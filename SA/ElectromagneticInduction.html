<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>電磁感應 3D 實驗室</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@800&family=Noto+Sans+TC:wght@400;700;900&display=swap');

        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; 
            background-color: #ffffff; font-family: 'Noto Sans TC', sans-serif; touch-action: none; 
        }

        .main-container { display: flex; flex-direction: column; height: 100vh; width: 100vw; }

        /* 上方：實驗區 */
        #experiment-area { 
            flex: 3; position: relative; background-color: #ffffff; border-bottom: 2px solid #f1f5f9; 
        }

        /* 下方：控制區 */
        #control-area { 
            flex: 2; background-color: #f8fafc; padding: 12px 20px; overflow-y: auto; 
            box-shadow: 0 -4px 15px rgba(0,0,0,0.05); z-index: 10; 
        }

        .hud-overlay { 
            position: absolute; top: 15px; left: 15px; right: 15px; display: flex; 
            flex-direction: column; gap: 8px; pointer-events: none; 
        }

        .hud-row { display: flex; justify-content: space-between; align-items: flex-start; }

        .glass-tag { 
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); 
            border: 1px solid rgba(0, 0, 0, 0.05); padding: 8px 14px; border-radius: 14px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.04);
        }

        #currentLabel { 
            position: absolute; color: #f97316; font-family: 'JetBrains Mono', monospace; 
            font-weight: 800; font-size: 1.3rem; pointer-events: none; opacity: 0; z-index: 100; 
        }

        input[type=range] { -webkit-appearance: none; background: transparent; height: 38px; width: 100%; }
        input[type=range]::-webkit-slider-thumb { 
            -webkit-appearance: none; height: 28px; width: 28px; border-radius: 50%; 
            background: #0ea5e9; border: 3px solid #ffffff; margin-top: -10px; 
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1); 
        }
        input[type=range]::-webkit-slider-runnable-track { height: 6px; background: #e2e8f0; border-radius: 3px; }

        .btn-round { 
            width: 52px; height: 52px; background: white; border: 1px solid #e2e8f0; 
            border-radius: 16px; display: flex; align-items: center; justify-content: center; 
            transition: all 0.2s; 
        }
        .btn-round:active { transform: scale(0.9); background: #f1f5f9; }
    </style>
</head>
<body>

<div class="main-container">
    <div id="experiment-area">
        <div id="currentLabel">I = 0.00 A</div>
        <div class="hud-overlay">
            <div class="hud-row">
                <div class="glass-tag">
                    <h1 class="text-slate-900 text-base font-black tracking-tight leading-tight">電磁感應</h1>
                    <p class="text-[9px] text-slate-500 font-bold uppercase tracking-widest mt-0.5">Electromagnetic Induction</p>
                    <div class="flex items-center gap-1.5 mt-2">
                        <div class="w-1.5 h-1.5 rounded-full bg-emerald-500 animate-pulse"></div>
                        <span class="text-[8px] text-emerald-600 font-bold uppercase">Physics Lab Ready</span>
                    </div>
                </div>
                <div class="flex flex-col gap-2 items-end">
                    <div class="glass-tag text-right min-w-[120px]">
                        <span class="text-[9px] text-slate-400 font-bold uppercase block mb-1">感應電流 (I)</span>
                        <div id="hudAmp" class="text-xl font-black text-orange-600 font-mono leading-none">0.00 A</div>
                    </div>
                    <div id="fluxCounter" class="glass-tag text-right min-w-[120px] hidden">
                        <span class="text-[9px] text-emerald-600 font-bold uppercase block mb-1">通過線圈磁力線數</span>
                        <div class="text-xl font-black text-emerald-600 font-mono leading-none">
                            <span id="fluxLinesCount">0</span> <span class="text-xs">條</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="canvas-container" class="w-full h-full"></div>
    </div>

    <div id="control-area">
        <div class="max-w-md mx-auto space-y-4">
            <div class="grid grid-cols-1 gap-3">
                <div class="flex flex-col">
                    <div class="flex justify-between items-center px-1">
                        <span class="text-[10px] font-black text-slate-400 uppercase">磁鐵中心位置 (Magnet)</span>
                        <span id="magText" class="text-xs font-bold text-sky-600">0.0</span>
                    </div>
                    <input type="range" id="magSlider" min="-30" max="30" step="0.1" value="-15">
                </div>
                <div class="flex flex-col">
                    <div class="flex justify-between items-center px-1">
                        <span class="text-[10px] font-black text-slate-400 uppercase">線圈中心位置 (Coil)</span>
                        <span id="coilText" class="text-xs font-bold text-sky-600">0.0</span>
                    </div>
                    <input type="range" id="coilSlider" min="-30" max="30" step="0.1" value="0">
                </div>
            </div>

            <div class="flex items-center gap-4">
                <div class="flex-1">
                    <div class="flex justify-between items-center px-1">
                        <span class="text-[10px] font-black text-slate-400 uppercase">線圈傾斜角度 θ</span>
                        <span id="angleText" class="text-xs font-bold text-sky-600">0°</span>
                    </div>
                    <input type="range" id="angleSlider" min="0" max="90" step="1" value="0">
                </div>
                <div class="flex gap-2">
                    <button id="flipBtn" class="btn-round" title="翻轉磁極">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                        </svg>
                    </button>
                    <button id="linesToggle" class="btn-round" title="顯示磁力線">
                        <svg id="linesIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-slate-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * 物理配色與視覺參數
 */
const COLORS = {
    bg: 0xffffff,
    magnetN: 0xdc2626, // 紅色
    magnetS: 0x2563eb, // 藍色
    copper: 0xb45309,
    fluxLine: 0x22c55e,
    induced: 0xf97316
};

let scene, camera, renderer, controls;
let magnetGroup, coilGroup, currentArrowGroup, fieldLinesGroup;
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

let state = {
    magX: -15,
    coilX: 0,
    coilAngle: 0,
    polarity: 1, // 1: N在右, -1: S在右
    showLines: false,
    lastFlux: 0,
    inducedI: 0
};

function init() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.bg);

    camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 22, 65);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 1.9;

    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    
    magnetGroup = new THREE.Group();
    coilGroup = new THREE.Group();
    fieldLinesGroup = new THREE.Group();
    
    scene.add(magnetGroup);
    scene.add(coilGroup);
    scene.add(fieldLinesGroup);

    createMagnet();
    createCoil();
    createFieldLines();

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', () => controls.enabled = true);

    setupUI();
    animate();
}

function createMagnet() {
    magnetGroup.clear();
    const body = new THREE.Group();
    const r = 1.3, h = 6.5;
    const geo = new THREE.CylinderGeometry(r, r, h/2, 32).rotateZ(Math.PI/2);
    
    const mRight = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: state.polarity === 1 ? COLORS.magnetN : COLORS.magnetS }));
    mRight.position.x = h/4;
    body.add(mRight);

    const mLeft = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: state.polarity === 1 ? COLORS.magnetS : COLORS.magnetN }));
    mLeft.position.x = -h/4;
    body.add(mLeft);

    const createLabel = (txt, color) => {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.font = 'bold 100px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.strokeStyle = 'white'; ctx.lineWidth = 15;
        ctx.strokeText(txt, 64, 64);
        ctx.fillText(txt, 64, 64);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
        sprite.scale.set(3, 3, 1);
        return sprite;
    };

    const labelR = createLabel(state.polarity === 1 ? "N" : "S", state.polarity === 1 ? "#dc2626" : "#2563eb");
    labelR.position.set(h/2-0.5, r+1.3, 0);
    body.add(labelR);

    const labelL = createLabel(state.polarity === 1 ? "S" : "N", state.polarity === 1 ? "#2563eb" : "#dc2626");
    labelL.position.set(-h/2+0.5, r+1.3, 0);
    body.add(labelL);

    body.name = "MAGNET_BODY";
    magnetGroup.add(body);
    magnetGroup.position.x = state.magX;
}

function createCoil() {
    coilGroup.clear();
    const mat = new THREE.MeshStandardMaterial({ color: COLORS.copper, metalness: 0.8, roughness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.TorusGeometry(5.5, 0.45, 16, 64).rotateY(Math.PI/2), mat);
    mesh.name = "COIL_BODY";
    coilGroup.add(mesh);
    currentArrowGroup = new THREE.Group();
    coilGroup.add(currentArrowGroup);
    coilGroup.position.x = state.coilX;
}

function createFieldLines() {
    fieldLinesGroup.clear();
    const tubeRadius = 0.035; 
    const tubeMat = new THREE.MeshBasicMaterial({ 
        color: COLORS.fluxLine, 
        transparent: true, 
        opacity: 0.15, 
        depthWrite: false 
    });
    
    const h = 6.5;
    const numLoops = 10; 
    const layers = 6;    

    for (let i = 0; i < numLoops; i++) {
        const angle = (i / numLoops) * Math.PI * 2;
        for (let j = 1; j <= layers; j++) {
            const curveWidth = 30 * j; 
            const curveHeight = 5 * j; 
            const p = state.polarity;
            const startX = (h/2) * p, endX = -(h/2) * p;

            const curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(startX, 0, 0),
                new THREE.Vector3(startX + curveWidth * p, curveHeight, 0),
                new THREE.Vector3(endX - curveWidth * p, curveHeight, 0),
                new THREE.Vector3(endX, 0, 0)
            );

            const pts = curve.getPoints(60).map(pt => new THREE.Vector3(pt.x, pt.y * Math.cos(angle), pt.y * Math.sin(angle)));
            const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 60, tubeRadius, 6, false);
            const line = new THREE.Mesh(tubeGeo, tubeMat);
            fieldLinesGroup.add(line);

            if (j % 2 === 0) {
                const t = 0.5, pos = curve.getPoint(t);
                const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.5, 6), new THREE.MeshBasicMaterial({color: COLORS.fluxLine, transparent: true, opacity: 0.3}));
                arrow.position.set(pos.x, pos.y * Math.cos(angle), pos.y * Math.sin(angle));
                const tan = curve.getTangent(t).normalize();
                const worldTan = new THREE.Vector3(tan.x, tan.y * Math.cos(angle), tan.y * Math.sin(angle)).normalize();
                arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), worldTan);
                fieldLinesGroup.add(arrow);
            }
        }
    }
    fieldLinesGroup.visible = state.showLines;
}

/**
 * 修正感應電流視覺
 * 箭頭固定從 12 點鐘出發
 */
function updateInductionVisuals(val) {
    const absVal = Math.abs(val);
    const label = document.getElementById('currentLabel');
    const hudAmp = document.getElementById('hudAmp');
    
    hudAmp.innerText = `${absVal.toFixed(2)} A`;
    
    if (absVal > 0.05) {
        label.innerText = `I = ${val.toFixed(2)} A`;
        label.style.opacity = 1;
        const v = new THREE.Vector3(state.coilX, 7.5, 0);
        v.project(camera);
        const container = document.getElementById('experiment-area');
        const x = (v.x * 0.5 + 0.5) * container.clientWidth;
        const y = (-(v.y * 0.5) + 0.5) * container.clientHeight;
        label.style.left = `${x}px`;
        label.style.top = `${y - 40}px`;
    } else {
        label.style.opacity = 0;
    }

    currentArrowGroup.clear();
    if (absVal > 0.1) {
        const arrowRadius = 6.4;
        const arcLength = Math.min(Math.PI * 0.5, absVal * 0.15); 
        const startAngle = Math.PI / 2;
        
        /**
         * 冷次定律方向修正：
         * 根據使用者回饋，交換 val > 0 與 val < 0 的生長方向
         */
        const isClockwise = val > 0; // 交換正負流向
        const endAngle = isClockwise ? startAngle - arcLength : startAngle + arcLength;
        
        const curve = new THREE.EllipseCurve(0, 0, arrowRadius, arrowRadius, startAngle, endAngle, isClockwise);
        const pts = curve.getPoints(25).map(p => new THREE.Vector3(0, p.y, p.x));
        
        const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 20, 0.22, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ color: COLORS.induced });
        const tubeMesh = new THREE.Mesh(tubeGeo, tubeMat);
        currentArrowGroup.add(tubeMesh);
        
        const cone = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.3, 12), tubeMat);
        const tipPos = pts[pts.length - 1];
        cone.position.copy(tipPos);
        
        const tangent = new THREE.Vector3(0, Math.cos(endAngle), -Math.sin(endAngle)).normalize();
        if (isClockwise) tangent.multiplyScalar(-1); 
        cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
        currentArrowGroup.add(cone);
    }
}

function calculatePhysics() {
    const fluxDir = state.polarity; 
    const dist = state.coilX - state.magX;
    const angleRad = state.coilAngle * Math.PI / 180;
    
    // 磁通量模擬
    const flux = (350 / (dist * dist + 50)) * Math.cos(angleRad) * fluxDir;
    const dFlux = flux - state.lastFlux;
    
    // 冷次定律 I = -dPhi / dt
    const targetI = -dFlux * 55; 
    
    state.inducedI += (targetI - state.inducedI) * 0.18;
    state.lastFlux = flux;
    
    const linesCount = Math.round(Math.abs(flux) * 12);
    document.getElementById('fluxLinesCount').innerText = linesCount;
    
    updateInductionVisuals(state.inducedI);
}

function onPointerDown(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    for (let intersect of intersects) {
        let obj = intersect.object;
        while(obj.parent && !obj.name) obj = obj.parent;
        if (obj.name === "MAGNET_BODY" || obj.name === "COIL_BODY") { controls.enabled = false; break; }
    }
}

function onPointerMove(e) {
    if (controls.enabled) return;
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersectPos = new THREE.Vector3();
    raycaster.ray.intersectPlane(dragPlane, intersectPos);
    
    const limit = 30;
    const newX = Math.max(-limit, Math.min(limit, intersectPos.x));
    if (Math.abs(newX - state.magX) < Math.abs(newX - state.coilX)) {
        state.magX = newX;
        document.getElementById('magSlider').value = newX;
        document.getElementById('magText').innerText = newX.toFixed(1);
    } else {
        state.coilX = newX;
        document.getElementById('coilSlider').value = newX;
        document.getElementById('coilText').innerText = newX.toFixed(1);
    }
}

function onResize() {
    const container = document.getElementById('experiment-area');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

function setupUI() {
    document.getElementById('magSlider').addEventListener('input', (e) => {
        state.magX = parseFloat(e.target.value);
        document.getElementById('magText').innerText = state.magX.toFixed(1);
    });
    document.getElementById('coilSlider').addEventListener('input', (e) => {
        state.coilX = parseFloat(e.target.value);
        document.getElementById('coilText').innerText = state.coilX.toFixed(1);
    });
    document.getElementById('angleSlider').addEventListener('input', (e) => {
        state.coilAngle = parseFloat(e.target.value);
        document.getElementById('angleText').innerText = `${state.coilAngle}°`;
    });
    document.getElementById('linesToggle').addEventListener('click', () => {
        state.showLines = !state.showLines;
        fieldLinesGroup.visible = state.showLines;
        document.getElementById('fluxCounter').classList.toggle('hidden', !state.showLines);
        document.getElementById('linesIcon').classList.toggle('text-emerald-500', state.showLines);
        document.getElementById('linesIcon').classList.toggle('text-slate-300', !state.showLines);
    });
    document.getElementById('flipBtn').addEventListener('click', () => {
        state.polarity *= -1;
        createMagnet();
        createFieldLines();
    });
}

function animate() {
    requestAnimationFrame(animate);
    magnetGroup.position.x = state.magX;
    coilGroup.position.x = state.coilX;
    coilGroup.rotation.z = state.coilAngle * Math.PI / 180;
    fieldLinesGroup.position.x = state.magX;
    calculatePhysics();
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
