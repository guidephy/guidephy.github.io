<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>電磁感應 3D 實驗室 - 橫向優化版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@800&family=Noto+Sans+TC:wght@400;700;900&display=swap');

        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; 
            background-color: #ffffff; font-family: 'Noto Sans TC', sans-serif; touch-action: none; 
        }

        /* 主容器：支援響應式分向 */
        .main-container { 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            width: 100vw; 
        }

        /* 橫向模式 (Landscape) 下的佈局調整 */
        @media (orientation: landscape) {
            .main-container { flex-direction: row; }
            #experiment-area { flex: 1.6 !important; border-bottom: none !important; border-right: 2px solid #f1f5f9; }
            #control-area { flex: 1.2 !important; height: 100%; padding: 20px !important; }
        }

        /* 上方/左側：實驗區 */
        #experiment-area { 
            flex: 1.3; position: relative; background-color: #ffffff; border-bottom: 2px solid #f1f5f9; 
            min-height: 40%;
        }

        /* 下方/右側：控制區 */
        #control-area { 
            flex: 1; background-color: #f8fafc; padding: 12px 20px; overflow-y: auto; 
            box-shadow: 0 -4px 15px rgba(0,0,0,0.05); z-index: 10; 
        }

        .hud-overlay { 
            position: absolute; top: 12px; left: 12px; right: 12px; display: flex; 
            flex-direction: column; gap: 6px; pointer-events: none; 
        }

        .hud-row { display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; }

        .glass-tag { 
            background: rgba(255, 255, 255, 0.96); backdrop-filter: blur(10px); 
            border: 1px solid rgba(0, 0, 0, 0.08); padding: 10px 16px; border-radius: 18px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            white-space: nowrap;
        }

        /* 浮動標籤：兩行顯示、置中 */
        #currentLabel { 
            position: absolute; color: #ea580c; font-family: 'JetBrains Mono', monospace; 
            font-weight: 800; font-size: 1.2rem; pointer-events: none; opacity: 0; z-index: 100; 
            text-shadow: 0 0 10px rgba(255,255,255,0.9);
            text-align: center;
            line-height: 1.1;
            white-space: nowrap;
        }

        /* 滑桿優化 */
        input[type=range] { -webkit-appearance: none; background: transparent; height: 40px; width: 100%; }
        input[type=range]::-webkit-slider-thumb { 
            -webkit-appearance: none; height: 32px; width: 32px; border-radius: 50%; 
            background: #0ea5e9; border: 4px solid #ffffff; margin-top: -11px; 
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); 
        }
        input[type=range]::-webkit-slider-runnable-track { height: 10px; background: #e2e8f0; border-radius: 5px; }

        /* 按鈕設計 */
        .btn-action { 
            flex: 1; height: 74px; background: white; border: 2px solid #e2e8f0; 
            border-radius: 20px; display: flex; flex-direction: column; align-items: center; 
            justify-content: center; transition: all 0.2s; gap: 4px;
            white-space: nowrap;
        }
        .btn-action:active { transform: scale(0.95); background: #f1f5f9; border-color: #0ea5e9; }
        .btn-active { border-color: #10b981; background: #f0fdf4; }
        
        .label-text { font-size: 14px; font-weight: 900; color: #64748b; text-transform: uppercase; white-space: nowrap; }
        .value-text { font-size: 16px; font-weight: 900; color: #0284c7; }
    </style>
</head>
<body>

<div class="main-container">
    <div id="experiment-area">
        <!-- 感應電流標籤：兩行 -->
        <div id="currentLabel">Induced current<br>= 0.00 A</div>
        
        <div class="hud-overlay">
            <div class="hud-row">
                <div class="glass-tag flex-shrink-0">
                    <h1 class="text-slate-900 text-2xl font-black tracking-tighter leading-none whitespace-nowrap">電磁感應</h1>
                    <p class="text-[10px] text-slate-500 font-bold uppercase tracking-[0.1em] mt-1 whitespace-nowrap">Electromagnetic Induction</p>
                </div>
                <div class="flex flex-col gap-2 items-end flex-1">
                    <div id="fluxCounter" class="glass-tag text-right min-w-[130px] hidden">
                        <span class="text-[10px] text-emerald-600 font-black uppercase block mb-1 tracking-wider whitespace-nowrap">通過線圈磁力線數</span>
                        <div class="text-2xl font-black text-emerald-600 font-mono leading-none">
                            <span id="fluxLinesCount">0</span> <span class="text-sm">條</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="canvas-container" class="w-full h-full"></div>
    </div>

    <div id="control-area">
        <div class="max-w-xl mx-auto space-y-5">
            <!-- 位置控制組 -->
            <div class="space-y-4">
                <div class="flex flex-col">
                    <div class="flex justify-between items-center px-1">
                        <span class="label-text">磁鐵中心位置 (Magnet)</span>
                        <span id="magText" class="value-text">0.0</span>
                    </div>
                    <input type="range" id="magSlider" min="-30" max="30" step="0.1" value="-15">
                </div>
                <div class="flex flex-col">
                    <div class="flex justify-between items-center px-1">
                        <span class="label-text">線圈中心位置 (Coil)</span>
                        <span id="coilText" class="value-text">0.0</span>
                    </div>
                    <input type="range" id="coilSlider" min="-30" max="30" step="0.1" value="0">
                </div>
            </div>

            <!-- 線圈角度控制 -->
            <div class="flex flex-col">
                <div class="flex justify-between items-center px-1">
                    <span class="label-text">線圈傾斜角度 θ</span>
                    <span id="angleText" class="value-text">0°</span>
                </div>
                <input type="range" id="angleSlider" min="0" max="90" step="1" value="0">
            </div>

            <!-- 按鈕組 -->
            <div class="flex gap-4 pt-1">
                <button id="flipBtn" class="btn-action">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-slate-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                    </svg>
                    <span class="text-[12px] font-black text-slate-700 uppercase leading-none">磁極交換</span>
                </button>
                <button id="linesToggle" class="btn-action">
                    <svg id="linesIcon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-slate-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                    <span id="linesText" class="text-[12px] font-black text-slate-400 uppercase leading-none">顯示磁力線</span>
                </button>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * 物理配色與參數
 */
const COLORS = {
    bg: 0xffffff,
    magnetN: 0xdc2626, 
    magnetS: 0x2563eb, 
    copper: 0xb45309,
    fluxLine: 0x10b981,
    induced: 0xea580c // 修正了語法錯誤：補上了 0x 前綴
};

let scene, camera, renderer, controls;
let magnetGroup, coilGroup, currentArrowGroup, fieldLinesGroup;
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

let state = {
    magX: -15,
    coilX: 0,
    coilAngle: 0,
    polarity: 1, 
    showLines: false,
    lastFlux: 0,
    inducedI: 0
};

function init() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.bg);

    camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 22, 65);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.maxPolarAngle = Math.PI / 1.9;

    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    
    magnetGroup = new THREE.Group();
    coilGroup = new THREE.Group();
    fieldLinesGroup = new THREE.Group();
    
    scene.add(magnetGroup);
    scene.add(coilGroup);
    scene.add(fieldLinesGroup);

    createMagnet();
    createCoil();
    createFieldLines();

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', () => controls.enabled = true);

    setupUI();
    animate();
}

function createMagnet() {
    magnetGroup.clear();
    const body = new THREE.Group();
    const r = 1.3, h = 6.5;
    const geo = new THREE.CylinderGeometry(r, r, h/2, 32).rotateZ(Math.PI/2);
    
    const mRight = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: state.polarity === 1 ? COLORS.magnetN : COLORS.magnetS }));
    mRight.position.x = h/4;
    body.add(mRight);

    const mLeft = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: state.polarity === 1 ? COLORS.magnetS : COLORS.magnetN }));
    mLeft.position.x = -h/4;
    body.add(mLeft);

    const createLabel = (txt, color) => {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.font = 'bold 100px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.strokeStyle = 'white'; ctx.lineWidth = 15;
        ctx.strokeText(txt, 64, 64);
        ctx.fillText(txt, 64, 64);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
        sprite.scale.set(3, 3, 1);
        return sprite;
    };

    const labelR = createLabel(state.polarity === 1 ? "N" : "S", state.polarity === 1 ? "#dc2626" : "#2563eb");
    labelR.position.set(h/2-0.5, r+1.3, 0);
    body.add(labelR);

    const labelL = createLabel(state.polarity === 1 ? "S" : "N", state.polarity === 1 ? "#2563eb" : "#dc2626");
    labelL.position.set(-h/2+0.5, r+1.3, 0);
    body.add(labelL);

    body.name = "MAGNET_BODY";
    magnetGroup.add(body);
    magnetGroup.position.x = state.magX;
}

function createCoil() {
    coilGroup.clear();
    const mat = new THREE.MeshStandardMaterial({ color: COLORS.copper, metalness: 0.8, roughness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.TorusGeometry(5.5, 0.45, 16, 64).rotateY(Math.PI/2), mat);
    mesh.name = "COIL_BODY";
    coilGroup.add(mesh);
    currentArrowGroup = new THREE.Group();
    coilGroup.add(currentArrowGroup);
    coilGroup.position.x = state.coilX;
}

function createFieldLines() {
    fieldLinesGroup.clear();
    const tubeRadius = 0.035; 
    const tubeMat = new THREE.MeshBasicMaterial({ color: COLORS.fluxLine, transparent: true, opacity: 0.15, depthWrite: false });
    const h = 6.5, numLoops = 10, layers = 6;    

    for (let i = 0; i < numLoops; i++) {
        const angle = (i / numLoops) * Math.PI * 2;
        for (let j = 1; j <= layers; j++) {
            const curveWidth = 30 * j, curveHeight = 5 * j; 
            const p = state.polarity;
            const startX = (h/2) * p, endX = -(h/2) * p;
            const curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(startX, 0, 0),
                new THREE.Vector3(startX + curveWidth * p, curveHeight, 0),
                new THREE.Vector3(endX - curveWidth * p, curveHeight, 0),
                new THREE.Vector3(endX, 0, 0)
            );
            const pts = curve.getPoints(60).map(pt => new THREE.Vector3(pt.x, pt.y * Math.cos(angle), pt.y * Math.sin(angle)));
            const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 60, tubeRadius, 6, false);
            fieldLinesGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
        }
    }
    fieldLinesGroup.visible = state.showLines;
}

function updateInductionVisuals(val) {
    const absVal = Math.abs(val);
    const label = document.getElementById('currentLabel');
    if (absVal > 0.05) {
        label.innerHTML = `Induced current<br>= ${absVal.toFixed(2)} A`;
        label.style.opacity = 1;
        const v = new THREE.Vector3(state.coilX, 7.5, 0);
        v.project(camera);
        const container = document.getElementById('experiment-area');
        const x = (v.x * 0.5 + 0.5) * container.clientWidth;
        const y = (-(v.y * 0.5) + 0.5) * container.clientHeight;
        label.style.left = `${x}px`;
        label.style.top = `${y - 45}px`;
        label.style.transform = 'translateX(-50%)';
    } else {
        label.style.opacity = 0;
    }

    currentArrowGroup.clear();
    if (absVal > 0.1) {
        const arrowRadius = 6.4;
        const arcLength = Math.min(Math.PI * 0.5, absVal * 0.15); 
        const startAngle = Math.PI / 2;
        const isClockwise = val > 0; 
        const endAngle = isClockwise ? startAngle - arcLength : startAngle + arcLength;
        const curve = new THREE.EllipseCurve(0, 0, arrowRadius, arrowRadius, startAngle, endAngle, isClockwise);
        const pts = curve.getPoints(25).map(p => new THREE.Vector3(0, p.y, p.x));
        const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 20, 0.22, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ color: COLORS.induced });
        currentArrowGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
        
        const cone = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.3, 12), tubeMat);
        cone.position.copy(pts[pts.length - 1]);
        const tangent = new THREE.Vector3(0, Math.cos(endAngle), -Math.sin(endAngle)).normalize();
        if (isClockwise) tangent.multiplyScalar(-1); 
        cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
        currentArrowGroup.add(cone);
    }
}

function calculatePhysics() {
    const fluxDir = state.polarity; 
    const dist = state.coilX - state.magX;
    const angleRad = state.coilAngle * Math.PI / 180;
    const flux = (350 / (dist * dist + 50)) * Math.cos(angleRad) * fluxDir;
    const dFlux = flux - state.lastFlux;
    const targetI = -dFlux * 55; 
    state.inducedI += (targetI - state.inducedI) * 0.18;
    state.lastFlux = flux;
    if (document.getElementById('fluxLinesCount')) document.getElementById('fluxLinesCount').innerText = Math.round(Math.abs(flux) * 12);
    updateInductionVisuals(state.inducedI);
}

function onPointerDown(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    for (let intersect of intersects) {
        let obj = intersect.object;
        while(obj.parent && !obj.name) obj = obj.parent;
        if (obj.name === "MAGNET_BODY" || obj.name === "COIL_BODY") { controls.enabled = false; break; }
    }
}

function onPointerMove(e) {
    if (controls.enabled) return;
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersectPos = new THREE.Vector3();
    raycaster.ray.intersectPlane(dragPlane, intersectPos);
    const limit = 30;
    const newX = Math.max(-limit, Math.min(limit, intersectPos.x));
    if (Math.abs(newX - state.magX) < Math.abs(newX - state.coilX)) {
        state.magX = newX;
        document.getElementById('magSlider').value = newX;
        document.getElementById('magText').innerText = newX.toFixed(1);
    } else {
        state.coilX = newX;
        document.getElementById('coilSlider').value = newX;
        document.getElementById('coilText').innerText = newX.toFixed(1);
    }
}

function onResize() {
    const container = document.getElementById('experiment-area');
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
}

function setupUI() {
    document.getElementById('magSlider').addEventListener('input', (e) => {
        state.magX = parseFloat(e.target.value);
        document.getElementById('magText').innerText = state.magX.toFixed(1);
    });
    document.getElementById('coilSlider').addEventListener('input', (e) => {
        state.coilX = parseFloat(e.target.value);
        document.getElementById('coilText').innerText = state.coilX.toFixed(1);
    });
    document.getElementById('angleSlider').addEventListener('input', (e) => {
        state.coilAngle = parseFloat(e.target.value);
        document.getElementById('angleText').innerText = `${state.coilAngle}°`;
    });
    document.getElementById('linesToggle').addEventListener('click', () => {
        state.showLines = !state.showLines;
        fieldLinesGroup.visible = state.showLines;
        const btn = document.getElementById('linesToggle'), icon = document.getElementById('linesIcon'), text = document.getElementById('linesText');
        document.getElementById('fluxCounter').classList.toggle('hidden', !state.showLines);
        if (state.showLines) {
            btn.classList.add('btn-active');
            icon.classList.replace('text-slate-300', 'text-emerald-500');
            text.classList.replace('text-slate-400', 'text-emerald-600');
            text.innerText = "磁力線：開啟";
        } else {
            btn.classList.remove('btn-active');
            icon.classList.replace('text-emerald-500', 'text-slate-300');
            text.classList.replace('text-emerald-600', 'text-slate-400');
            text.innerText = "顯示磁力線";
        }
    });
    document.getElementById('flipBtn').addEventListener('click', () => {
        state.polarity *= -1;
        createMagnet();
        createFieldLines();
    });
}

function animate() {
    requestAnimationFrame(animate);
    magnetGroup.position.x = state.magX;
    coilGroup.position.x = state.coilX;
    coilGroup.rotation.z = state.coilAngle * Math.PI / 180;
    fieldLinesGroup.position.x = state.magX;
    calculatePhysics();
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
