<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>電磁感應 3D 實驗室</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Noto Sans TC', sans-serif; touch-action: none; }
        
        /* 底部控制面板動畫 */
        .bottom-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #0ea5e9;
            border: 2px solid #fff;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }

        #currentLabel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ea580c; 
            font-weight: 800;
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(255,255,255,0.8), 0 0 10px rgba(255,255,255,0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            white-space: nowrap;
            z-index: 5; 
        }

        /* 提示覆蓋層 */
        #gestureHint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            text-align: center;
            color: rgba(15, 23, 42, 0.6);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 4;
        }

        .toggle-checkbox:checked {
            background-color: #0ea5e9;
            border-color: #0ea5e9;
        }
        .toggle-checkbox:checked + div {
            transform: translateX(100%);
        }
        
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body>

<div id="currentLabel">I = 0.0 A</div>

<div id="gestureHint">
    <div class="text-4xl mb-2">↕</div>
    <div>上下滑動控制<br>線圈角度</div>
</div>

<!-- 頂部資訊列 -->
<div class="absolute top-0 left-0 right-0 p-4 flex justify-between items-start z-20 pointer-events-none">
    <div class="pointer-events-auto">
        <h1 class="text-lg font-bold text-slate-800 drop-shadow-sm">電磁感應</h1>
        <p class="text-[10px] text-slate-500">Faraday's Law</p>
    </div>
    
    <div class="pointer-events-auto bg-slate-800/90 backdrop-blur rounded-lg p-1 border border-slate-600/50 shadow-lg">
        <select id="modeSelect" class="bg-transparent text-xs text-white font-medium focus:outline-none p-1 pr-2 cursor-pointer">
            <option value="loop" class="text-black">環形線圈</option>
            <option value="solenoid" class="text-black">螺線管</option>
            <option value="uniformField" class="text-black">平行磁場</option>
        </select>
    </div>
</div>

<!-- 底部控制面板 -->
<div class="fixed bottom-0 left-0 right-0 z-30 bottom-panel shadow-[0_-4px_20px_rgba(0,0,0,0.1)]">
    
    <!-- 擴充設定區 -->
    <div id="expandedSettings" class="hidden px-5 py-4 space-y-5 border-b border-slate-700/50 max-h-[50vh] overflow-y-auto no-scrollbar">
        
        <div id="advancedControls" class="space-y-4 hidden">
            <!-- 角度控制桿 (加上 ID 以便程式控制隱藏) -->
            <div id="angleControlRow">
                <div class="flex justify-between mb-2">
                    <label class="text-xs text-slate-400">線圈角度 θ</label>
                    <span id="angleValue" class="text-xs text-sky-400 font-mono">0°</span>
                </div>
                <input type="range" id="angleSlider" min="0" max="90" step="1" value="0">
            </div>
            <div>
                <div class="flex justify-between mb-2">
                    <label class="text-xs text-slate-400">磁場強度 B</label>
                    <span id="BValue" class="text-xs text-sky-400 font-mono">0.80 T</span>
                </div>
                <input type="range" id="bSlider" min="0" max="1" step="0.01" value="0.8">
            </div>
        </div>

        <div class="grid grid-cols-2 gap-4">
            <label class="flex items-center space-x-3 cursor-pointer group">
                <input type="checkbox" id="linesToggle" class="sr-only peer">
                <div class="w-9 h-5 bg-slate-600 rounded-full peer peer-focus:ring-2 peer-focus:ring-sky-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-sky-500 relative"></div>
                <span class="text-xs text-slate-300 group-hover:text-white transition-colors">磁力線</span>
            </label>

            <label id="hideMagnetRow" class="flex items-center space-x-3 cursor-pointer group">
                <input type="checkbox" id="hideMagnetToggle" class="sr-only peer">
                <div class="w-9 h-5 bg-slate-600 rounded-full peer peer-focus:ring-2 peer-focus:ring-sky-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-sky-500 relative"></div>
                <span class="text-xs text-slate-300 group-hover:text-white transition-colors">隱藏磁鐵</span>
            </label>

            <label id="showProjRow" class="flex items-center space-x-3 cursor-pointer group hidden">
                <input type="checkbox" id="projToggle" class="sr-only peer">
                <div class="w-9 h-5 bg-slate-600 rounded-full peer peer-focus:ring-2 peer-focus:ring-sky-500 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-sky-500 relative"></div>
                <span class="text-xs text-slate-300 group-hover:text-white transition-colors">投影面積</span>
            </label>
        </div>
    </div>

    <!-- 主要控制列 -->
    <div class="px-4 py-4 flex items-center gap-4">
        <button id="settingsBtn" class="p-3 rounded-full bg-slate-700/50 text-slate-300 hover:bg-slate-600 hover:text-white transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        </button>

        <div class="flex-1 relative">
            <label id="positionLabel" class="absolute -top-5 left-0 text-[10px] text-slate-400">位置</label>
            <input type="range" id="positionSlider" min="-18" max="18" step="0.1" value="-12">
        </div>

        <button id="flipBtn" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold rounded-full shadow-lg transition-transform active:scale-95 whitespace-nowrap">
            翻轉 N/S
        </button>
    </div>
</div>

<div id="canvas-container"></div>

<script>
const CONFIG = {
    bg: 0xffffff, 
    wireColor: 0xcd7f32,
    magnetNColor: 0xdc2626,
    magnetSColor: 0x2563eb,
    inducedColor: 0xea580c, 
    fluxLineColor: 0x94a3b8, 
    uniformFluxColor: 0x0ea5e9, // Sky Blue 500
    highlightColor: 0xcccccc
};

let state = {
    mode: 'loop',
    position: -12,
    lastPosition: -12,
    inducedCurrent: 0,
    targetCurrent: 0,
    showFluxLines: false,
    showMagnetBody: true,
    polarity: 1,
    isDragging: false,
    loopAngleDeg: 0,
    lastFluxUniform: 0,
    BStrength: 0.8,
    showProjection: false,
    isSwipeMode: false, 
};

const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

let scene, camera, renderer, controls;
let coilGroup = new THREE.Group();
let magnetGroup = new THREE.Group();
let magnetBodyGroup = new THREE.Group();
let currentArrowGroup = new THREE.Group();
let magnetFieldLines = new THREE.Group();
let uniformFieldGroup = new THREE.Group();
let projectedAreaMesh = null; 

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let dragPlane;

const currentLabel = document.getElementById('currentLabel');
const gestureHint = document.getElementById('gestureHint');
let labelTargetPos = new THREE.Vector3(0, 0, 0);

// Camera target for animation
let targetCameraPos = new THREE.Vector3(0, 20, 40);
let targetLookAt = new THREE.Vector3(0, 0, 0);

// Touch interaction tracking
let lastPointerX = 0;
let lastPointerY = 0;

function init() {
    const container = document.getElementById('canvas-container');

    scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.bg);
    scene.fog = new THREE.Fog(CONFIG.bg, 30, 80); 

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 20, 40);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = !isMobile; 
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 1.5; 

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = !isMobile; 
    if(!isMobile) {
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
    }
    scene.add(dirLight);

    const backLight = new THREE.DirectionalLight(0x38bdf8, 0.2);
    backLight.position.set(-10, 10, -20);
    scene.add(backLight);

    dragPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    dragPlane.rotation.x = -Math.PI / 2;
    scene.add(dragPlane);

    scene.add(coilGroup);
    magnetGroup.add(magnetBodyGroup);
    magnetGroup.add(magnetFieldLines);
    scene.add(magnetGroup);

    createUniformField();
    scene.add(uniformFieldGroup);
    uniformFieldGroup.visible = false;

    createMagnet();
    rebuildCoil();
    createProjectedAreaDisc(); 

    window.addEventListener('resize', onWindowResize);
    container.addEventListener('pointerdown', onPointerDown);
    container.addEventListener('pointermove', onPointerMove);
    container.addEventListener('pointerup', onPointerUp);
    container.addEventListener('pointerleave', onPointerUp);

    setupUI();
    animate();
}

function updateHighlight(group, highlight) {
    // 移除所有發光與縮放效果，保持物體原樣
}

function onPointerDown(event) {
    if(event.target !== renderer.domElement) return;

    // Record start position for swipe
    lastPointerX = event.clientX;
    lastPointerY = event.clientY;

    if (state.isSwipeMode) {
        state.isDragging = true;
        // Don't disable controls here, we manage camera manually in animate
        document.body.style.cursor = 'grabbing';
        return;
    }

    if (!state.showMagnetBody && state.mode !== 'uniformField') return;

    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    if (state.showMagnetBody) {
        const intersects = raycaster.intersectObjects(magnetBodyGroup.children, true);
        if (intersects.length > 0) {
            state.isDragging = true;
            controls.enabled = false;
            document.body.style.cursor = 'grabbing';
            // Simple highlight effect removed
            return;
        }
    }
}

function onPointerMove(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    // --- Swipe Mode Logic (Uniform Field) ---
    if (state.isSwipeMode && state.isDragging) {
        // Horizontal logic removed
        const dy = event.clientY - lastPointerY;
        
        lastPointerX = event.clientX;
        lastPointerY = event.clientY;

        // Vertical drag -> Angle
        const angleSensitivity = 0.5;
        let newAngle = state.loopAngleDeg + dy * angleSensitivity;
        newAngle = Math.max(0, Math.min(90, newAngle));
        state.loopAngleDeg = newAngle;
        document.getElementById('angleSlider').value = newAngle;
        document.getElementById('angleValue').textContent = `${Math.round(newAngle)}°`;

        return; 
    }

    // --- Normal Object Drag Logic ---
    raycaster.setFromCamera(mouse, camera);

    if (state.isDragging && !state.isSwipeMode) {
        const intersects = raycaster.intersectObject(dragPlane);
        if (intersects.length > 0) {
            let point = intersects[0].point;
            let newX = Math.max(-18, Math.min(18, point.x));
            state.position = newX;
            document.getElementById('positionSlider').value = newX;
        }
    }
}

function onPointerUp() {
    state.isDragging = false;
    if (!state.isSwipeMode) {
        controls.enabled = true;
    }
    document.body.style.cursor = 'default';
}

function createLabelSprite(text) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.font = 'bold 90px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
    ctx.shadowBlur = 4;
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 4;
    ctx.strokeText(text, 64, 64);
    ctx.fillText(text, 64, 64);
    const tex = new THREE.CanvasTexture(canvas);
    return new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
}

function createMagnet() {
    while(magnetBodyGroup.children.length > 0) magnetBodyGroup.remove(magnetBodyGroup.children[0]);
    const radius = 1.2, length = 6;
    const geo = new THREE.CylinderGeometry(radius, radius, length/2, 24).rotateZ(Math.PI/2);
    const nMat = new THREE.MeshPhongMaterial({ color: CONFIG.magnetNColor, shininess: 100 });
    const sMat = new THREE.MeshPhongMaterial({ color: CONFIG.magnetSColor, shininess: 100 });
    const rightMat = state.polarity === 1 ? nMat : sMat;
    const leftMat = state.polarity === 1 ? sMat : nMat;
    
    const rightPole = new THREE.Mesh(geo, rightMat); rightPole.position.x = length/4;
    magnetBodyGroup.add(rightPole);
    const leftPole = new THREE.Mesh(geo, leftMat); leftPole.position.x = -length/4;
    magnetBodyGroup.add(leftPole);

    const l1 = createLabelSprite(state.polarity===1?"N":"S"); l1.position.set(length/2-0.4, radius+0.8, 0); l1.scale.set(2.5,2.5,1);
    magnetBodyGroup.add(l1);
    const l2 = createLabelSprite(state.polarity===1?"S":"N"); l2.position.set(-length/2+0.4, radius+0.8, 0); l2.scale.set(2.5,2.5,1);
    magnetBodyGroup.add(l2);
    
    createMagnetFieldLines(length, radius);
    magnetFieldLines.visible = state.showFluxLines; 
    magnetGroup.position.x = state.position;
}

function createMagnetFieldLines(length, radius) {
    magnetFieldLines.clear();
    const material = new THREE.LineBasicMaterial({ color: CONFIG.fluxLineColor, transparent: true, opacity: 0.5 });
    const arrowGeo = new THREE.ConeGeometry(0.2, 0.6, 6); 
    const arrowMat = new THREE.MeshBasicMaterial({ color: CONFIG.fluxLineColor, transparent: true, opacity: 0.8 });
    const numStrands = 8, loopsPerAngle = 3; 
    for(let i=0; i<numStrands; i++) {
        const angle = (i / numStrands) * Math.PI * 2;
        for(let j=0; j<loopsPerAngle; j++) {
            const scale = 4.0 + j * 3.5; 
            const p = state.polarity;
            const startX = (length/2) * p, endX = -(length/2) * p;
            const stretch = 2.5 + j * 0.8, rHeight = scale * 0.8;
            const curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(startX, 0, 0),
                new THREE.Vector3(startX + scale*stretch*p, rHeight, 0),
                new THREE.Vector3(endX - scale*stretch*p, rHeight, 0),
                new THREE.Vector3(endX, 0, 0)
            );
            const points = curve.getPoints(30); 
            const rotatedPoints = points.map(pt => new THREE.Vector3(pt.x, pt.y*Math.cos(angle), pt.y*Math.sin(angle)));
            magnetFieldLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(rotatedPoints), material));
            const t = 0.5, pt = curve.getPoint(t), tan = curve.getTangent(t).normalize();
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.position.set(pt.x, pt.y*Math.cos(angle), pt.y*Math.sin(angle));
            arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), new THREE.Vector3(tan.x, tan.y*Math.cos(angle), tan.y*Math.sin(angle)).normalize());
            magnetFieldLines.add(arrow);
        }
    }
}

function rebuildCoil() {
    while(coilGroup.children.length > 0) coilGroup.remove(coilGroup.children[0]);
    currentArrowGroup = new THREE.Group();
    coilGroup.add(currentArrowGroup);
    const copperMat = new THREE.MeshStandardMaterial({ color: CONFIG.wireColor, metalness: 0.6, roughness: 0.4 });
    let mainMesh = null;

    if (state.mode === 'loop') {
        const geo = new THREE.TorusGeometry(6, 0.5, 12, 32).rotateY(Math.PI/2);
        mainMesh = new THREE.Mesh(geo, copperMat);
        currentArrowGroup.userData = { radius: 6.8, xPos: 0 };
    } else if (state.mode === 'solenoid') {
        class HelixCurve extends THREE.Curve {
            getPoint(t) {
                const angle = t * Math.PI * 2 * 10;
                return new THREE.Vector3((t - 0.5) * 12, 3.5 * Math.cos(angle), 3.5 * Math.sin(angle));
            }
        }
        mainMesh = new THREE.Mesh(new THREE.TubeGeometry(new HelixCurve(), 100, 0.3, 6, false), copperMat);
        currentArrowGroup.userData = { radius: 4.1, xPos: 0 };
    } else if (state.mode === 'uniformField') {
        mainMesh = new THREE.Mesh(new THREE.TorusGeometry(6, 0.5, 12, 32), copperMat);
        currentArrowGroup.userData = { radius: 6.8, xPos: 0 };
    }
    if (mainMesh) coilGroup.add(mainMesh);
    coilGroup.rotation.set(0,0,0);
}

function updateArrowGeometry(magnitude) {
    while (currentArrowGroup.children.length > 0) {
        const child = currentArrowGroup.children[0];
        if (child.geometry) child.geometry.dispose();
        currentArrowGroup.remove(child);
    }
    if (magnitude < 0.1) return;

    const radius = currentArrowGroup.userData.radius;
    const xPos = currentArrowGroup.userData.xPos;
    const arcLength = Math.min(Math.PI * 1.8, magnitude * 1.0);
    const startAngle = Math.PI/2 - arcLength/2;
    const endAngle = Math.PI/2 + arcLength/2;
    const pts = new THREE.EllipseCurve(0, 0, radius, radius, startAngle, endAngle, false, 0).getPoints(Math.max(8, Math.floor(arcLength*12)));
    
    let pathCurve;
    if (state.mode === 'uniformField') {
        pathCurve = new THREE.CatmullRomCurve3(pts.map(p => new THREE.Vector3(p.x, p.y, 0)));
        labelTargetPos.set(0, radius + 0.5, 0);
    } else {
        pathCurve = new THREE.CatmullRomCurve3(pts.map(p => new THREE.Vector3(xPos, p.y, p.x)));
        labelTargetPos.set(xPos, radius + 0.5, 0);
    }

    const tubeMat = new THREE.MeshStandardMaterial({ color: CONFIG.inducedColor, emissive: CONFIG.inducedColor, emissiveIntensity: 1.5, transparent: true, opacity: 0.9 });
    currentArrowGroup.add(new THREE.Mesh(new THREE.TubeGeometry(pathCurve, 32, 0.25, 8, false), tubeMat));
    
    const cone = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2.0, 12), tubeMat);
    const endPoint = pathCurve.getPoint(1);
    cone.position.copy(endPoint);
    cone.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), pathCurve.getTangent(1));
    currentArrowGroup.add(cone);
}

function createUniformField() {
    uniformFieldGroup.clear();
    if (state.BStrength <= 0.001) return;

    const lineMat = new THREE.LineBasicMaterial({ color: CONFIG.uniformFluxColor, transparent: true, opacity: 0.6 });
    const arrowGeo = new THREE.ConeGeometry(0.25, 0.9, 8);
    const arrowMat = new THREE.MeshBasicMaterial({ color: CONFIG.uniformFluxColor });

    const halfL = 8;
    const regionHalfSize = 16;
    let linesPerAxis = 1 + Math.round(state.BStrength * 8);
    
    // Direction towards Camera (+Z)
    const dir = new THREE.Vector3(0, 0, 1);

    for (let i = 0; i < linesPerAxis; i++) {
        const tx = linesPerAxis===1 ? 0 : i / (linesPerAxis - 1);
        const x = -regionHalfSize + tx * (regionHalfSize * 2);
        for (let j = 0; j < linesPerAxis; j++) {
            const ty = linesPerAxis===1 ? 0 : j / (linesPerAxis - 1);
            const y = -regionHalfSize + ty * (regionHalfSize * 2);
            // Lines from -Z to +Z
            uniformFieldGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, y, -halfL), new THREE.Vector3(x, y, halfL)]), lineMat));
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.position.set(x, y, halfL);
            arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            uniformFieldGroup.add(arrow);
        }
    }
}

function createProjectedAreaDisc() {
    projectedAreaMesh = new THREE.Mesh(new THREE.CircleGeometry(6, 32), new THREE.MeshBasicMaterial({ color: 0x38bdf8, transparent: true, opacity: 0.25, side: THREE.DoubleSide, depthWrite: false }));
    projectedAreaMesh.position.set(0, 0, 0.05);
    scene.add(projectedAreaMesh);
    projectedAreaMesh.visible = false;
}

function positionFluxFactor(x) {
    const fieldHalfWidth = 16, coilRadius = 6;
    const ax = Math.abs(x);
    if (ax <= fieldHalfWidth - coilRadius) return 1;
    if (ax >= fieldHalfWidth + coilRadius) return 0;
    const t = (fieldHalfWidth - ax) / coilRadius;
    return (Math.acos(-t) - t * Math.sqrt(1 - t * t)) / Math.PI;
}

function updatePhysics() {
    const newPos = state.position;
    const diff = newPos - state.lastPosition;
    let rawInduced = 0;

    // Smoothly animate camera
    if (state.isSwipeMode) {
        camera.position.lerp(targetCameraPos, 0.05);
        camera.lookAt(targetLookAt);
    }

    if (state.mode === 'uniformField') {
        const alpha = state.loopAngleDeg * Math.PI / 180;    
        const posFactor = positionFluxFactor(newPos);
        const flux = state.BStrength * posFactor * Math.sin(alpha);   
        const dFlux = flux - state.lastFluxUniform;
        // High gain for sensitivity
        rawInduced = -dFlux * 150; 
        if (Math.abs(dFlux) < 0.0001) rawInduced = 0;

        state.lastFluxUniform = flux;
        state.targetCurrent = rawInduced;
        state.inducedCurrent += (state.targetCurrent - state.inducedCurrent) * 0.2;

        coilGroup.position.x = newPos;
        magnetGroup.visible = false;
        uniformFieldGroup.visible = true; 
        state.lastPosition = newPos;

        const rotX = (90 - state.loopAngleDeg) * Math.PI / 180; 
        coilGroup.rotation.set(rotX, 0, 0); 

        if (projectedAreaMesh) {
            if (state.showProjection) {
                const f = Math.abs(Math.sin(alpha));
                if (f > 0.001) {
                    projectedAreaMesh.visible = true;
                    projectedAreaMesh.scale.set(1, f, 1);
                    projectedAreaMesh.position.x = coilGroup.position.x;
                } else {
                    projectedAreaMesh.visible = false;
                }
            } else {
                projectedAreaMesh.visible = false;
            }
        }
    } else {
        const x = state.lastPosition; 
        const fluxSlope = -x / Math.pow(x*x + 25, 2.5) * 150; 
        const velocity = diff; 
        rawInduced = -fluxSlope * velocity * 800 * state.polarity; 
        if (Math.abs(diff) < 0.005) rawInduced = 0;

        state.targetCurrent = rawInduced;
        state.inducedCurrent += (state.targetCurrent - state.inducedCurrent) * 0.2;

        magnetGroup.position.x = newPos;
        coilGroup.position.x = 0;
        uniformFieldGroup.visible = false;
        magnetGroup.visible = true;
        state.lastPosition = newPos;
        if (projectedAreaMesh) projectedAreaMesh.visible = false;
    }

    updateCoilIndicators();
    updateLabelPosition();
}

function updateCoilIndicators() {
    const mag = Math.abs(state.inducedCurrent);
    const isVisible = mag > 0.1;
    currentLabel.innerText = `I = ${mag.toFixed(2)} A`;
    if (isVisible) {
        currentLabel.style.opacity = 1;
        if (state.inducedCurrent > 0) currentLabel.style.color = '#ea580c'; 
        else currentLabel.style.color = '#dc2626'; 
    } else {
        currentLabel.style.opacity = 0;
    }
    updateArrowGeometry(mag);
    const targetRotY = (state.inducedCurrent > 0) ? Math.PI : 0;
    currentArrowGroup.rotation.y = targetRotY;
}

function updateLabelPosition() {
    if (currentLabel.style.opacity == 0) return;
    const worldPos = labelTargetPos.clone();
    currentArrowGroup.localToWorld(worldPos);
    worldPos.project(camera);
    const x = (worldPos.x * .5 + .5) * window.innerWidth;
    const y = (-(worldPos.y * .5) + .5) * window.innerHeight;
    currentLabel.style.left = `${x}px`;
    currentLabel.style.top = `${y - 50}px`; 
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    updatePhysics();
    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function setupUI() {
    const slider = document.getElementById('positionSlider');
    const modeSelect = document.getElementById('modeSelect');
    
    const linesToggle = document.getElementById('linesToggle');
    const hideMagnetToggle = document.getElementById('hideMagnetToggle');
    const projToggle = document.getElementById('projToggle');
    const flipBtn = document.getElementById('flipBtn');
    
    const settingsBtn = document.getElementById('settingsBtn');
    const expandedSettings = document.getElementById('expandedSettings');

    const angleControl = document.getElementById('advancedControls');
    const angleControlRow = document.getElementById('angleControlRow'); // Used to hide slider in uniform mode
    const angleSlider = document.getElementById('angleSlider');
    const angleValue = document.getElementById('angleValue');
    const bSlider = document.getElementById('bSlider');
    const BValue = document.getElementById('BValue');

    const showLinesRow = document.getElementById('showLinesRow'); 
    const hideMagnetRow = document.getElementById('hideMagnetRow');
    const showProjRow = document.getElementById('showProjRow');

    settingsBtn.addEventListener('click', () => {
        expandedSettings.classList.toggle('hidden');
    });

    slider.addEventListener('input', (e) => {
        state.position = parseFloat(e.target.value);
    });

    angleSlider.addEventListener('input', (e) => {
        const deg = parseFloat(e.target.value);
        state.loopAngleDeg = deg;
        angleValue.textContent = `${deg}°`;
    });

    bSlider.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        state.BStrength = v;
        BValue.textContent = `${v.toFixed(2)} T`;
        if (state.mode === 'uniformField') {
            createUniformField();
        }
    });

    projToggle.addEventListener('change', (e) => {
        if (state.mode === 'uniformField') {
            state.showProjection = e.target.checked;
        } else {
            state.showProjection = false;
            projToggle.checked = false;
        }
    });

    linesToggle.addEventListener('change', (e) => {
        if (state.mode === 'uniformField') {
            linesToggle.checked = true;
            state.showFluxLines = true;
            uniformFieldGroup.visible = true;
            return;
        }
        state.showFluxLines = e.target.checked;
        magnetFieldLines.visible = state.showFluxLines;
    });

    hideMagnetToggle.addEventListener('change', (e) => {
        if (state.mode === 'uniformField') {
            hideMagnetToggle.checked = false;
            state.showMagnetBody = true;
            magnetBodyGroup.visible = true;
            return;
        }
        state.showMagnetBody = !e.target.checked; 
        magnetBodyGroup.visible = state.showMagnetBody;
    });

    modeSelect.addEventListener('change', (e) => {
        state.mode = e.target.value;
        rebuildCoil();

        if (state.mode === 'uniformField') {
            state.position = -12;
            state.lastPosition = -12;
            slider.value = state.position;

            state.loopAngleDeg = 0;
            state.lastFluxUniform = 0;
            angleSlider.value = 0;
            angleValue.textContent = '0°';

            angleControl.classList.remove('hidden');
            angleControlRow.classList.add('hidden'); // Hide slider row

            state.showFluxLines = true;
            linesToggle.checked = true;
            createUniformField();
            uniformFieldGroup.visible = true;
            magnetFieldLines.visible = false;

            hideMagnetRow.classList.add('hidden');
            flipBtn.classList.add('hidden');
            showProjRow.classList.remove('hidden');

            state.showProjection = false;
            projToggle.checked = false;
            if (projectedAreaMesh) projectedAreaMesh.visible = false;

            state.showMagnetBody = true;
            magnetBodyGroup.visible = true;
            hideMagnetToggle.checked = false;

            // --- Switch to Swipe Control & Locked Camera ---
            state.isSwipeMode = true;
            controls.enabled = false; 
            
            // Initial Camera Transition: Start close, look forward
            camera.position.set(0, 0, 50);
            camera.lookAt(0, 0, 0);
            
            // Set Target to be slightly elevated (fixed)
            targetCameraPos.set(0, 10, 50);
            targetLookAt.set(0, 0, 0);

            gestureHint.style.opacity = 1;
            setTimeout(() => { gestureHint.style.opacity = 0; }, 3000);

        } else {
            coilGroup.position.x = 0;
            state.loopAngleDeg = 0;
            angleSlider.value = 0;
            angleValue.textContent = '0°';
            angleControl.classList.add('hidden');

            uniformFieldGroup.visible = false;
            magnetFieldLines.visible = state.showFluxLines;

            hideMagnetRow.classList.remove('hidden');
            flipBtn.classList.remove('hidden');
            showProjRow.classList.add('hidden');

            state.showProjection = false;
            projToggle.checked = false;
            if (projectedAreaMesh) projectedAreaMesh.visible = false;

            // --- Reset to Orbit Controls ---
            state.isSwipeMode = false;
            controls.enabled = true;
            camera.position.set(0, 20, 40);
            camera.lookAt(0, 0, 0);
            controls.target.set(0,0,0);
        }
    });

    flipBtn.addEventListener('click', () => {
        state.polarity *= -1;
        createMagnet();
    });
}

init();
</script>
</body>
</html>
