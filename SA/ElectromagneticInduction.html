<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>電磁感應 3D 實驗室</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@800&family=Noto+Sans+TC:wght@400;700;900&display=swap');

        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; 
            background-color: #ffffff; font-family: 'Noto Sans TC', sans-serif; touch-action: none; 
        }

        .main-container { display: flex; flex-direction: column; height: 100vh; width: 100vw; }

        /* 橫向模式適配 */
        @media (orientation: landscape) {
            .main-container { flex-direction: row; }
            #experiment-area { flex: 1.8 !important; border-right: 2px solid #f1f5f9; border-bottom: none !important; }
            #control-area { flex: 1.1 !important; height: 100%; padding: 15px !important; }
        }

        #experiment-area { 
            flex: 2; position: relative; background-color: #ffffff; border-bottom: 2px solid #f1f5f9; 
            min-height: 40%;
        }

        #control-area { 
            flex: 1; background-color: #f8fafc; padding: 12px 16px; overflow-y: auto; 
            box-shadow: 0 -4px 15px rgba(0,0,0,0.05); z-index: 10; 
        }

        .hud-overlay { 
            position: absolute; top: 10px; left: 10px; right: 10px; display: flex; 
            flex-direction: column; gap: 5px; pointer-events: none; 
        }

        .hud-row { display: flex; justify-content: space-between; align-items: flex-start; gap: 6px; }

        .glass-tag { 
            background: rgba(255, 255, 255, 0.96); backdrop-filter: blur(8px); 
            border: 1px solid rgba(0, 0, 0, 0.08); padding: 8px 12px; border-radius: 14px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.04);
            white-space: nowrap;
            pointer-events: auto;
        }

        /* 感應電流標籤 */
        #currentLabel { 
            position: absolute; color: #ea580c; font-family: 'JetBrains Mono', monospace; 
            font-weight: 800; font-size: 1.15rem; pointer-events: none; opacity: 0; z-index: 100; 
            text-shadow: 0 0 10px rgba(255,255,255,0.9); text-align: center; line-height: 1.1;
        }

        /* 緊湊滑桿 */
        input[type=range] { -webkit-appearance: none; background: transparent; height: 36px; width: 100%; }
        input[type=range]::-webkit-slider-thumb { 
            -webkit-appearance: none; height: 28px; width: 28px; border-radius: 50%; 
            background: #0ea5e9; border: 3px solid #ffffff; margin-top: -10px; 
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); 
        }
        input[type=range]::-webkit-slider-runnable-track { height: 8px; background: #e2e8f0; border-radius: 4px; }

        .label-text { font-size: 12px; font-weight: 900; color: #64748b; text-transform: uppercase; white-space: nowrap; }
        .value-text { font-size: 14px; font-weight: 900; color: #0284c7; }
        
        .btn-sm-action { 
            background: white; border: 1.5px solid #e2e8f0; 
            border-radius: 12px; display: flex; align-items: center; 
            justify-content: center; transition: all 0.2s; gap: 4px;
            padding: 6px 12px;
        }
        .btn-sm-action:active { transform: scale(0.95); background: #f1f5f9; border-color: #0ea5e9; }
        
        .no-scrollbar::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>

<div class="main-container">
    <div id="experiment-area">
        <div id="currentLabel">Induced current<br>= 0.00 A</div>
        
        <div class="hud-overlay">
            <div class="hud-row">
                <!-- 左上：標題 -->
                <div class="glass-tag">
                    <h1 class="text-slate-900 text-lg font-black tracking-tighter leading-none whitespace-nowrap">電磁感應</h1>
                    <p class="text-[10px] text-slate-500 font-bold uppercase tracking-[0.1em] mt-1 whitespace-nowrap">EM Induction</p>
                </div>
                <!-- 右上：磁力線控制與數據 -->
                <div class="flex flex-col gap-2 items-end">
                    <div class="glass-tag text-right min-w-[125px] flex flex-col items-end gap-1.5">
                        <button id="linesToggle" class="w-full text-[11px] font-black py-2 px-3 rounded-xl border-2 transition-all flex items-center justify-center gap-2 bg-white border-slate-200 text-slate-500 shadow-sm">
                            <span id="toggleDot" class="w-2.5 h-2.5 rounded-full bg-slate-300 shadow-inner"></span>
                            顯示磁力線
                        </button>
                        
                        <div id="fluxInfo" class="hidden w-full space-y-1 mt-1 border-t border-slate-100 pt-2">
                            <div class="flex justify-between items-baseline px-1">
                                <span class="text-[9px] text-emerald-600 font-black uppercase">通過磁力線數</span>
                                <div class="text-xl font-black text-emerald-600 font-mono leading-none">
                                    <span id="fluxLinesCount">0</span><span class="text-[10px] ml-0.5">條</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="canvas-container" class="w-full h-full"></div>
    </div>

    <div id="control-area" class="no-scrollbar">
        <div class="max-w-xl mx-auto space-y-3">
            <!-- 位置控制組 -->
            <div class="grid grid-cols-1 gap-2">
                <div class="flex flex-col">
                    <div class="flex justify-between items-center px-1">
                        <span class="label-text">磁鐵位置 (Magnet)</span>
                        <span id="magText" class="value-text">0.0</span>
                    </div>
                    <input type="range" id="magSlider" min="-30" max="30" step="0.1" value="-15">
                </div>
                <div class="flex flex-col">
                    <div class="flex justify-between items-center px-1">
                        <span class="label-text">線圈位置 (Coil)</span>
                        <span id="coilText" class="value-text">0.0</span>
                    </div>
                    <input type="range" id="coilSlider" min="-30" max="30" step="0.1" value="0">
                </div>
            </div>

            <!-- 角度與磁極合併行 -->
            <div class="flex items-end gap-3">
                <div class="flex-1 flex flex-col">
                    <div class="flex justify-between items-center px-1">
                        <span class="label-text">線圈角度 θ</span>
                        <span id="angleText" class="value-text">0°</span>
                    </div>
                    <input type="range" id="angleSlider" min="0" max="90" step="1" value="0">
                </div>
                <button id="flipBtn" class="btn-sm-action h-[40px] flex-shrink-0 px-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-slate-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                    </svg>
                    <span class="text-[11px] font-black text-slate-700">磁極交換</span>
                </button>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * 物理與視覺常數
 */
const COLORS = {
    bg: 0xffffff,
    magnetN: 0xdc2626, 
    magnetS: 0x2563eb, 
    copper: 0xb45309,
    fluxLine: 0x10b981,
    induced: 0xea580c 
};

let scene, camera, renderer, controls;
let magnetGroup, coilGroup, currentArrowGroup, fieldLinesGroup;
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

let state = {
    magX: -15,
    coilX: 0,
    coilAngle: 0,
    polarity: 1, 
    showLines: false,
    lastFlux: 0,
    inducedI: 0
};

function init() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.bg);

    camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 22, 65);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.maxPolarAngle = Math.PI / 1.9;

    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    
    magnetGroup = new THREE.Group();
    coilGroup = new THREE.Group();
    fieldLinesGroup = new THREE.Group();
    
    scene.add(magnetGroup);
    scene.add(coilGroup);
    scene.add(fieldLinesGroup);

    createMagnet();
    createCoil();
    createFieldLines();

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', () => controls.enabled = true);

    setupUI();
    animate();
}

function createMagnet() {
    magnetGroup.clear();
    const body = new THREE.Group();
    const r = 1.3, h = 6.5;
    const geo = new THREE.CylinderGeometry(r, r, h/2, 32).rotateZ(Math.PI/2);
    
    const mRight = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: state.polarity === 1 ? COLORS.magnetN : COLORS.magnetS }));
    mRight.position.x = h/4;
    body.add(mRight);

    const mLeft = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: state.polarity === 1 ? COLORS.magnetS : COLORS.magnetN }));
    mLeft.position.x = -h/4;
    body.add(mLeft);

    const createLabel = (txt, color) => {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.font = 'bold 100px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.strokeStyle = 'white'; ctx.lineWidth = 15;
        ctx.strokeText(txt, 64, 64); ctx.fillText(txt, 64, 64);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
        sprite.scale.set(3, 3, 1);
        return sprite;
    };

    const labelR = createLabel(state.polarity === 1 ? "N" : "S", state.polarity === 1 ? "#dc2626" : "#2563eb");
    labelR.position.set(h/2-0.5, r+1.3, 0);
    body.add(labelR);

    const labelL = createLabel(state.polarity === 1 ? "S" : "N", state.polarity === 1 ? "#2563eb" : "#dc2626");
    labelL.position.set(-h/2+0.5, r+1.3, 0);
    body.add(labelL);

    body.name = "MAGNET_BODY";
    magnetGroup.add(body);
    magnetGroup.position.x = state.magX;
}

function createCoil() {
    coilGroup.clear();
    const mat = new THREE.MeshStandardMaterial({ color: COLORS.copper, metalness: 0.8, roughness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.TorusGeometry(5.5, 0.45, 16, 64).rotateY(Math.PI/2), mat);
    mesh.name = "COIL_BODY";
    coilGroup.add(mesh);
    currentArrowGroup = new THREE.Group();
    coilGroup.add(currentArrowGroup);
    coilGroup.position.x = state.coilX;
}

function createFieldLines() {
    fieldLinesGroup.clear();
    // 固定使用普通寬度 0.035
    const tubeRadius = 0.035; 
    const tubeMat = new THREE.MeshBasicMaterial({ 
        color: COLORS.fluxLine, 
        transparent: true, 
        opacity: 0.18, 
        depthWrite: false 
    });
    
    const h = 6.5, numLoops = 10, layers = 6;    
    for (let i = 0; i < numLoops; i++) {
        const angle = (i / numLoops) * Math.PI * 2;
        for (let j = 1; j <= layers; j++) {
            const curveWidth = 35 * j, curveHeight = 5.5 * j; 
            const p = state.polarity;
            const startX = (h/2) * p, endX = -(h/2) * p;
            const curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(startX, 0, 0),
                new THREE.Vector3(startX + curveWidth * p, curveHeight, 0),
                new THREE.Vector3(endX - curveWidth * p, curveHeight, 0),
                new THREE.Vector3(endX, 0, 0)
            );
            const pts = curve.getPoints(60).map(pt => new THREE.Vector3(pt.x, pt.y * Math.cos(angle), pt.y * Math.sin(angle)));
            const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 60, tubeRadius, 6, false);
            fieldLinesGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
        }
    }
    fieldLinesGroup.visible = state.showLines;
}

function updateInductionVisuals(val) {
    const absVal = Math.abs(val);
    const label = document.getElementById('currentLabel');
    if (absVal > 0.05) {
        label.innerHTML = `Induced current<br>= ${absVal.toFixed(2)} A`;
        label.style.opacity = 1;
        const v = new THREE.Vector3(state.coilX, 7.5, 0);
        v.project(camera);
        const container = document.getElementById('experiment-area');
        const x = (v.x * 0.5 + 0.5) * container.clientWidth;
        const y = (-(v.y * 0.5) + 0.5) * container.clientHeight;
        label.style.left = `${x}px`;
        label.style.top = `${y - 40}px`;
        label.style.transform = 'translateX(-50%)';
    } else { label.style.opacity = 0; }

    currentArrowGroup.clear();
    if (absVal > 0.1) {
        const arrowRadius = 6.4;
        const arcLength = Math.min(Math.PI * 0.5, absVal * 0.15); 
        const startAngle = Math.PI / 2;
        const isClockwise = val > 0; 
        const endAngle = isClockwise ? startAngle - arcLength : startAngle + arcLength;
        const curve = new THREE.EllipseCurve(0, 0, arrowRadius, arrowRadius, startAngle, endAngle, isClockwise);
        const pts = curve.getPoints(25).map(p => new THREE.Vector3(0, p.y, p.x));
        const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 20, 0.22, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ color: COLORS.induced });
        currentArrowGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
        const cone = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.3, 12), tubeMat);
        cone.position.copy(pts[pts.length - 1]);
        const tangent = new THREE.Vector3(0, Math.cos(endAngle), -Math.sin(endAngle)).normalize();
        if (isClockwise) tangent.multiplyScalar(-1); 
        cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
        currentArrowGroup.add(cone);
    }
}

function calculatePhysics() {
    const fluxDir = state.polarity; 
    const dist = state.coilX - state.magX;
    const angleRad = state.coilAngle * Math.PI / 180;
    const flux = (350 / (dist * dist + 50)) * Math.cos(angleRad) * fluxDir;
    const dFlux = flux - state.lastFlux;
    const targetI = -dFlux * 55; 
    state.inducedI += (targetI - state.inducedI) * 0.18;
    state.lastFlux = flux;
    if (document.getElementById('fluxLinesCount')) document.getElementById('fluxLinesCount').innerText = Math.round(Math.abs(flux) * 12);
    updateInductionVisuals(state.inducedI);
}

function onPointerDown(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    for (let intersect of intersects) {
        let obj = intersect.object;
        while(obj.parent && !obj.name) obj = obj.parent;
        if (obj.name === "MAGNET_BODY" || obj.name === "COIL_BODY") { controls.enabled = false; break; }
    }
}

function onPointerMove(e) {
    if (controls.enabled) return;
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersectPos = new THREE.Vector3();
    raycaster.ray.intersectPlane(dragPlane, intersectPos);
    const limit = 30;
    const newX = Math.max(-limit, Math.min(limit, intersectPos.x));
    if (Math.abs(newX - state.magX) < Math.abs(newX - state.coilX)) {
        state.magX = newX;
        document.getElementById('magSlider').value = newX;
        document.getElementById('magText').innerText = newX.toFixed(1);
    } else {
        state.coilX = newX;
        document.getElementById('coilSlider').value = newX;
        document.getElementById('coilText').innerText = newX.toFixed(1);
    }
}

function onResize() {
    const container = document.getElementById('experiment-area');
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
}

function setupUI() {
    document.getElementById('magSlider').addEventListener('input', (e) => {
        state.magX = parseFloat(e.target.value);
        document.getElementById('magText').innerText = state.magX.toFixed(1);
    });
    document.getElementById('coilSlider').addEventListener('input', (e) => {
        state.coilX = parseFloat(e.target.value);
        document.getElementById('coilText').innerText = state.coilX.toFixed(1);
    });
    document.getElementById('angleSlider').addEventListener('input', (e) => {
        state.coilAngle = parseFloat(e.target.value);
        document.getElementById('angleText').innerText = `${state.coilAngle}°`;
    });
    
    const linesToggle = document.getElementById('linesToggle');
    const fluxInfo = document.getElementById('fluxInfo');
    const toggleDot = document.getElementById('toggleDot');

    linesToggle.addEventListener('click', () => {
        state.showLines = !state.showLines;
        fieldLinesGroup.visible = state.showLines;
        
        if (state.showLines) {
            linesToggle.classList.replace('border-slate-200', 'border-emerald-500');
            linesToggle.classList.replace('text-slate-500', 'text-emerald-600');
            toggleDot.classList.replace('bg-slate-300', 'bg-emerald-500');
            fluxInfo.classList.remove('hidden');
            linesToggle.innerHTML = '<span class="w-2.5 h-2.5 rounded-full bg-emerald-500"></span> 磁力線：已開啟';
        } else {
            linesToggle.classList.replace('border-emerald-500', 'border-slate-200');
            linesToggle.classList.replace('text-emerald-600', 'text-slate-500');
            toggleDot.classList.replace('bg-emerald-500', 'bg-slate-300');
            fluxInfo.classList.add('hidden');
            linesToggle.innerHTML = '<span class="w-2.5 h-2.5 rounded-full bg-slate-300"></span> 顯示磁力線';
        }
    });

    document.getElementById('flipBtn').addEventListener('click', () => {
        state.polarity *= -1;
        createMagnet();
        createFieldLines();
    });
}

function animate() {
    requestAnimationFrame(animate);
    magnetGroup.position.x = state.magX;
    coilGroup.position.x = state.coilX;
    coilGroup.rotation.z = state.coilAngle * Math.PI / 180;
    fieldLinesGroup.position.x = state.magX;
    calculatePhysics();
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
