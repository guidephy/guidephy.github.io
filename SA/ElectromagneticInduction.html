<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>電磁感應 3D 實驗室</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@800&family=Noto+Sans+TC:wght@400;700;900&display=swap');

        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; 
            background-color: #ffffff; font-family: 'Noto Sans TC', sans-serif; touch-action: none; 
        }

        .main-container { display: flex; flex-direction: column; height: 100vh; width: 100vw; }

        @media (orientation: landscape) {
            .main-container { flex-direction: row; }
            #experiment-area { flex: 1.8 !important; border-right: 2px solid #f1f5f9; border-bottom: none !important; }
            #control-area { flex: 1.1 !important; height: 100%; padding: 12px 15px !important; }
        }

        #experiment-area { 
            flex: 2; position: relative; background-color: #ffffff; border-bottom: 2px solid #f1f5f9; 
            min-height: 35%;
        }

        #control-area { 
            flex: 1; background-color: #f8fafc; padding: 12px 16px; overflow-y: auto; 
            box-shadow: 0 -4px 15px rgba(0,0,0,0.05); z-index: 10; 
        }

        .hud-overlay { 
            position: absolute; top: 10px; left: 10px; right: 10px; display: flex; 
            flex-direction: column; gap: 5px; pointer-events: none; 
        }

        .hud-row { display: flex; justify-content: space-between; align-items: flex-start; gap: 6px; }

        .glass-tag { 
            background: rgba(255, 255, 255, 0.96); backdrop-filter: blur(10px); 
            border: 1px solid rgba(0, 0, 0, 0.08); padding: 10px 14px; border-radius: 14px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.04);
            white-space: nowrap; pointer-events: auto; width: fit-content;
        }

        /* 感應電流標籤視覺：改回兩行顯示並優化 */
        #currentLabel { 
            position: absolute; 
            color: #ea580c; 
            font-family: 'JetBrains Mono', monospace; 
            font-weight: 800; 
            font-size: 1.2rem; 
            pointer-events: none; 
            opacity: 0; 
            z-index: 100; 
            text-align: center; 
            line-height: 1.1;
            text-shadow: 0 0 12px #ffffff, 0 0 4px #ffffff, 0 0 20px rgba(255,255,255,0.5); 
            transform: translateX(-50%);
            transition: opacity 0.3s ease;
        }

        input[type=range] { -webkit-appearance: none; background: transparent; height: 34px; width: 100%; }
        input[type=range]::-webkit-slider-thumb { 
            -webkit-appearance: none; height: 26px; width: 26px; border-radius: 50%; 
            background: #0ea5e9; border: 3px solid #ffffff; margin-top: -10px; 
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); 
        }
        input[type=range]::-webkit-slider-runnable-track { height: 7px; background: #e2e8f0; border-radius: 4px; }

        .label-text { font-size: 12px; font-weight: 900; color: #64748b; text-transform: uppercase; white-space: nowrap; }
        .value-text { font-size: 14px; font-weight: 900; color: #0284c7; }
        
        .btn-sm-action { 
            background: white; border: 1.5px solid #e2e8f0; 
            border-radius: 12px; display: flex; align-items: center; 
            justify-content: center; transition: all 0.2s; gap: 4px; padding: 5px 10px;
        }
        .btn-sm-action:active { transform: scale(0.95); background: #f1f5f9; border-color: #0ea5e9; }
        
        .no-scrollbar::-webkit-scrollbar { display: none; }

        .title-container { display: flex; flex-direction: column; align-items: flex-start; }
        .title-main { font-size: 1.1rem; font-weight: 900; color: #1e293b; line-height: 1.1; letter-spacing: -0.02em; }
        .title-sub { font-size: 1.1rem; font-weight: 900; color: #0ea5e9; line-height: 1.1; margin-top: 4px; }
        .divider-full { height: 3px; background-color: #e2e8f0; width: 100%; margin: 6px 0; border-radius: 99px; }

        .hud-tool-btn { 
            width: 100%; text-align: center; font-size: 10px; font-weight: 900; 
            padding: 6px 8px; border-radius: 10px; border: 2px solid #e2e8f0;
            transition: all 0.2s; background: white; color: #94a3b8;
            display: flex; align-items: center; justify-content: center; gap: 4px;
        }
        .hud-tool-btn.active { border-color: #0ea5e9; color: #0ea5e9; background: #f0f9ff; }
        .hud-tool-btn.active-green { border-color: #10b981; color: #059669; background: #f0fdf4; }

        #it-graph-box { width: 140px; height: 75px; background: #f8fafc; border-radius: 10px; border: 1px solid #e2e8f0; margin-top: 8px; }
    </style>
</head>
<body>

<div class="main-container">
    <div id="experiment-area">
        <!-- 感應電流標籤 -->
        <div id="currentLabel">Induced current<br>= 0.0 A</div>
        
        <div class="hud-overlay">
            <div class="hud-row">
                <div class="glass-tag title-container">
                    <div class="title-main">Electromagnetic<br>Induction</div>
                    <div class="divider-full"></div>
                    <div class="title-sub text-sky-600">電磁感應</div>
                </div>

                <div class="flex flex-col gap-2 items-end">
                    <div class="glass-tag flex flex-col gap-2 min-w-[150px]">
                        <div class="flex gap-1.5 w-full">
                            <button id="linesToggle" class="hud-tool-btn flex-1">
                                <span class="w-1.5 h-1.5 rounded-full bg-current opacity-40"></span>
                                磁力線
                            </button>
                            <button id="graphToggle" class="hud-tool-btn flex-1">
                                <span class="w-1.5 h-1.5 rounded-full bg-current opacity-40"></span>
                                I-t 圖
                            </button>
                        </div>
                        
                        <div id="fluxLinesDisplay" class="hidden w-full border-t border-slate-100 pt-2 pb-1">
                            <div class="flex justify-between items-baseline px-1">
                                <span class="text-[9px] text-emerald-600 font-black uppercase tracking-tighter">通過磁力線數</span>
                                <div class="text-xl font-black text-emerald-600 font-mono leading-none">
                                    <span id="fluxLinesCount">0</span><span class="text-[10px] ml-0.5">條</span>
                                </div>
                            </div>
                        </div>

                        <div id="itGraphDisplay" class="hidden w-full border-t border-slate-100 pt-2">
                            <div class="w-full flex justify-between items-center mb-1 px-1">
                                <span class="text-[8px] font-black text-slate-400 uppercase tracking-tighter">Current (I) - Time (t)</span>
                                <span class="text-[8px] font-bold text-orange-500">I(A)</span>
                            </div>
                            <div id="it-graph-box">
                                <canvas id="currentGraph" width="140" height="75"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="canvas-container" class="w-full h-full"></div>
    </div>

    <div id="control-area" class="no-scrollbar">
        <div class="max-w-xl mx-auto space-y-3.5">
            <div class="grid grid-cols-1 gap-2.5">
                <div class="flex flex-col">
                    <div class="flex justify-between items-center px-1 mb-0.5">
                        <span class="label-text">磁鐵 (Magnet) 位置</span>
                    </div>
                    <input type="range" id="magSlider" min="-30" max="30" step="0.1" value="-15">
                </div>
                <div class="flex flex-col">
                    <div class="flex justify-between items-center px-1 mb-0.5">
                        <span class="label-text">線圈 (Coil)</span>
                    </div>
                    <input type="range" id="coilSlider" min="-30" max="30" step="0.1" value="0">
                </div>
            </div>

            <div class="flex items-end gap-3">
                <div class="flex-1 flex flex-col">
                    <div class="flex justify-between items-center px-1 mb-0.5">
                        <span class="label-text">線圈角度 θ</span>
                        <span id="angleText" class="value-text">0°</span>
                    </div>
                    <input type="range" id="angleSlider" min="0" max="90" step="1" value="0">
                </div>
                <button id="flipBtn" class="btn-sm-action h-[38px] flex-shrink-0 px-3 border-slate-300">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                    </svg>
                    <span class="text-[10px] font-black text-slate-700">磁極交換</span>
                </button>
            </div>
        </div>
    </div>
</div>

<script>
const COLORS = {
    bg: 0xffffff,
    magnetN: 0xdc2626, 
    magnetS: 0x2563eb, 
    copper: 0xb45309,
    fluxLine: 0x10b981,
    induced: 0xea580c 
};

let scene, camera, renderer, controls;
let magnetGroup, coilGroup, currentArrowGroup, fieldLinesGroup;
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

const graphHistory = [];
const maxGraphPoints = 150; 

let averageBuffer = [];
const bufferSize = 10; 

let labelVisibilityTimer = 0;
const labelHoldTime = 12; 

let state = {
    magX: -15,
    coilX: 0,
    coilAngle: 0,
    polarity: 1, 
    showLines: false,
    showGraph: false,
    lastFlux: 0,
    inducedI: 0,
    displayedValueI: 0
};

function init() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.bg);

    camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 22, 65);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.maxPolarAngle = Math.PI / 1.9;

    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    
    magnetGroup = new THREE.Group();
    coilGroup = new THREE.Group();
    fieldLinesGroup = new THREE.Group();
    
    scene.add(magnetGroup);
    scene.add(coilGroup);
    scene.add(fieldLinesGroup);

    createMagnet();
    createCoil();
    createFieldLines();

    const dist = state.coilX - state.magX;
    const angleRad = state.coilAngle * Math.PI / 180;
    state.lastFlux = (350 / (dist * dist + 50)) * Math.cos(angleRad) * state.polarity;

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', () => controls.enabled = true);

    setupUI();
    animate();
}

function createMagnet() {
    magnetGroup.clear();
    const body = new THREE.Group();
    const r = 1.3, h = 6.5;
    const geo = new THREE.CylinderGeometry(r, r, h/2, 32).rotateZ(Math.PI/2);
    const mRight = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: state.polarity === 1 ? COLORS.magnetN : COLORS.magnetS }));
    mRight.position.x = h/4;
    body.add(mRight);
    const mLeft = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: state.polarity === 1 ? COLORS.magnetS : COLORS.magnetN }));
    mLeft.position.x = -h/4;
    body.add(mLeft);

    const createLabel = (txt, color) => {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.font = 'bold 100px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(txt, 64, 64);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
        sprite.scale.set(3, 3, 1);
        return sprite;
    };
    const labelR = createLabel(state.polarity === 1 ? "N" : "S", state.polarity === 1 ? "#dc2626" : "#2563eb");
    labelR.position.set(h/2-0.5, r+1.3, 0);
    body.add(labelR);
    const labelL = createLabel(state.polarity === 1 ? "S" : "N", state.polarity === 1 ? "#2563eb" : "#dc2626");
    labelL.position.set(-h/2+0.5, r+1.3, 0);
    body.add(labelL);
    body.name = "MAGNET_BODY";
    magnetGroup.add(body);
    magnetGroup.position.x = state.magX;
}

function createCoil() {
    coilGroup.clear();
    const mat = new THREE.MeshStandardMaterial({ color: COLORS.copper, metalness: 0.8, roughness: 0.2 });
    const mesh = new THREE.Mesh(new THREE.TorusGeometry(5.5, 0.45, 16, 64).rotateY(Math.PI/2), mat);
    mesh.name = "COIL_BODY";
    coilGroup.add(mesh);
    currentArrowGroup = new THREE.Group();
    coilGroup.add(currentArrowGroup);
    coilGroup.position.x = state.coilX;
}

function createFieldLines() {
    fieldLinesGroup.clear();
    const tubeRadius = 0.035; 
    const tubeMat = new THREE.MeshBasicMaterial({ color: COLORS.fluxLine, transparent: true, opacity: 0.18, depthWrite: false });
    const h = 6.5, numLoops = 10, layers = 6;    
    for (let i = 0; i < numLoops; i++) {
        const angle = (i / numLoops) * Math.PI * 2;
        for (let j = 1; j <= layers; j++) {
            const curveWidth = 35 * j, curveHeight = 5.5 * j; 
            const p = state.polarity;
            const startX = (h/2) * p, endX = -(h/2) * p;
            const curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(startX, 0, 0),
                new THREE.Vector3(startX + curveWidth * p, curveHeight, 0),
                new THREE.Vector3(endX - curveWidth * p, curveHeight, 0),
                new THREE.Vector3(endX, 0, 0)
            );
            const pts = curve.getPoints(60).map(pt => new THREE.Vector3(pt.x, pt.y * Math.cos(angle), pt.y * Math.sin(angle)));
            const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 60, tubeRadius, 6, false);
            fieldLinesGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
        }
    }
    fieldLinesGroup.visible = state.showLines;
}

function updateInductionVisuals(rawVal) {
    const label = document.getElementById('currentLabel');
    averageBuffer.push(rawVal);
    if (averageBuffer.length > bufferSize) averageBuffer.shift();
    const avgI = averageBuffer.reduce((a, b) => a + b, 0) / averageBuffer.length;
    state.displayedValueI += (avgI - state.displayedValueI) * 0.15;
    const stableI = Math.abs(rawVal) < 0.008 ? 0 : state.displayedValueI;

    if (Math.abs(stableI) > 0.02) {
        labelVisibilityTimer = labelHoldTime;
        // 修正：= A 在第二行
        label.innerHTML = `Induced current<br>= ${stableI.toFixed(1)} A`;
        label.style.opacity = 1;
        const v = new THREE.Vector3(state.coilX, 7.5, 0);
        v.project(camera);
        const container = document.getElementById('experiment-area');
        const x = (v.x * 0.5 + 0.5) * container.clientWidth;
        const y = (-(v.y * 0.5) + 0.5) * container.clientHeight;
        label.style.left = `${x}px`;
        label.style.top = `${y - 45}px`;
    } else {
        if (labelVisibilityTimer > 0) labelVisibilityTimer--;
        else label.style.opacity = 0;
    }

    currentArrowGroup.clear();
    const absVal = Math.abs(stableI);
    if (absVal > 0.1) {
        const arrowRadius = 6.4;
        const arcLength = Math.min(Math.PI * 0.5, absVal * 0.15); 
        const startAngle = Math.PI / 2;
        const isClockwise = stableI < 0; 
        const endAngle = isClockwise ? startAngle - arcLength : startAngle + arcLength;
        const curve = new THREE.EllipseCurve(0, 0, arrowRadius, arrowRadius, startAngle, endAngle, isClockwise);
        const pts = curve.getPoints(25).map(p => new THREE.Vector3(0, p.y, p.x));
        const tubeGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts), 20, 0.22, 8, false);
        const tubeMat = new THREE.MeshBasicMaterial({ color: COLORS.induced });
        currentArrowGroup.add(new THREE.Mesh(tubeGeo, tubeMat));
        const cone = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.3, 12), tubeMat);
        cone.position.copy(pts[pts.length - 1]);
        const tangent = new THREE.Vector3(0, Math.cos(endAngle), -Math.sin(endAngle)).normalize();
        if (isClockwise) tangent.multiplyScalar(-1); 
        cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tangent);
        currentArrowGroup.add(cone);
    }
}

function drawGraph() {
    if (!state.showGraph) return;
    const canvas = document.getElementById('currentGraph');
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0, 0, w, h);
    const fixedMaxI = 20.0; 
    ctx.setLineDash([2, 2]);
    ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
    ctx.setLineDash([]); 
    if (graphHistory.length < 2) return;
    ctx.strokeStyle = '#ea580c'; ctx.lineWidth = 2.5; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
    ctx.beginPath();
    const step = w / (maxGraphPoints - 1);
    const yScale = (h / 2 * 0.85) / fixedMaxI; 
    for (let i = 0; i < graphHistory.length; i++) {
        const x = i * step;
        const val = Math.max(-fixedMaxI, Math.min(fixedMaxI, graphHistory[i]));
        const y = h/2 - (val * yScale);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
}

function calculatePhysics() {
    const fluxDir = state.polarity; 
    const dist = state.coilX - state.magX;
    const angleRad = state.coilAngle * Math.PI / 180;
    const flux = (350 / (dist * dist + 50)) * Math.cos(angleRad) * fluxDir;
    const dFlux = flux - state.lastFlux;
    state.inducedI = dFlux * 40; 
    state.lastFlux = flux;
    graphHistory.push(state.inducedI);
    if (graphHistory.length > maxGraphPoints) graphHistory.shift();
    if (document.getElementById('fluxLinesCount')) {
        document.getElementById('fluxLinesCount').innerText = Math.round(Math.abs(flux) * 12);
    }
    updateInductionVisuals(state.inducedI);
    drawGraph();
}

function onPointerDown(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    for (let intersect of intersects) {
        let obj = intersect.object;
        while(obj.parent && !obj.name) obj = obj.parent;
        if (obj.name === "MAGNET_BODY" || obj.name === "COIL_BODY") { controls.enabled = false; break; }
    }
}

function onPointerMove(e) {
    if (controls.enabled) return;
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersectPos = new THREE.Vector3();
    raycaster.ray.intersectPlane(dragPlane, intersectPos);
    const limit = 30;
    const newX = Math.max(-limit, Math.min(limit, intersectPos.x));
    if (Math.abs(newX - state.magX) < Math.abs(newX - state.coilX)) {
        state.magX = newX;
        document.getElementById('magSlider').value = newX;
    } else {
        state.coilX = newX;
        document.getElementById('coilSlider').value = newX;
    }
}

function onResize() {
    const container = document.getElementById('experiment-area');
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
}

function setupUI() {
    document.getElementById('magSlider').addEventListener('input', (e) => state.magX = parseFloat(e.target.value));
    document.getElementById('coilSlider').addEventListener('input', (e) => state.coilX = parseFloat(e.target.value));
    document.getElementById('angleSlider').addEventListener('input', (e) => {
        state.coilAngle = parseFloat(e.target.value);
        document.getElementById('angleText').innerText = `${state.coilAngle}°`;
    });
    const linesToggle = document.getElementById('linesToggle');
    const fluxLinesDisplay = document.getElementById('fluxLinesDisplay');
    linesToggle.addEventListener('click', () => {
        state.showLines = !state.showLines;
        fieldLinesGroup.visible = state.showLines;
        linesToggle.classList.toggle('active-green', state.showLines);
        fluxLinesDisplay.classList.toggle('hidden', !state.showLines);
    });
    const graphToggle = document.getElementById('graphToggle');
    const itGraphDisplay = document.getElementById('itGraphDisplay');
    graphToggle.addEventListener('click', () => {
        state.showGraph = !state.showGraph;
        graphToggle.classList.toggle('active', state.showGraph);
        itGraphDisplay.classList.toggle('hidden', !state.showGraph);
        if (state.showGraph) drawGraph();
    });
    document.getElementById('flipBtn').addEventListener('click', () => {
        state.polarity *= -1;
        createMagnet();
        createFieldLines();
    });
}

function animate() {
    requestAnimationFrame(animate);
    magnetGroup.position.x = state.magX;
    coilGroup.position.x = state.coilX;
    coilGroup.rotation.z = state.coilAngle * Math.PI / 180;
    fieldLinesGroup.position.x = state.magX;
    calculatePhysics();
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
