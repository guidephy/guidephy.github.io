<!DOCTYPE html>
<html lang="zh-TW">
<head>
     <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物體自然頻率AI分析器</title>
    <!-- 添加noUiSlider庫 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.6.1/nouislider.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.6.1/nouislider.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    
<style>
   body {
    font-family: 'Microsoft JhengHei', Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f5f5f5;
}

h1, h2, h3 {
    color: #2c3e50;
}

.container {
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.file-upload {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-bottom: 20px;
}

.upload-box {
    flex: 1;
    min-width: 300px;
    border: 2px dashed #3498db;
    border-radius: 5px;
    padding: 20px;
    text-align: center;
    transition: all 0.3s;
}

.upload-box:hover {
    border-color: #2980b9;
    background-color: #f0f7fc;
}

input[type="file"] {
    display: none;
}

.upload-label {
    display: block;
    cursor: pointer;
    font-weight: bold;
    color: #3498db;
}

button {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    margin-right: 10px;
    margin-bottom: 10px;
}

button:hover {
    background-color: #2980b9;
}

button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
}

.visualizations {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
}

.viz-container {
    flex: 1;
    min-width: 400px;
    margin-bottom: 20px;
}

@media (max-width: 768px) {
    .viz-container {
        min-width: 100%;
    }
}

.loading {
    display: none;
    text-align: center;
    margin: 20px 0;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 2s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.file-name {
    margin-top: 10px;
    font-style: italic;
    word-break: break-all;
}

.canvas-container {
    overflow-x: auto;
    margin-top: 10px;
    position: relative;
}

/* 錄音相關樣式 */
.record-option {
    margin-top: 10px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.record-button-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
}

.record-button {
    flex: 1;
    min-width: 80px;
    padding: 12px;
}

.record-button.start {
    background-color: #e74c3c;
}

.record-button.start:hover {
    background-color: #c0392b;
}

.record-button.stop {
    background-color: #7f8c8d;
}

.record-button.stop:hover {
    background-color: #636e72;
}

.record-button.use {
    background-color: #27ae60;
}

.record-button.use:hover {
    background-color: #2ecc71;
}

.record-info {
    margin-top: 10px;
    font-size: 14px;
    color: #666;
}

.record-timer {
    font-weight: bold;
}

.record-visualization {
    width: 100%;
    height: 60px;
    background-color: #000;
    border-radius: 5px;
    margin-top: 10px;
    position: relative;
    overflow: hidden;
}

/* 波形預覽與選擇區域樣式 */
.preview-container {
    margin-top: 20px;
    padding: 10px;
    border: 1px solid #e0e0e0;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.preview-title {
    font-weight: bold;
    margin-bottom: 10px;
}

.waveform-preview {
    position: relative;
    width: 100%;
    height: 150px;
    margin-bottom: 20px;
    border: 1px solid #ddd;
    background-color: #fff;
}

.selection-overlay {
    position: absolute;
    top: 0;
    background-color: rgba(52, 152, 219, 0.3);
    border: 1px solid rgba(52, 152, 219, 0.7);
    height: 100%;
    pointer-events: none;
}

.slider-container {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    margin: 10px 0;
}

@media (max-width: 768px) {
    .slider-container {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .slider-container .slider {
        width: 100%;
        margin: 5px 0;
    }
    
    .slider-container .time-display {
        margin: 5px 0;
    }
}

.time-display {
    margin: 0 10px;
    min-width: 120px;
    text-align: center;
}

.slider {
    flex-grow: 1;
    margin: 0 10px;
}

input[type="range"] {
    width: 100%;
}

.button-container {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.tab-container {
    margin-bottom: 15px;
}

.tab-button {
    border: none;
    background-color: #f2f2f2;
    padding: 10px 20px;
    border-radius: 5px 5px 0 0;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    margin-right: 5px;
}

.tab-button.active {
    background-color: #3498db;
    color: white;
}

.tab-content {
    display: none;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 0 5px 5px 5px;
}

.tab-content.active {
    display: block;
}

.debug-info {
    font-size: 12px;
    color: #666;
    margin-top: 5px;
    font-family: monospace;
}

.analyze-button-container {
    margin-top: 20px;
    text-align: center;
}

.analyze-button-container button {
    padding: 12px 30px;
    font-size: 18px;
}

.primary-button {
    background-color: #9b59b6;
}

.primary-button:hover {
    background-color: #8e44ad;
}

.secondary-button {
    background-color: #27ae60;
}

.secondary-button:hover {
    background-color: #2ecc71;
}

.status-message {
    color: #666;
    font-style: italic;
    margin-top: 5px;
}

.mobile-responsive {
    overflow-x: auto;
}

@media (max-width: 768px) {
    h1 {
        font-size: 24px;
    }
    
    h2 {
        font-size: 20px;
    }
    
    h3 {
        font-size: 18px;
    }
    
    .container {
        padding: 15px;
    }
    
    button {
        padding: 8px 16px;
        font-size: 14px;
    }
    
    .analyze-button-container button {
        padding: 10px 20px;
        font-size: 16px;
    }
}

.tab-indicator {
    background-color: #2ecc71;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    font-size: 12px;
    margin-left: 5px;
}

/* AI分析結果樣式 */
.ai-analysis-result {
    background-color: #f8f9fc;
    border-left: 4px solid #9b59b6;
    padding: 20px;
    border-radius: 8px;
    margin: 20px 0;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.ai-analysis-title {
    color: #9b59b6;
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
    padding-bottom: 10px;
}

.ai-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 20px 0;
}

.ai-loading .spinner {
    border-top-color: #9b59b6;
    margin-right: 15px;
}

.ai-freq-highlight {
    background-color: #9b59b625;
    border-left: 4px solid #9b59b6;
    padding: 15px;
    margin: 15px 0;
    border-radius: 4px;
}

.ai-freq-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding: 10px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.ai-freq-value {
    font-size: 18px;
    font-weight: bold;
    color: #2c3e50;
}

.ai-freq-reason {
    margin-top: 10px;
    padding: 10px;
    background-color: #f1f1f1;
    border-radius: 4px;
    font-style: italic;
}

.ai-suggestion {
    background-color: #eef7ee;
    padding: 15px;
    border-radius: 8px;
    margin-top: 20px;
    border-left: 4px solid #27ae60;
}

/* noUiSlider 樣式 */
.noui-slider {
    height: 10px;
    width: 100%;
    margin: 15px 0;
}

.noUi-connect {
    background: #3498db;
}

.noUi-horizontal {
    height: 10px;
}

.noUi-handle {
    border: 1px solid #3498db;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
    width: 20px !important;
    height: 20px !important;
    top: -5px !important;
    right: -10px !important;
}

.noUi-handle:before,
.noUi-handle:after {
    display: none;
}

.noUi-tooltip {
    display: none;
}

.noUi-active .noUi-tooltip {
    display: block;
}

.canvas-container {
    height: 220px !important; /* 給圖表高度加上一些額外空間 */
    margin-bottom: 15px;
}
</style>
</head>
<body>
    <h1>物體自然頻率AI分析器</h1>
    
    <div class="container">
        <h2>實驗原理說明</h2>
        <p>此工具用於分析物體的自然頻率。使用方法：</p>
        <ol>
            <li>上傳第一個音檔：純桌面被敲擊的聲音（也可直接錄製）</li>
            <li>上傳第二個音檔：待測物體放在桌面上被敲擊的聲音（也可直接錄製）</li>
            <li>選擇每個音檔中要分析的波形區段</li>
            <li>點擊「分析並取得AI解讀」按鈕進行處理</li>
        </ol>
        <p>系統會顯示兩個音檔的波形圖、頻譜分析（FFT）和功率譜密度（PSD），並使用AI分析識別第二個音檔中獨有的頻率成分，這些頻率即為待測物體的自然頻率。</p>
    </div>
    
    <div class="container">
        <h2>音頻錄製或上傳</h2>
        
        <div class="tab-container">
            <button class="tab-button active" data-target="upload1">上傳檔案</button>
            <button class="tab-button" data-target="record1">錄製音頻</button>
        </div>
        
        <div class="tab-content active" id="upload1">
            <div class="file-upload">
                <div class="upload-box">
                    <label class="upload-label" for="file1">
                        上傳第一個音檔（純桌面）
                        <br><br>
                        <i class="fas fa-cloud-upload-alt" style="font-size: 24px;"></i>
                        <br><br>
                        點擊或拖放文件到此處
                    </label>
                    <input type="file" id="file1" accept="audio/*">
                    <p class="file-name" id="fileName1"></p>
                </div>
                
                <div class="upload-box">
                    <label class="upload-label" for="file2">
                        上傳第二個音檔（物體+桌面）
                        <br><br>
                        <i class="fas fa-cloud-upload-alt" style="font-size: 24px;"></i>
                        <br><br>
                        點擊或拖放文件到此處
                    </label>
                    <input type="file" id="file2" accept="audio/*">
                    <p class="file-name" id="fileName2"></p>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="record1">
            <div class="record-option">
                <h3>錄製第一個音檔（純桌面）<span id="recordStatus1" class="status-message"></span></h3>
                <div class="record-button-container">
                    <button id="startRecord1" class="record-button start">開始錄音</button>
                    <button id="stopRecord1" class="record-button stop" disabled>停止錄音</button>
                    <button id="playRecorded1" class="record-button" disabled>播放錄音</button>
                    <button id="useRecording1" class="record-button use" disabled>使用此錄音</button>
                </div>
                <div class="record-info">
                    <p>錄音時間: <span id="recordTime1" class="record-timer">00:00</span></p>
                </div>
                <div class="record-visualization" id="recordVisual1"></div>
            </div>
            
            <div class="record-option">
                <h3>錄製第二個音檔（物體+桌面）<span id="recordStatus2" class="status-message"></span></h3>
                <div class="record-button-container">
                    <button id="startRecord2" class="record-button start">開始錄音</button>
                    <button id="stopRecord2" class="record-button stop" disabled>停止錄音</button>
                    <button id="playRecorded2" class="record-button" disabled>播放錄音</button>
                    <button id="useRecording2" class="record-button use" disabled>使用此錄音</button>
                </div>
                <div class="record-info">
                    <p>錄音時間: <span id="recordTime2" class="record-timer">00:00</span></p>
                </div>
                <div class="record-visualization" id="recordVisual2"></div>
            </div>
        </div>
    </div>
    
    <!-- 波形預覽與範圍選擇區域 -->
 <!-- 波形預覽與範圍選擇區域 -->
<div class="container" id="previewContainer" style="display:none;">
    <h2>波形預覽與範圍選擇</h2>
    <p>請在下方波形圖上選擇要分析的時間範圍：</p>
    
    <div class="preview-container">
        <div class="preview-title">第一個音檔（純桌面）</div>
        <div class="waveform-preview">
            <canvas id="preview1"></canvas>
            <div id="selection1" class="selection-overlay"></div>
        </div>
        <div class="slider-container">
            <span>時間範圍：</span>
            <div id="slider1" class="noui-slider"></div>
            <div class="time-display">
                <span id="startTime1">0.00 秒</span> - <span id="endTime1">0.00 秒</span>
            </div>
        </div>
        <div class="button-container">
            <button id="playSelection1">播放選擇區域</button>
            <button id="zoomSelection1">放大選擇區域</button>
            <button id="resetZoom1">重設縮放</button>
        </div>
    </div>
        
     <div class="preview-container">
        <div class="preview-title">第二個音檔（物體+桌面）</div>
        <div class="waveform-preview">
            <canvas id="preview2"></canvas>
            <div id="selection2" class="selection-overlay"></div>
        </div>
        <div class="slider-container">
            <span>時間範圍：</span>
            <div id="slider2" class="noui-slider"></div>
            <div class="time-display">
                <span id="startTime2">0.00 秒</span> - <span id="endTime2">0.00 秒</span>
            </div>
        </div>
        <div class="button-container">
            <button id="playSelection2">播放選擇區域</button>
            <button id="zoomSelection2">放大選擇區域</button>
            <button id="resetZoom2">重設縮放</button>
        </div>
    </div>
        
          <div class="analyze-button-container">
        <button id="analyzeBtn" class="primary-button">分析並取得AI解讀</button>
        <div id="statusMessage" class="status-message"></div>
    </div>
        
         <div class="loading" id="loadingIndicator">
        <p>正在處理音頻數據，請稍候...</p>
        <div class="spinner"></div>
    </div>
</div>
    
    <div class="container" id="resultsContainer" style="display:none;">
        <h2>分析結果</h2>
        
        <div class="mobile-responsive">
        <div class="visualizations">
            <div class="viz-container">
                <h3>波形圖</h3>
                <div class="canvas-container">
                    <canvas id="waveform1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="waveform2"></canvas>
                </div>
            </div>
            
            <div class="viz-container">
                <h3>FFT頻譜分析</h3>
                <div class="canvas-container">
                    <canvas id="fft1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="fft2"></canvas>
                </div>
            </div>
        </div>
        
        <div class="visualizations">
            <div class="viz-container">
                <h3>功率譜密度 (PSD)</h3>
                <div class="canvas-container">
                    <canvas id="psd1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="psd2"></canvas>
                </div>
            </div>
            
            <div class="viz-container result-section">
                <h3>AI自然頻率分析</h3>
                <div id="aiAnalysisResult" class="ai-analysis-result">
                    <div id="aiAnalysisContent">
                        <div class="ai-loading">
                            <div class="spinner"></div>
                            <p>AI正在分析數據，請稍候...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </div>
    <script>
// 全局變量
let audioContext;
let file1Data = null;
let file2Data = null;
let audioBuffer1 = null;
let audioBuffer2 = null;
let charts = {};
let audioSource1 = null;
let audioSource2 = null;
let fftData1 = null;
let fftData2 = null;
let psdData1 = null;
let psdData2 = null;

// 選擇範圍變量
let selectedRange1 = { start: 0, end: 1 };
let selectedRange2 = { start: 0, end: 1 };

// 縮放變量
let zoom1 = { start: 0, end: 1 };
let zoom2 = { start: 0, end: 1 };

// 錄音相關變量
let mediaRecorder1 = null;
let mediaRecorder2 = null;
let recordedChunks1 = [];
let recordedChunks2 = [];
let recordingStream1 = null;
let recordingStream2 = null;
let recordingStartTime1 = 0;
let recordingStartTime2 = 0;
let recordingTimer1 = null;
let recordingTimer2 = null;
let recordedBlob1 = null;
let recordedBlob2 = null;
let visualizer1 = null;
let visualizer2 = null;
let recording1Ready = false;
let recording2Ready = false;

// 初始化頁面
document.addEventListener('DOMContentLoaded', function() {
    console.log("初始化頁面");
    
    // 檢查瀏覽器是否支持Web Audio API
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
    } catch (e) {
        alert('您的瀏覽器不支持Web Audio API。請使用Chrome、Firefox、Safari或Edge的最新版本。');
    }
    
    // 檢查瀏覽器是否支持MediaRecorder API
    if (!window.MediaRecorder) {
        document.getElementById('record1').innerHTML = '<p>您的瀏覽器不支持錄音功能。請使用Chrome、Firefox、Safari或Edge的最新版本。</p>';
    }
    
    // 設置標籤頁切換
    setupTabs();
    
    // 文件上傳事件處理
    document.getElementById('file1').addEventListener('change', function(e) {
        handleFileUpload(e, 'file1', 'fileName1');
    });
    
    document.getElementById('file2').addEventListener('change', function(e) {
        handleFileUpload(e, 'file2', 'fileName2');
    });
    
    // 拖放事件
    setupDragAndDrop('file1', 'fileName1');
    setupDragAndDrop('file2', 'fileName2');
    
    // 錄音事件處理
    setupRecording(1);
    setupRecording(2);
    
    // 分析按鈕事件
    const analyzeBtn = document.getElementById('analyzeBtn');
    analyzeBtn.addEventListener('click', function() {
        console.log("分析按鈕被點擊");
        analyzeAudioWithAI();
    });
    
    // 範圍選擇事件
    setupRangeSelection(1);
    setupRangeSelection(2);
    
    // 播放選擇區域事件
    document.getElementById('playSelection1').addEventListener('click', function() {
        playSelectedAudio(1);
    });
    document.getElementById('playSelection2').addEventListener('click', function() {
        playSelectedAudio(2);
    });
    
    // 縮放事件
    document.getElementById('zoomSelection1').addEventListener('click', function() {
        zoomToSelection(1);
    });
    document.getElementById('zoomSelection2').addEventListener('click', function() {
        zoomToSelection(2);
    });
    
    // 重設縮放
    document.getElementById('resetZoom1').addEventListener('click', function() {
        resetZoom(1);
    });
    document.getElementById('resetZoom2').addEventListener('click', function() {
        resetZoom(2);
    });
    
    // 確保初始狀態下分析按鈕是禁用的
    analyzeBtn.disabled = true;
    updateStatusMessage("請上傳或錄製音檔後再進行分析");
});

// 設置標籤頁切換
function setupTabs() {
    const tabButtons = document.querySelectorAll('.tab-button');
    
    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            // 取得目標標籤頁ID
            const targetId = this.getAttribute('data-target');
            
            // 移除所有標籤頁按鈕的active類
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 隱藏所有標籤頁內容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 添加當前按鈕的active類
            this.classList.add('active');
            
            // 顯示目標標籤頁內容
            document.getElementById(targetId).classList.add('active');
        });
    });
}

// 設置錄音功能
function setupRecording(fileNumber) {
    const startButton = document.getElementById(`startRecord${fileNumber}`);
    const stopButton = document.getElementById(`stopRecord${fileNumber}`);
    const playButton = document.getElementById(`playRecorded${fileNumber}`);
    const useButton = document.getElementById(`useRecording${fileNumber}`);
    const statusDisplay = document.getElementById(`recordStatus${fileNumber}`);
    const timerDisplay = document.getElementById(`recordTime${fileNumber}`);
    const visualizerContainer = document.getElementById(`recordVisual${fileNumber}`);
    
    // 開始錄音按鈕事件
    startButton.addEventListener('click', function() {
        startRecording(fileNumber);
    });
    
    // 停止錄音按鈕事件
    stopButton.addEventListener('click', function() {
        stopRecording(fileNumber);
    });
    
    // 播放錄音按鈕事件
    playButton.addEventListener('click', function() {
        playRecording(fileNumber);
    });
    
    // 使用錄音按鈕事件
    useButton.addEventListener('click', function() {
        useRecording(fileNumber);
    });
}

// 檢測支持的錄音格式
function getSupportedMimeTypes() {
    const possibleTypes = [
        'audio/webm',
        'audio/webm;codecs=opus',
        'audio/ogg',
        'audio/ogg;codecs=opus',
        'audio/mp4',
        'audio/mp4;codecs=aac',
        'audio/wav',
        'audio/wav;codecs=1'
    ];
    
    return possibleTypes.filter(type => {
        try {
            return MediaRecorder.isTypeSupported(type);
        } catch(e) {
            return false;
        }
    });
}

// 開始錄音
async function startRecording(fileNumber) {
    try {
        // 請求麥克風權限
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // 恢復AudioContext（解決移動設備上的問題）
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        // 檢測支持的格式
        const supportedMimeTypes = getSupportedMimeTypes();
        console.log("支持的錄音格式:", supportedMimeTypes);
        
        if (supportedMimeTypes.length === 0) {
            throw new Error("您的瀏覽器不支持任何可用的錄音格式");
        }
        
        // 使用第一個支持的格式
        const mimeType = supportedMimeTypes[0];
        console.log(`使用錄音格式: ${mimeType}`);
        
        // 設置錄音器
        const recorderOptions = { mimeType };
        const recorder = new MediaRecorder(stream, recorderOptions);
        
        // 存儲全局變量
        if (fileNumber === 1) {
            recordedChunks1 = [];
            recordingStream1 = stream;
            mediaRecorder1 = recorder;
            recordingStartTime1 = Date.now();
            
            // 創建可視化
            visualizer1 = createVisualizer(stream, 'recordVisual1');
            
            // 啟動計時器
            startTimer(fileNumber);
            
            // 更新狀態
            document.getElementById('recordStatus1').textContent = "正在錄音...";
            document.getElementById('startRecord1').disabled = true;
            document.getElementById('stopRecord1').disabled = false;
            document.getElementById('playRecorded1').disabled = true;
            document.getElementById('useRecording1').disabled = true;
        } else {
            recordedChunks2 = [];
            recordingStream2 = stream;
            mediaRecorder2 = recorder;
            recordingStartTime2 = Date.now();
            
            // 創建可視化
            visualizer2 = createVisualizer(stream, 'recordVisual2');
            
            // 啟動計時器
            startTimer(fileNumber);
            
            // 更新狀態
            document.getElementById('recordStatus2').textContent = "正在錄音...";
            document.getElementById('startRecord2').disabled = true;
            document.getElementById('stopRecord2').disabled = false;
            document.getElementById('playRecorded2').disabled = true;
            document.getElementById('useRecording2').disabled = true;
        }
        
        // 設置數據處理事件
        recorder.ondataavailable = function(e) {
            if (e.data.size > 0) {
                if (fileNumber === 1) {
                    recordedChunks1.push(e.data);
                } else {
                    recordedChunks2.push(e.data);
                }
            }
        };
        
        // 錄音結束事件
        recorder.onstop = function() {
            if (fileNumber === 1) {
                // 停止流和可視化
                stopMediaTracks(recordingStream1);
                if (visualizer1) {
                    visualizer1.disconnect();
                }
                
                // 停止計時器
                clearInterval(recordingTimer1);
                
                // 創建音頻Blob，使用實際使用的MIME類型
                const actualType = mediaRecorder1.mimeType || 'audio/webm';
                recordedBlob1 = new Blob(recordedChunks1, { type: actualType });
                
                // 更新狀態
                document.getElementById('recordStatus1').textContent = "錄音完成";
                document.getElementById('startRecord1').disabled = false;
                document.getElementById('stopRecord1').disabled = true;
                document.getElementById('playRecorded1').disabled = false;
                document.getElementById('useRecording1').disabled = false;
                
                recording1Ready = true;
            } else {
                // 停止流和可視化
                stopMediaTracks(recordingStream2);
                if (visualizer2) {
                    visualizer2.disconnect();
                }
                
                // 停止計時器
                clearInterval(recordingTimer2);
                
                // 創建音頻Blob，使用實際使用的MIME類型
                const actualType = mediaRecorder2.mimeType || 'audio/webm';
                recordedBlob2 = new Blob(recordedChunks2, { type: actualType });
                
                // 更新狀態
                document.getElementById('recordStatus2').textContent = "錄音完成";
                document.getElementById('startRecord2').disabled = false;
                document.getElementById('stopRecord2').disabled = true;
                document.getElementById('playRecorded2').disabled = false;
                document.getElementById('useRecording2').disabled = false;
                
                recording2Ready = true;
            }
        };
        
        // 開始錄音，每100毫秒獲取一次數據
        recorder.start(100);
        
    } catch (error) {
        console.error(`錄音時發生錯誤 (音檔${fileNumber}):`, error);
        
        let errorMessage = "";
        if (error.name === "NotAllowedError") {
            errorMessage = "請允許麥克風權限以進行錄音";
        } else if (error.message.includes("mimeType") || error.name === "NotSupportedError") {
            errorMessage = "瀏覽器不支持錄音格式，請嘗試使用Chrome或Firefox";
        } else {
            errorMessage = `錄音錯誤: ${error.message}`;
        }
        
        alert(`無法開始錄音: ${errorMessage}`);
        console.log("錄音錯誤詳情:", error);
        
        // 重設按鈕狀態
        if (fileNumber === 1) {
            document.getElementById('startRecord1').disabled = false;
            document.getElementById('stopRecord1').disabled = true;
            document.getElementById('recordStatus1').textContent = "錄音失敗: " + errorMessage;
        } else {
            document.getElementById('startRecord2').disabled = false;
            document.getElementById('stopRecord2').disabled = true;
            document.getElementById('recordStatus2').textContent = "錄音失敗: " + errorMessage;
        }
    }
}

// 停止錄音
function stopRecording(fileNumber) {
    if (fileNumber === 1 && mediaRecorder1 && mediaRecorder1.state !== 'inactive') {
        mediaRecorder1.stop();
    } else if (fileNumber === 2 && mediaRecorder2 && mediaRecorder2.state !== 'inactive') {
        mediaRecorder2.stop();
    }
}

// 播放錄音
function playRecording(fileNumber) {
    const blob = fileNumber === 1 ? recordedBlob1 : recordedBlob2;
    
    if (!blob) {
        console.error(`沒有可用的錄音 (音檔${fileNumber})`);
        return;
    }
    
    // 創建音頻元素播放
    const audioURL = URL.createObjectURL(blob);
    const audio = new Audio(audioURL);
    audio.play();
    
    // 播放完成後釋放URL
    audio.onended = function() {
        URL.revokeObjectURL(audioURL);
    };
}

// 使用錄音作為音頻源
async function useRecording(fileNumber) {
    const blob = fileNumber === 1 ? recordedBlob1 : recordedBlob2;
    
    if (!blob) {
        console.error(`沒有可用的錄音 (音檔${fileNumber})`);
        return;
    }
    
    try {
        // 將Blob轉換為ArrayBuffer
        const arrayBuffer = await blob.arrayBuffer();
        
        // 處理錄音數據
        if (fileNumber === 1) {
            file1Data = arrayBuffer;
            document.getElementById('fileName1').textContent = "已錄製的音頻";
        } else {
            file2Data = arrayBuffer;
            document.getElementById('fileName2').textContent = "已錄製的音頻";
        }
        
        // 解碼並預覽
        await decodeAndPreview(arrayBuffer, fileNumber);
        
        // 更新狀態
        if (fileNumber === 1) {
            document.getElementById('recordStatus1').textContent = "已使用此錄音";
            
            // 在標籤頁按鈕上添加指示器
            const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
            if (tabButton) {
                if (!tabButton.querySelector('.tab-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'tab-indicator';
                    indicator.textContent = '✓';
                    tabButton.appendChild(indicator);
                }
            }
        } else {
            document.getElementById('recordStatus2').textContent = "已使用此錄音";
        }
        
    } catch (error) {
        console.error(`處理錄音時發生錯誤 (音檔${fileNumber}):`, error);
        alert(`無法處理錄音。錯誤: ${error.message}`);
    }
}

// 啟動錄音計時器
function startTimer(fileNumber) {
    const timerDisplay = document.getElementById(`recordTime${fileNumber}`);
    const startTime = Date.now();
    
    if (fileNumber === 1) {
        // 清除舊計時器
        if (recordingTimer1) {
            clearInterval(recordingTimer1);
        }
        
        // 設置新計時器
        recordingTimer1 = setInterval(function() {
            const elapsedTime = Date.now() - startTime;
            const seconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }, 1000);
    } else {
        // 清除舊計時器
        if (recordingTimer2) {
            clearInterval(recordingTimer2);
        }
        
        // 設置新計時器
        recordingTimer2 = setInterval(function() {
            const elapsedTime = Date.now() - startTime;
            const seconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }, 1000);
    }
}

// 停止媒體軌道
function stopMediaTracks(stream) {
    if (stream) {
        stream.getTracks().forEach(track => {
            track.stop();
        });
    }
}

// 創建音頻可視化
function createVisualizer(stream, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return null;
    
    try {
        // 清空容器
        container.innerHTML = '';
        
        // 創建畫布
        const canvas = document.createElement('canvas');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // 創建音頻分析器
        const audioSource = audioContext.createMediaStreamSource(stream);
        const analyzer = audioContext.createAnalyser();
        analyzer.fftSize = 256;
        
        audioSource.connect(analyzer);
        
        const bufferLength = analyzer.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        // 動畫函數
        function draw() {
            // 獲取畫布尺寸（可能已更改）
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            requestAnimationFrame(draw);
            
            analyzer.getByteFrequencyData(dataArray);
            
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * canvas.height;
                
                // 根據頻率設置顏色漸變
                const r = 50 + (i * 2);
                const g = 50 + (i * 1);
                const b = 200;
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }
        
        draw();
        
        return audioSource;
    } catch (error) {
        console.error('創建可視化時發生錯誤:', error);
        return null;
    }
}

// 更新狀態消息
function updateStatusMessage(message) {
    const statusElement = document.getElementById('statusMessage');
    if (statusElement) {
        statusElement.textContent = message;
    }
}

// 處理文件上傳
function handleFileUpload(event, fileId, fileNameId) {
    const file = event.target.files[0];
    if (!file) return;
    
    document.getElementById(fileNameId).textContent = file.name;
    updateStatusMessage(`正在載入 ${file.name}...`);
    
    const reader = new FileReader();
    reader.onload = function(e) {
        if (fileId === 'file1') {
            file1Data = e.target.result;
            decodeAndPreview(file1Data, 1);
            
            // 在標籤頁按鈕上添加指示器
            const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
            if (tabButton) {
                if (!tabButton.querySelector('.tab-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'tab-indicator';
                    indicator.textContent = '✓';
                    tabButton.appendChild(indicator);
                }
            }
        } else {
            file2Data = e.target.result;
            decodeAndPreview(file2Data, 2);
        }
    };
    reader.onerror = function() {
        updateStatusMessage(`讀取文件 ${file.name} 時出錯`);
    };
    reader.readAsArrayBuffer(file);
}

// 設置拖放功能
function setupDragAndDrop(fileId, fileNameId) {
    const dropZone = document.querySelector(`label[for="${fileId}"]`).parentNode;
    
    dropZone.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '#e3f2fd';
    });
    
    dropZone.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '';
    });
    
    dropZone.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '';
        
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('audio/')) {
            document.getElementById(fileId).files = e.dataTransfer.files;
            document.getElementById(fileNameId).textContent = file.name;
            updateStatusMessage(`正在載入 ${file.name}...`);
            
            const reader = new FileReader();
            reader.onload = function(event) {
                if (fileId === 'file1') {
                    file1Data = event.target.result;
                    decodeAndPreview(file1Data, 1);
                    
                    // 在標籤頁按鈕上添加指示器
                    const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
                    if (tabButton) {
                        if (!tabButton.querySelector('.tab-indicator')) {
                            const indicator = document.createElement('span');
                            indicator.className = 'tab-indicator';
                            indicator.textContent = '✓';
                            tabButton.appendChild(indicator);
                        }
                    }
                } else {
                    file2Data = event.target.result;
                    decodeAndPreview(file2Data, 2);
                }
            };
            reader.onerror = function() {
                updateStatusMessage(`讀取文件 ${file.name} 時出錯`);
            };
            reader.readAsArrayBuffer(file);
        }
    });
}

// 解碼音頻並預覽
async function decodeAndPreview(audioData, fileNumber) {
    try {
        // 顯示預覽容器 (在嘗試解碼前就顯示)
        document.getElementById('previewContainer').style.display = 'block';
        
        // 解碼音頻
        console.log(`開始解碼音頻 ${fileNumber}`);
        const audioBuffer = await decodeAudio(audioData);
        console.log(`音頻 ${fileNumber} 解碼完成，時長: ${audioBuffer.duration} 秒`);
        
        if (fileNumber === 1) {
            audioBuffer1 = audioBuffer;
            // 初始化選擇範圍
            selectedRange1 = { start: 0, end: audioBuffer.duration };
            zoom1 = { start: 0, end: audioBuffer.duration };
            
        } else {
            audioBuffer2 = audioBuffer;
            // 初始化選擇範圍
            selectedRange2 = { start: 0, end: audioBuffer.duration };
            zoom2 = { start: 0, end: audioBuffer.duration };
        }
        
        // 繪製預覽波形
        console.log(`繪製音頻 ${fileNumber} 的波形`);
        drawPreviewWaveform(audioBuffer, fileNumber);
        
        // 初始化範圍滑桿
        initializeNoUiSlider(fileNumber, 0, audioBuffer.duration);
        
        // 檢查兩個文件是否都已上傳
        checkFilesReady();
        
    } catch (error) {
        console.error(`解碼音頻 ${fileNumber} 時發生錯誤:`, error);
        updateStatusMessage(`無法解碼音頻文件 ${fileNumber}: ${error.message}`);
    }
}

// 初始化noUiSlider
function initializeNoUiSlider(fileNumber, minTime, maxTime) {
    const sliderElement = document.getElementById(`slider${fileNumber}`);
    
    // 如果已經初始化，則銷毀
    if (sliderElement.noUiSlider) {
        sliderElement.noUiSlider.destroy();
    }
    
    // 創建noUiSlider
    noUiSlider.create(sliderElement, {
        start: [minTime, maxTime],
        connect: true,
        range: {
            'min': minTime,
            'max': maxTime
        },
        step: 0.01,
        format: {
            to: function (value) {
                return parseFloat(value.toFixed(2));
            },
            from: function (value) {
                return parseFloat(value);
            }
        }
    });
    
    // 監聽滑塊變化
    sliderElement.noUiSlider.on('update', function (values) {
        const startTime = values[0];
        const endTime = values[1];
        
        // 更新顯示
        document.getElementById(`startTime${fileNumber}`).textContent = startTime.toFixed(2) + ' 秒';
        document.getElementById(`endTime${fileNumber}`).textContent = endTime.toFixed(2) + ' 秒';
        
        // 更新選擇範圍
        if (fileNumber === 1) {
            selectedRange1 = { start: startTime, end: endTime };
        } else {
            selectedRange2 = { start: startTime, end: endTime };
        }
        
        // 更新選擇覆蓋層
        updateSelectionOverlay(fileNumber);
    });
}

// 設置範圍選擇
function setupRangeSelection(fileNumber) {
    // 注意: 這個函數在使用noUiSlider後不再需要設置事件監聽器
    // 但保留函數以保持與原代碼的兼容性
}

// 更新選擇覆蓋層
function updateSelectionOverlay(fileNumber) {
    const canvas = document.getElementById(`preview${fileNumber}`);
    const overlay = document.getElementById(`selection${fileNumber}`);
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    const zoomRange = fileNumber === 1 ? zoom1 : zoom2;
    const duration = zoomRange.end - zoomRange.start;
    
    // 計算相對於當前縮放的百分比
    const startPercent = (range.start - zoomRange.start) / duration * 100;
    const endPercent = (range.end - zoomRange.start) / duration * 100;
    
    // 更新覆蓋層位置和寬度
    overlay.style.left = `${startPercent}%`;
    overlay.style.width = `${endPercent - startPercent}%`;
}

// 縮放到選擇範圍
function zoomToSelection(fileNumber) {
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    
    if (fileNumber === 1) {
        zoom1 = { start: range.start, end: range.end };
        drawPreviewWaveform(audioBuffer1, 1);
        
        // 更新範圍滑桿
        const slider1 = document.getElementById('slider1');
        if (slider1.noUiSlider) {
            slider1.noUiSlider.updateOptions({
                range: {
                    'min': range.start,
                    'max': range.end
                }
            });
            slider1.noUiSlider.set([range.start, range.end]);
        }
    } else {
        zoom2 = { start: range.start, end: range.end };
        drawPreviewWaveform(audioBuffer2, 2);
        
        // 更新範圍滑桿
        const slider2 = document.getElementById('slider2');
        if (slider2.noUiSlider) {
            slider2.noUiSlider.updateOptions({
                range: {
                    'min': range.start,
                    'max': range.end
                }
            });
            slider2.noUiSlider.set([range.start, range.end]);
        }
    }
}

// 重設縮放
function resetZoom(fileNumber) {
    const buffer = fileNumber === 1 ? audioBuffer1 : audioBuffer2;
    if (!buffer) return;
    
    if (fileNumber === 1) {
        zoom1 = { start: 0, end: buffer.duration };
        drawPreviewWaveform(buffer, 1);
        
        // 更新範圍滑桿
        const slider1 = document.getElementById('slider1');
        if (slider1.noUiSlider) {
            slider1.noUiSlider.updateOptions({
                range: {
                    'min': 0,
                    'max': buffer.duration
                }
            });
            slider1.noUiSlider.set([0, buffer.duration]);
        }
    } else {
        zoom2 = { start: 0, end: buffer.duration };
        drawPreviewWaveform(buffer, 2);
        
        // 更新範圍滑桿
        const slider2 = document.getElementById('slider2');
        if (slider2.noUiSlider) {
            slider2.noUiSlider.updateOptions({
                range: {
                    'min': 0,
                    'max': buffer.duration
                }
            });
            slider2.noUiSlider.set([0, buffer.duration]);
        }
    }
}

// 播放選擇的音頻
function playSelectedAudio(fileNumber) {
    // 停止當前正在播放的音頻
    if (fileNumber === 1 && audioSource1) {
        audioSource1.stop();
        audioSource1 = null;
    } else if (fileNumber === 2 && audioSource2) {
        audioSource2.stop();
        audioSource2 = null;
    }
    
    const buffer = fileNumber === 1 ? audioBuffer1 : audioBuffer2;
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    
    if (!buffer) return;
    
    try {
        // 確保AudioContext處於運行狀態
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // 創建音頻源
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        
        // 存儲音頻源以便之後停止
        if (fileNumber === 1) {
            audioSource1 = source;
        } else {
            audioSource2 = source;
        }
        
        // 播放選擇的部分
        source.start(0, range.start, range.end - range.start);
        
        // 播放完成後清理
        source.onended = function() {
            if (fileNumber === 1) {
                audioSource1 = null;
            } else {
                audioSource2 = null;
            }
        };
    } catch (error) {
        console.error('播放音頻時發生錯誤:', error);
        updateStatusMessage(`播放音頻時發生錯誤: ${error.message}`);
    }
}

// 檢查檔案是否已就緒
function checkFilesReady() {
    const analyzeBtn = document.getElementById('analyzeBtn');
    
    if (audioBuffer2) {
        console.log("至少有第二個音檔已上傳並解碼完成，啟用分析按鈕");
        analyzeBtn.disabled = false;
        
        if (!audioBuffer1) {
            updateStatusMessage("僅上傳第二個音檔，將直接分析物體的自然頻率");
        } else {
            updateStatusMessage("兩個音檔已上傳，可以進行比較分析");
        }
    } else {
        console.log("尚未上傳第二個音檔，分析按鈕保持禁用");
        analyzeBtn.disabled = true;
        if (audioBuffer1) {
            updateStatusMessage("已上傳第一個音檔，請上傳第二個音檔");
        } else {
            updateStatusMessage("請至少上傳第二個音檔後再進行分析");
        }
    }
}

// 繪製預覽波形
function drawPreviewWaveform(audioBuffer, fileNumber) {
    const canvas = document.getElementById(`preview${fileNumber}`);
    if (!canvas) {
        console.error(`Canvas element preview${fileNumber} not found`);
        return;
    }
    
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error(`Could not get 2D context for canvas preview${fileNumber}`);
        return;
    }
    
    // 獲取音頻數據
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600; // 預設寬度以防父元素寬度未設置
    canvas.width = parentWidth;
    canvas.height = 150;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 獲取當前縮放範圍
    const zoomRange = fileNumber === 1 ? zoom1 : zoom2;
    const startSample = Math.floor(zoomRange.start * sampleRate);
    const endSample = Math.min(Math.floor(zoomRange.end * sampleRate), channelData.length);
    
    // 計算每個像素對應的樣本數
    const samplesPerPixel = Math.max(1, Math.ceil((endSample - startSample) / canvas.width));
    
    // 繪製波形
    ctx.strokeStyle = '#3498db';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    for (let i = 0; i < canvas.width; i++) {
        // 計算當前像素對應的樣本範圍
        const sampleStart = startSample + i * samplesPerPixel;
        const sampleEnd = Math.min(sampleStart + samplesPerPixel, endSample);
        
        // 在樣本範圍內尋找最大和最小值
        let min = Infinity;
        let max = -Infinity;
        
        for (let j = sampleStart; j < sampleEnd; j++) {
            if (j < channelData.length) {
                const value = channelData[j];
                if (value < min) min = value;
                if (value > max) max = value;
            }
        }
        
        // 如果沒有找到有效值，設置為0
        if (min === Infinity) min = 0;
        if (max === -Infinity) max = 0;
        
        // 將值映射到畫布高度
        const y1 = (1 + min) * canvas.height / 2;
        const y2 = (1 + max) * canvas.height / 2;
        
        // 繪製垂直線段
        ctx.moveTo(i, y1);
        ctx.lineTo(i, y2);
    }
    
    ctx.stroke();
}

// 使用AI分析音頻
async function analyzeAudioWithAI() {
    console.log("執行音頻分析並用AI解讀");
    
    // 確保有第二個音檔的數據
    if (!audioBuffer2) {
        console.error("缺少第二個音檔數據，無法分析");
        alert('請至少上傳第二個音頻文件（物體+桌面）。');
        return;
    }
    
    // 顯示載入指示器
    document.getElementById('loadingIndicator').style.display = 'block';
    document.getElementById('analyzeBtn').disabled = true;
    updateStatusMessage("正在分析音頻數據...");
    
    // 清除先前的圖表
    Object.values(charts).forEach(chart => {
        if (chart) chart.destroy();
    });
    
    try {
        console.log("提取選定範圍的數據");
        
        // 如果有第一個音檔，則提取其數據
        let selectedData1 = null;
        if (audioBuffer1) {
            selectedData1 = extractSelectedData(audioBuffer1, selectedRange1);
            console.log("繪製第一個音檔波形圖");
            drawWaveform(selectedData1, 'waveform1', '純桌面波形');
        }
        
        // 提取第二個音檔數據
        const selectedData2 = extractSelectedData(audioBuffer2, selectedRange2);
        console.log("繪製第二個音檔波形圖");
        drawWaveform(selectedData2, 'waveform2', '物體+桌面波形');
        
        console.log("計算FFT");
        // 如果有第一個音檔，計算其FFT
        if (selectedData1) {
            fftData1 = calculateFFT(selectedData1);
            console.log("繪製第一個音檔FFT圖");
            drawFFT(fftData1, 'fft1', '純桌面頻譜');
        } else {
            fftData1 = null;
        }
        
        // 計算第二個音檔的FFT
        fftData2 = calculateFFT(selectedData2);
        console.log("繪製第二個音檔FFT圖");
        drawFFT(fftData2, 'fft2', '物體+桌面頻譜');
        
        console.log("計算PSD");
        // 如果有第一個音檔，計算其PSD
        if (selectedData1) {
            psdData1 = calculatePSD(selectedData1);
            console.log("繪製第一個音檔PSD圖");
            drawPSD(psdData1, 'psd1', '純桌面功率譜密度');
        } else {
            psdData1 = null;
        }
        
        // 計算第二個音檔的PSD
        psdData2 = calculatePSD(selectedData2);
        console.log("繪製第二個音檔PSD圖");
        drawPSD(psdData2, 'psd2', '物體+桌面功率譜密度');
        
        console.log("顯示結果容器");
        // 顯示結果容器
        document.getElementById('resultsContainer').style.display = 'block';
        
        // 滾動到結果區域
        document.getElementById('resultsContainer').scrollIntoView({ behavior: 'smooth' });
        
        // 使用AI分析數據
        await performAIAnalysis();
        
        updateStatusMessage("分析完成");
        
    } catch (error) {
        console.error('分析過程中發生錯誤:', error);
        alert('分析過程中發生錯誤: ' + error.message);
        updateStatusMessage(`分析過程中發生錯誤: ${error.message}`);
    } finally {
        // 隱藏載入指示器
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('analyzeBtn').disabled = false;
    }
}

// 從AudioBuffer中提取選定範圍的數據
function extractSelectedData(audioBuffer, range) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 計算選擇的樣本範圍
    const startSample = Math.floor(range.start * sampleRate);
    const endSample = Math.min(Math.floor(range.end * sampleRate), channelData.length);
    const sampleCount = endSample - startSample;
    
    if (sampleCount <= 0) {
        throw new Error("選擇的範圍無效或太小");
    }
    
    // 創建新的AudioBuffer
    const newBuffer = audioContext.createBuffer(
        audioBuffer.numberOfChannels,
        sampleCount,
        sampleRate
    );
    
    // 複製選擇範圍的數據
    const newChannelData = newBuffer.getChannelData(0);
    for (let i = 0; i < sampleCount; i++) {
        newChannelData[i] = channelData[startSample + i];
    }
    
    return newBuffer;
}

// 解碼音頻
async function decodeAudio(audioData) {
    return new Promise((resolve, reject) => {
        try {
            // 確保有有效的音頻數據
            if (!audioData || audioData.byteLength === 0) {
                reject(new Error("無效的音頻數據"));
                return;
            }
            
            // 嘗試解碼
            audioContext.decodeAudioData(
                audioData.slice(0), 
                (buffer) => {
                    if (buffer) {
                        resolve(buffer);
                    } else {
                        reject(new Error("解碼音頻失敗"));
                    }
                },
                (error) => {
                    reject(error || new Error("解碼音頻時發生未知錯誤"));
                }
            );
        } catch (error) {
            reject(error);
        }
    });
}

function drawWaveform(audioBuffer, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 獲取音頻數據
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 設置畫布大小 - 與FFT圖保持一致
    const parentWidth = canvas.parentNode.clientWidth || 600;
    const targetHeight = 200; // 基礎高度
    canvas.width = parentWidth;
    canvas.height = targetHeight;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 繪製波形
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    // 對數據進行下採樣以適應畫布寬度
    const downsampleFactor = Math.max(1, Math.ceil(channelData.length / canvas.width));
    const maxData = [];  // 用於存儲最大值
    const minData = [];  // 用於存儲最小值
    
    for (let i = 0; i < canvas.width; i++) {
        const startIndex = i * downsampleFactor;
        const endIndex = Math.min((i + 1) * downsampleFactor, channelData.length);
        
        // 在每個區間內尋找最大和最小值
        let min = Infinity;
        let max = -Infinity;
        
        for (let j = startIndex; j < endIndex; j++) {
            if (j < channelData.length) {
                const value = channelData[j];
                if (value < min) min = value;
                if (value > max) max = value;
            }
        }
        
        // 如果沒有找到有效值，設置為0
        if (min === Infinity) min = 0;
        if (max === -Infinity) max = 0;
        
        const x = i / canvas.width * audioBuffer.duration;
        
        // 分別存儲最大值和最小值
        maxData.push({ x: x, y: max });
        minData.push({ x: x, y: min });
    }
    
    // 使用Chart.js創建波形圖，同時繪製最大值和最小值
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    label: label,
                    data: maxData,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: false
                },
                {
                    label: '_hidden', // 使用下劃線前綴的標籤會被圖例忽略
                    data: minData,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: '+1',  // 填充到前一個數據集
                    backgroundColor: 'rgba(75, 192, 192, 0.2)'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // 不維持寬高比，允許完全自定義高度
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '時間 (秒)'
                    },
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: '振幅'
                    },
                    min: -1.1,
                    max: 1.1,
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        filter: function(item) {
                            // 不顯示以下劃線開頭的標籤
                            return !item.text.startsWith('_');
                        },
                        boxWidth: 15,
                        padding: 5
                    }
                },
                tooltip: {
                    enabled: false // 禁用工具提示以提高性能
                }
            },
            layout: {
                padding: {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }
            },
            animation: false,
            elements: {
                line: {
                    tension: 0 // 禁用曲線平滑
                }
            }
        }
    });
    
    // 設置容器樣式以確保高度匹配
    const container = canvas.parentNode;
    if (container) {
        container.style.height = targetHeight + 'px';
    }
}

// FFT 類實現
class FFT {
    constructor(size) {
        this.size = size;
        this.csize = size * 2;
        
        // 預計算反轉位元表
        this.reverseBits = new Array(size);
        for (let i = 0; i < size; i++) {
            this.reverseBits[i] = this.calculateReverseBits(i, Math.log2(size));
        }
        
        // 預計算旋轉因子
        this.cosTable = new Array(size / 2);
        this.sinTable = new Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
            this.cosTable[i] = Math.cos(2 * Math.PI * i / size);
            this.sinTable[i] = Math.sin(2 * Math.PI * i / size);
        }
    }
    
    // 計算反轉位元
    calculateReverseBits(x, bits) {
        let res = 0;
        for (let i = 0; i < bits; i++) {
            res = (res << 1) | (x & 1);
            x >>= 1;
        }
        return res;
    }
    
    // 執行FFT
    forward(input) {
        // 創建複數數組 (實部+虛部)
        const complex = new Float32Array(this.csize);
        
        // 填充實部，虛部為零
        for (let i = 0; i < this.size; i++) {
            complex[2 * this.reverseBits[i]] = input[i];
        }
        
        // 蝴蝶運算
        for (let len = 2; len <= this.size; len *= 2) {
            const halfLen = len / 2;
            const tablestep = this.size / len;
            
            for (let i = 0; i < this.size; i += len) {
                for (let j = 0; j < halfLen; j++) {
                    const idx1 = 2 * (i + j);
                    const idx2 = 2 * (i + j + halfLen);
                    
                    const k = j * tablestep;
                    const cosVal = this.cosTable[k];
                    const sinVal = this.sinTable[k];
                    
                    const re = complex[idx2] * cosVal + complex[idx2 + 1] * sinVal;
                    const im = complex[idx2 + 1] * cosVal - complex[idx2] * sinVal;
                    
                    complex[idx2] = complex[idx1] - re;
                    complex[idx2 + 1] = complex[idx1 + 1] - im;
                    complex[idx1] += re;
                    complex[idx1 + 1] += im;
                }
            }
        }
        
        // 計算幅度
        const magnitudes = new Float32Array(this.size);
        for (let i = 0; i < this.size; i++) {
            const re = complex[2 * i];
            const im = complex[2 * i + 1];
            magnitudes[i] = Math.sqrt(re * re + im * im) / this.size;
        }
        
        return magnitudes;
    }
}

// 計算FFT
function calculateFFT(audioBuffer) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 確定FFT大小（2的冪次方）
    const fftSize = Math.pow(2, Math.ceil(Math.log2(channelData.length)));
    
    // 創建FFT對象
    const fft = new FFT(fftSize);
    
    // 準備輸入數據（用零填充）
    const fftInput = new Float32Array(fftSize);
    fftInput.set(channelData.slice(0, fftSize));
    
    // 在執行FFT前應用窗口函數（漢寧窗）
    applyHannWindow(fftInput);
    
    // 執行FFT
    const fftOutput = fft.forward(fftInput);
    
    // 計算頻率分辨率
    const freqStep = sampleRate / fftSize;
    
    // 準備結果數據（只取前半部分，因為FFT結果是對稱的）
    const result = {
        frequencies: [],
        magnitudes: [],
        sampleRate: sampleRate
    };
    
    for (let i = 0; i < fftSize / 2; i++) {
        result.frequencies.push(i * freqStep);
        result.magnitudes.push(fftOutput[i]);
    }
    
    return result;
}

// 應用漢寧窗
function applyHannWindow(buffer) {
    for (let i = 0; i < buffer.length; i++) {
        const multiplier = 0.5 * (1 - Math.cos(2 * Math.PI * i / (buffer.length - 1)));
        buffer[i] *= multiplier;
    }
}

// 計算功率譜密度 (PSD)
function calculatePSD(audioBuffer) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 確定FFT大小（2的冪次方）
    const fftSize = Math.pow(2, Math.ceil(Math.log2(channelData.length)));
    
    // 創建FFT對象
    const fft = new FFT(fftSize);
    
    // 準備輸入數據（用零填充）
    const fftInput = new Float32Array(fftSize);
    fftInput.set(channelData.slice(0, fftSize));
    
    // 在執行FFT前應用窗口函數（漢寧窗）
    applyHannWindow(fftInput);
    
    // 執行FFT
    const fftOutput = fft.forward(fftInput);
    
    // 計算頻率分辨率
    const freqStep = sampleRate / fftSize;
    
    // 準備結果數據（只取前半部分，因為FFT結果是對稱的）
    const result = {
        frequencies: [],
        psd: [],
        sampleRate: sampleRate
    };
    
    for (let i = 0; i < fftSize / 2; i++) {
        result.frequencies.push(i * freqStep);
        // 計算功率譜密度（幅度的平方除以頻率分辨率）
        result.psd.push((fftOutput[i] * fftOutput[i]) / freqStep);
    }
    
    return result;
}

// 繪製FFT圖
function drawFFT(fftData, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600;
    const targetHeight = 200; // 與波形圖一致的高度
    canvas.width = parentWidth;
    canvas.height = targetHeight;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 創建數據點
    const dataPoints = [];
    const maxFreq = 5000; // 最大顯示頻率 (Hz)
    
    for (let i = 0; i < fftData.frequencies.length; i++) {
        if (fftData.frequencies[i] <= maxFreq) {
            dataPoints.push({
                x: fftData.frequencies[i],
                y: fftData.magnitudes[i]
            });
        }
    }
    
    // 使用Chart.js創建FFT圖
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: label,
                data: dataPoints,
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                pointRadius: 0,
                fill: false
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // 不維持寬高比，允許完全自定義高度
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '頻率 (Hz)'
                    },
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                },
                y: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '振幅'
                    },
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        boxWidth: 15,
                        padding: 5
                    }
                },
                tooltip: {
                    enabled: false // 禁用工具提示以提高性能
                }
            },
            layout: {
                padding: {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }
            },
            animation: false
        }
    });
    
    // 設置容器樣式以確保高度匹配
    const container = canvas.parentNode;
    if (container) {
        container.style.height = targetHeight + 'px';
    }
}

// 相應地修改PSD圖的繪製函數
function drawPSD(psdData, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600;
    const targetHeight = 200; // 與其他圖一致的高度
    canvas.width = parentWidth;
    canvas.height = targetHeight;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 創建數據點
    const dataPoints = [];
    const maxFreq = 5000; // 最大顯示頻率 (Hz)
    
    for (let i = 0; i < psdData.frequencies.length; i++) {
        if (psdData.frequencies[i] <= maxFreq) {
            dataPoints.push({
                x: psdData.frequencies[i],
                y: 10 * Math.log10(psdData.psd[i] + 1e-10) // 轉換為dB，避免log(0)
            });
        }
    }
    
    // 使用Chart.js創建PSD圖
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: label,
                data: dataPoints,
                borderColor: 'rgba(153, 102, 255, 1)',
                borderWidth: 1,
                pointRadius: 0,
                fill: false
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // 不維持寬高比，允許完全自定義高度
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '頻率 (Hz)'
                    },
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                },
                y: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: 'PSD (dB/Hz)'
                    },
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        boxWidth: 15,
                        padding: 5
                    }
                },
                tooltip: {
                    enabled: false // 禁用工具提示以提高性能
                }
            },
            layout: {
                padding: {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }
            },
            animation: false
        }
    });
    
    // 設置容器樣式以確保高度匹配
    const container = canvas.parentNode;
    if (container) {
        container.style.height = targetHeight + 'px';
    }
}

// AI分析頻率數據
async function performAIAnalysis() {
    const aiContentContainer = document.getElementById('aiAnalysisContent');
    
    // 檢查是否有頻率數據可以分析
    if (!fftData2 || !psdData2) {
        aiContentContainer.innerHTML = '<p>沒有足夠的數據可分析。</p>';
        return;
    }
    
    // 顯示載入狀態
    aiContentContainer.innerHTML = `
        <div class="ai-loading">
            <div class="spinner"></div>
            <p>AI正在分析數據，請稍候...</p>
        </div>
    `;
    
    try {
        // 整合FFT和PSD進行分析
        console.log("整合FFT和PSD進行分析");
        const resultFrequencies = analyzeFFTAndPSD(fftData1, fftData2, psdData1, psdData2);
        
        // 準備AI分析所需的提示文本
        const promptText = prepareAIPrompt(resultFrequencies, fftData1, fftData2, psdData1, psdData2);
        
        // 構建請求數據
        const requestData = {
            contents: [{
                parts: [{
                    text: promptText
                }]
            }]
        };
        
        // 發送請求到Gemini API
        console.log("發送請求到Gemini API");
        const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDov2Ya3CxuExXJ1sQHnJjgZ0cvxCvIKTI", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(requestData)
        });
        
        const data = await response.json();
        
        // 處理響應
        if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0].text) {
            const analysisText = data.candidates[0].content.parts[0].text;
            
            // 格式化AI回復，轉換為HTML表格
            const formattedAnalysis = formatTableResponse(analysisText);
            
            // 顯示結果
            aiContentContainer.innerHTML = formattedAnalysis;
        } else {
            throw new Error("無法獲取AI結果");
        }
    } catch (error) {
        console.error("AI分析過程中發生錯誤:", error);
        aiContentContainer.innerHTML = `
            <p>分析過程中發生錯誤: ${error.message}</p>
            <p>請稍後再試</p>
        `;
    }
}

// FFT和PSD結合分析函數
function analyzeFFTAndPSD(fftData1, fftData2, psdData1, psdData2) {
    // 結果數組
    const results = [];
    
    // 1. 先從FFT中找出主要峰值
    const fftPeaks = findSignificantPeaks(fftData2, 20); // 找出20個顯著峰值
    
    // 2. 使用PSD來驗證這些峰值是否真實
    for (const peak of fftPeaks) {
        // 在PSD數據中尋找對應頻率
        const psdValue = findPSDValueAtFrequency(psdData2, peak.frequency);
        const normalizedPSDValue = normalizePSDValue(psdData2, psdValue);
        
        // 計算FFT峰值的顯著性
        const fftSignificance = calculatePeakSignificance(fftData2, peak.index);
        
        // 如果PSD在此頻率點也顯示能量集中，則認為此峰值可信
        const psdConfirmed = isPSDConfirmed(psdData2, peak.frequency);
        
        // 如果有第一個音頻數據，計算頻率增強率
        let enhancementRatio = 1;
        let isEnhanced = false;
        
        if (fftData1) {
            const result = compareWithFirstFile(fftData1, peak.frequency, peak.magnitude);
            enhancementRatio = result.ratio;
            isEnhanced = result.isEnhanced;
        }
        
        // 計算可信度
        const credibility = calculateCredibility(
            fftSignificance,
            normalizedPSDValue,
            psdConfirmed,
            enhancementRatio,
            isEnhanced
        );
        
        // 如果可信度足夠高，添加到結果
        if (credibility > 30) { // 可信度閾值
            results.push({
                frequency: peak.frequency,
                credibility: credibility,
                fftMagnitude: peak.magnitude,
                psdValue: psdValue,
                psdConfirmed: psdConfirmed,
                enhancementRatio: fftData1 ? enhancementRatio : null,
                isNew: fftData1 ? (enhancementRatio > 10) : null
            });
        }
    }
    
    // 合併接近的頻率（相差5%內）
    const mergedResults = mergeCloseFrequencies(results);
    
    // 按可信度排序（從高到低）
    mergedResults.sort((a, b) => b.credibility - a.credibility);
    
    // 返回前5個結果
    return mergedResults.slice(0, 5);
}

// 查找顯著峰值
function findSignificantPeaks(fftData, maxPeaks) {
    const peaks = [];
    const minPeakDistance = 5; // 峰值最小間距(Hz)
    
    // 尋找局部峰值
    for (let i = 2; i < fftData.frequencies.length - 2; i++) {
        const freq = fftData.frequencies[i];
        const mag = fftData.magnitudes[i];
        
        // 跳過低頻噪音（低於50Hz）和高頻噪音（高於5000Hz）
        if (freq < 50 || freq > 5000) continue;
        
        // 跳過振幅太小的值
        if (mag < 0.001) continue;
        
        // 檢查是否是局部峰值 (比左右兩側高)
        if (mag > fftData.magnitudes[i-2] && 
            mag > fftData.magnitudes[i-1] && 
            mag > fftData.magnitudes[i+1] && 
            mag > fftData.magnitudes[i+2]) {
            
            // 檢查是否與已有峰值太接近
            let tooClose = false;
            for (const peak of peaks) {
                if (Math.abs(peak.frequency - freq) < minPeakDistance) {
                    tooClose = true;
                    // 如果新峰值更強，替換舊峰值
                    if (mag > peak.magnitude) {
                        peak.frequency = freq;
                        peak.magnitude = mag;
                        peak.index = i;
                    }
                    break;
                }
            }
            
            // 如果不太接近現有峰值，添加新峰值
            if (!tooClose) {
                peaks.push({
                    frequency: freq,
                    magnitude: mag,
                    index: i
                });
            }
        }
    }
    
    // 按振幅排序
    peaks.sort((a, b) => b.magnitude - a.magnitude);
    
    // 返回前N個峰值
    return peaks.slice(0, maxPeaks);
}

// 在PSD數據中尋找特定頻率的值
function findPSDValueAtFrequency(psdData, targetFreq) {
    let closestIndex = 0;
    let minDiff = Infinity;
    
    // 尋找最接近的頻率點
    for (let i = 0; i < psdData.frequencies.length; i++) {
        const diff = Math.abs(psdData.frequencies[i] - targetFreq);
        if (diff < minDiff) {
            minDiff = diff;
            closestIndex = i;
        }
    }
    
    return psdData.psd[closestIndex];
}

// 歸一化PSD值
function normalizePSDValue(psdData, value) {
    // 找出最大PSD值
    const maxPSD = Math.max(...psdData.psd);
    
    // 返回歸一化值（0-100）
    return value / maxPSD * 100;
}

// 計算峰值顯著性（相對於周圍的高度）
function calculatePeakSignificance(fftData, peakIndex) {
    const peakMag = fftData.magnitudes[peakIndex];
    const searchRange = 10; // 搜索範圍
    
    // 計算周圍區域平均振幅
    let sum = 0;
    let count = 0;
    
    for (let i = Math.max(0, peakIndex - searchRange); i <= Math.min(fftData.magnitudes.length - 1, peakIndex + searchRange); i++) {
        if (Math.abs(i - peakIndex) > 2) { // 排除峰值點及其緊鄰點
            sum += fftData.magnitudes[i];
            count++;
        }
    }
    
    const avgMag = count > 0 ? sum / count : 0;
    
    // 峰值與周圍區域平均振幅的比率
    return avgMag > 0 ? peakMag / avgMag : 1;
}

// 檢查PSD是否確認此頻率點有能量集中
function isPSDConfirmed(psdData, targetFreq) {
    // 找出最接近的頻率點
    let closestIndex = 0;
    let minDiff = Infinity;
    
    for (let i = 0; i < psdData.frequencies.length; i++) {
        const diff = Math.abs(psdData.frequencies[i] - targetFreq);
        if (diff < minDiff) {
            minDiff = diff;
            closestIndex = i;
        }
    }
    
    // 檢查是否是PSD局部峰值
    if (closestIndex > 1 && closestIndex < psdData.psd.length - 2) {
        return (psdData.psd[closestIndex] > psdData.psd[closestIndex-2] &&
                psdData.psd[closestIndex] > psdData.psd[closestIndex-1] && 
                psdData.psd[closestIndex] > psdData.psd[closestIndex+1] &&
                psdData.psd[closestIndex] > psdData.psd[closestIndex+2]);
    }
    
    return false;
}

// 與第一個音頻文件對比
function compareWithFirstFile(fftData1, targetFreq, magnitude2) {
    const freqTolerance = targetFreq * 0.03; // 頻率匹配容許3%誤差
    
    // 在第一個音頻中尋找對應頻率
    let magnitude1 = 0;
    let found = false;
    
    for (let i = 0; i < fftData1.frequencies.length; i++) {
        if (Math.abs(fftData1.frequencies[i] - targetFreq) <= freqTolerance) {
            magnitude1 = fftData1.magnitudes[i];
            found = true;
            break;
        }
    }
    
    // 計算振幅比例
    const ratio = found && magnitude1 > 0.000001 ? magnitude2 / magnitude1 : 10;
    
    // 判斷是否顯著增強（比率大於1.5倍）
    const isEnhanced = ratio > 1.5;
    
    return { ratio, isEnhanced, magnitude1 };
}

// 計算可信度分數
function calculateCredibility(fftSignificance, normalizedPSD, psdConfirmed, enhancementRatio, isEnhanced) {
    // 初始化各個分量的分數
    let fftScore = 0;       // FFT峰值評分
    let psdScore = 0;       // PSD確認評分
    let enhancementScore = 0; // 頻率增強評分
    
    // 1. FFT峰值顯著性評分 (最高5分)
    // fftSignificance是峰值與周圍振幅的比例
    if (fftSignificance < 1.5) {
        fftScore = 1; // 微弱峰值
    } else if (fftSignificance < 2.5) {
        fftScore = 2; // 弱峰值
    } else if (fftSignificance < 4) {
        fftScore = 3; // 中等峰值
    } else if (fftSignificance < 6) {
        fftScore = 4; // 強峰值
    } else {
        fftScore = 5; // 非常顯著的峰值
    }
    
    // 2. PSD確認評分 (最高3分)
    if (psdConfirmed) {
        psdScore = 3; // PSD完全確認
    } else if (normalizedPSD > 50) {
        psdScore = 2; // PSD有較強能量
    } else if (normalizedPSD > 20) {
        psdScore = 1; // PSD有部分能量
    }
    
    // 3. 頻率增強評分 (最高5分，僅在有兩個音檔時適用)
    if (enhancementRatio !== null) {
        if (!isEnhanced) {
            enhancementScore = 0; // 未增強
        } else if (enhancementRatio < 2) {
            enhancementScore = 1; // 輕微增強
        } else if (enhancementRatio < 3) {
            enhancementScore = 2; // 明顯增強
        } else if (enhancementRatio < 5) {
            enhancementScore = 3; // 顯著增強
        } else if (enhancementRatio < 8) {
            enhancementScore = 4; // 強烈增強
        } else {
            enhancementScore = 5; // 極度增強或新頻率
        }
    } else {
        // 如果沒有比較數據，則對PSD和FFT評分給予更高權重
        fftScore = Math.min(5, Math.ceil(fftScore * 1.3));
        psdScore = Math.min(3, Math.ceil(psdScore * 1.3));
    }
    
    // 計算總分
    const totalScore = fftScore + psdScore + enhancementScore;
    const maxScore = enhancementRatio !== null ? 13 : 8;
    
    // 計算可信度百分比
    const credibility = Math.min(100, Math.round(totalScore / maxScore * 100));
    
    // 直接返回可信度百分比
    return credibility;
}

// 合併接近的頻率
function mergeCloseFrequencies(results) {
    const merged = [];
    const threshold = 0.05; // 5%閾值
    
    for (const result of results) {
        let foundGroup = false;
        
        for (const group of merged) {
            // 檢查是否在閾值範圍內
            if (Math.abs(group.frequency - result.frequency) / group.frequency < threshold) {
                // 如果新結果可信度更高，更新組信息
                if (result.credibility > group.credibility) {
                    group.frequency = result.frequency;
                    group.fftMagnitude = result.fftMagnitude;
                    group.psdValue = result.psdValue;
                    group.psdConfirmed = result.psdConfirmed;
                    group.enhancementRatio = result.enhancementRatio;
                    group.isNew = result.isNew;
                }
                
                // 取平均可信度，略微提高
                group.credibility = Math.min(100, Math.round((group.credibility + result.credibility) / 2 * 1.05));
                group.count = (group.count || 1) + 1;
                foundGroup = true;
                break;
            }
        }
        
        // 如果不能合併到現有組，創建新組
        if (!foundGroup) {
            merged.push({...result, count: 1});
        }
    }
    
    return merged;
}

// 修改 prepareAIPrompt 函數，移除星級評分並改用百分比
function prepareAIPrompt(resultFrequencies, fftData1, fftData2, psdData1, psdData2) {
    // 基礎提示詞
    let prompt = `你是一位物理分析專家，特別擅長振動與自然頻率分析。以下是我對物體的振動頻率分析，請幫我解讀分析結果，並用繁體中文撰寫。

【重要】我需要你使用表格格式呈現結果，表格應包含以下列：頻率(Hz)、可信度(%)、說明。說明應該解釋為何該頻率可能是物體的自然頻率。表格內容請依照可信度百分比由高至低排序。

分析方法說明：
我使用了音頻頻譜分析技術，通過比較敲擊桌面與敲擊桌面上物體的聲音差異，識別物體的自然頻率。分析流程如下：
1. 先錄製或上傳兩個音頻：純桌面敲擊聲音和物體放在桌面上敲擊的聲音
2. 使用快速傅立葉變換(FFT)找出頻譜中的峰值頻率，這些可能是自然頻率
3. 用功率譜密度(PSD)分析來確認這些頻率是否確實能量集中
4. 比較兩個音頻中同一頻率的強度，如果某頻率在放置物體後明顯增強，則很可能是物體的自然頻率`;

    // 添加有關可信度評分的說明
    prompt += `\n\n可信度百分比評分系統說明：
0-20%: 可能是噪聲，幾乎沒有證據支持這是自然頻率
21-40%: 有弱證據支持，但可能是偶然性峰值
41-60%: 中等可信度，有一定證據但不夠強烈
61-80%: 高可信度，多項證據支持這是自然頻率
81-100%: 極高可信度，幾乎可以確定是物體的自然頻率`;

    // 添加結果數據
    prompt += `\n\n已識別的可能自然頻率：\n${JSON.stringify(resultFrequencies, null, 2)}\n\n`;
    
    // 添加分析請求
    prompt += `請根據以上數據分析：
1. 用純數字百分比表示可信度 (例如：95%)
2. 每個自然頻率提供簡短說明，包含以下信息：
   - 此頻率在FFT中表現（是否為顯著峰值）
   - 此頻率在PSD中是否得到確認
   - 此頻率相較於純桌面敲擊時是否顯著增強（如果有兩個音檔）
3. 最後提供一段淺顯易懂的分析總結，解釋：
   - 這些自然頻率代表什麼物理含義
   - 根據結果有何推論（物體可能是什麼材質、形狀等）
   - 測試結果的整體可靠性評估
   - 簡單說明可信度百分比的計算方式

回應格式：
1. 繁體中文表格，包含頻率、可信度(%)和說明，請依可信度百分比由高至低排序
2. 淺顯易懂的分析總結 (包含可信度計算方式的簡要說明)`;

    return prompt;
}

// 修改 formatTableResponse 函數以正確顯示百分比並依照可信度排序
function formatTableResponse(text) {
    // 提取表格部分
    const tableMatch = text.match(/\|\s*頻率[\s\S]*?(?=\n\n|$)/);
    const summaryMatch = text.match(/(?:分析總結|總結分析|總結).+(?:\n.+)*/g);
    
    let htmlContent = `<div class="ai-analysis-title">物體自然頻率分析結果</div>`;
    
    // 處理表格部分
    if (tableMatch) {
        const tableContent = tableMatch[0];
        
        // 轉換Markdown表格為HTML表格
        const rows = tableContent.split('\n').filter(row => row.trim().length > 0);
        
        let htmlTable = `
            <table class="natural-freq-table" style="width:100%; border-collapse:collapse; margin:20px 0;">
                <thead style="background-color:#f2f2f2;">
        `;
        
        // 處理表頭
        if (rows.length > 0) {
            const headerCells = rows[0].split('|').filter(cell => cell.trim().length > 0);
            htmlTable += '<tr>';
            headerCells.forEach(cell => {
                htmlTable += `<th style="padding:8px; border:1px solid #ddd; text-align:center;">${cell.trim()}</th>`;
            });
            htmlTable += '</tr></thead><tbody>';
            
            // 跳過分隔符行和表頭，處理數據行
            const dataRows = rows.slice(2);
            const maxRows = Math.min(5, dataRows.length);
            
            for (let i = 0; i < maxRows; i++) {
                const cells = dataRows[i].split('|').filter(cell => cell.trim().length > 0);
                if (cells.length < 3) continue; // 跳過不完整的行
                
                htmlTable += '<tr>';
                
                cells.forEach((cell, index) => {
                    // 對頻率列應用特殊樣式
                    if (index === 0) {
                        htmlTable += `<td style="padding:8px; border:1px solid #ddd; font-weight:bold; color:#9b59b6; text-align:center;">${cell.trim()}</td>`;
                    } 
                    // 對可信度列應用特殊樣式（百分比）
                    else if (index === 1) {
                        // 用進度條樣式顯示百分比
                        const percentValue = parseInt(cell.trim().replace(/%/g, ''));
                        const barWidth = Math.max(5, Math.min(100, percentValue)); // 確保進度條至少有5%寬度並且不超過100%
                        
                        htmlTable += `
                            <td style="padding:8px; border:1px solid #ddd; text-align:center;">
                                <div style="position:relative; width:100%; height:20px; background-color:#f0f0f0; border-radius:10px; overflow:hidden;">
                                    <div style="position:absolute; width:${barWidth}%; height:100%; background-color:#9b59b6; border-radius:10px;"></div>
                                    <div style="position:relative; text-align:center; color:#000; line-height:20px; font-weight:bold;">${cell.trim()}</div>
                                </div>
                            </td>`;
                    }
                    // 對說明列應用普通樣式
                    else {
                        htmlTable += `<td style="padding:8px; border:1px solid #ddd;">${cell.trim()}</td>`;
                    }
                });
                
                htmlTable += '</tr>';
            }
            
            htmlTable += '</tbody></table>';
            htmlContent += htmlTable;
        }
    }
    
    // 添加分析總結
    if (summaryMatch && summaryMatch.length > 0) {
        const summaryText = summaryMatch.join(' ').replace(/分析總結[：:]\s*/i, '');
        
        htmlContent += `
            <div class="ai-suggestion">
                <p><strong>分析總結：</strong>${summaryText}</p>
            </div>
        `;
    } else {
        // 如果沒有找到總結，使用整個文本的最後部分
        const paragraphs = text.split('\n\n');
        if (paragraphs.length > 0) {
            const lastParagraph = paragraphs[paragraphs.length - 1];
            if (lastParagraph.length > 20) {
                htmlContent += `
                    <div class="ai-suggestion">
                        <p><strong>分析總結：</strong>${lastParagraph}</p>
                    </div>
                `;
            }
        }
    }
    
    return htmlContent;
}

// 輔助函數：找出數據中的前N個峰值
function findTopPeaks(data, n, valueType = 'magnitudes') {
    // 創建索引數組
    const indices = Array.from({ length: data[valueType].length }, (_, i) => i);
    
    // 按振幅排序
    indices.sort((a, b) => data[valueType][b] - data[valueType][a]);
    
    // 提取前N個峰值
    const topPeaks = indices.slice(0, n).map(i => ({
        frequency: data.frequencies[i],
        value: data[valueType][i],
        magnitude: valueType === 'magnitudes' ? data[valueType][i] : undefined
    }));
    
    // 按頻率排序
    topPeaks.sort((a, b) => a.frequency - b.frequency);
    
    return topPeaks;
}
</script>

</body>
</html>