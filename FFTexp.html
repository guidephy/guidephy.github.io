<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自然頻率分析器</title>
<style>
    body {
    font-family: 'Microsoft JhengHei', Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f5f5f5;
}

h1, h2, h3 {
    color: #2c3e50;
}

.container {
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.file-upload {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-bottom: 20px;
}

.upload-box {
    flex: 1;
    min-width: 300px;
    border: 2px dashed #3498db;
    border-radius: 5px;
    padding: 20px;
    text-align: center;
    transition: all 0.3s;
}

.upload-box:hover {
    border-color: #2980b9;
    background-color: #f0f7fc;
}

input[type="file"] {
    display: none;
}

.upload-label {
    display: block;
    cursor: pointer;
    font-weight: bold;
    color: #3498db;
}

button {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    margin-right: 10px;
    margin-bottom: 10px;
}

button:hover {
    background-color: #2980b9;
}

button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
}

.visualizations {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
}

.viz-container {
    flex: 1;
    min-width: 400px;
    margin-bottom: 20px;
}

@media (max-width: 768px) {
    .viz-container {
        min-width: 100%;
    }
}

.result-section {
    margin-top: 30px;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
}

table, th, td {
    border: 1px solid #ddd;
}

th, td {
    padding: 10px;
    text-align: left;
}

th {
    background-color: #f2f2f2;
}

.loading {
    display: none;
    text-align: center;
    margin: 20px 0;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 2s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.file-name {
    margin-top: 10px;
    font-style: italic;
    word-break: break-all;
}

.canvas-container {
    overflow-x: auto;
    margin-top: 10px;
    position: relative;
}

/* 錄音相關樣式 */
.record-option {
    margin-top: 10px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.record-button-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
}

.record-button {
    flex: 1;
    min-width: 80px;
    padding: 12px;
}

.record-button.start {
    background-color: #e74c3c;
}

.record-button.start:hover {
    background-color: #c0392b;
}

.record-button.stop {
    background-color: #7f8c8d;
}

.record-button.stop:hover {
    background-color: #636e72;
}

.record-button.use {
    background-color: #27ae60;
}

.record-button.use:hover {
    background-color: #2ecc71;
}

.record-info {
    margin-top: 10px;
    font-size: 14px;
    color: #666;
}

.record-timer {
    font-weight: bold;
}

.record-visualization {
    width: 100%;
    height: 60px;
    background-color: #000;
    border-radius: 5px;
    margin-top: 10px;
    position: relative;
    overflow: hidden;
}

/* 波形預覽與選擇區域樣式 */
.preview-container {
    margin-top: 20px;
    padding: 10px;
    border: 1px solid #e0e0e0;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.preview-title {
    font-weight: bold;
    margin-bottom: 10px;
}

.waveform-preview {
    position: relative;
    width: 100%;
    height: 150px;
    margin-bottom: 20px;
    border: 1px solid #ddd;
    background-color: #fff;
}

.selection-overlay {
    position: absolute;
    top: 0;
    background-color: rgba(52, 152, 219, 0.3);
    border: 1px solid rgba(52, 152, 219, 0.7);
    height: 100%;
    pointer-events: none;
}

.slider-container {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    margin: 10px 0;
}

@media (max-width: 768px) {
    .slider-container {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .slider-container .slider {
        width: 100%;
        margin: 5px 0;
    }
    
    .slider-container .time-display {
        margin: 5px 0;
    }
}

.time-display {
    margin: 0 10px;
    min-width: 120px;
    text-align: center;
}

.slider {
    flex-grow: 1;
    margin: 0 10px;
}

input[type="range"] {
    width: 100%;
}

.button-container {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.tab-container {
    margin-bottom: 15px;
}

.tab-button {
    border: none;
    background-color: #f2f2f2;
    padding: 10px 20px;
    border-radius: 5px 5px 0 0;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    margin-right: 5px;
}

.tab-button.active {
    background-color: #3498db;
    color: white;
}

.tab-content {
    display: none;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 0 5px 5px 5px;
}

.tab-content.active {
    display: block;
}

.debug-info {
    font-size: 12px;
    color: #666;
    margin-top: 5px;
    font-family: monospace;
}

.analyze-button-container {
    margin-top: 20px;
    text-align: center;
}

.analyze-button-container button {
    padding: 12px 30px;
    font-size: 18px;
    background-color: #27ae60;
}

.analyze-button-container button:hover {
    background-color: #2ecc71;
}

.analyze-button-container button:disabled {
    background-color: #95a5a6;
}

.status-message {
    color: #666;
    font-style: italic;
    margin-top: 5px;
}

.mobile-responsive {
    overflow-x: auto;
}

@media (max-width: 768px) {
    h1 {
        font-size: 24px;
    }
    
    h2 {
        font-size: 20px;
    }
    
    h3 {
        font-size: 18px;
    }
    
    .container {
        padding: 15px;
    }
    
    button {
        padding: 8px 16px;
        font-size: 14px;
    }
    
    .analyze-button-container button {
        padding: 10px 20px;
        font-size: 16px;
    }
}

.tab-indicator {
    background-color: #2ecc71;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    font-size: 12px;
    margin-left: 5px;
}

/* 新增的自然頻率表樣式優化 */
.frequency-table {
    border-collapse: collapse;
    width: 100%;
    margin-top: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.frequency-table th {
    background-color: #34495e;
    color: white;
    padding: 12px;
    text-align: center;
}

.frequency-table td {
    padding: 10px;
    text-align: center;
    vertical-align: middle;
}

.frequency-table tr:nth-child(even) {
    background-color: #f9f9f9;
}

.frequency-table tr:hover {
    background-color: #f0f7fc;
}

.confidence-very-high {
    background-color: #d4edda !important;
    font-weight: bold;
    border-left: 4px solid #28a745;
}

.confidence-high {
    background-color: #e8f4f8 !important;
    font-weight: bold;
    border-left: 4px solid #17a2b8;
}

.confidence-medium {
    background-color: #fff3cd !important;
    border-left: 4px solid #ffc107;
}

.confidence-low {
    background-color: #f8f9fa !important;
    color: #6c757d;
}

.freq-value {
    font-size: 1.1em;
    color: #2c3e50;
}

.amplitude-ratio {
    font-family: monospace;
    font-size: 0.95em;
}

.confidence-badge {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.85em;
    font-weight: bold;
}

.badge-very-high {
    background-color: #28a745;
    color: white;
}

.badge-high {
    background-color: #17a2b8;
    color: white;
}

.badge-medium {
    background-color: #ffc107;
    color: #343a40;
}

.badge-low {
    background-color: #e9ecef;
    color: #495057;
}

.frequency-summary {
    background-color: #f8f9fc;
    border-left: 4px solid #4e73df;
    padding: 15px;
    border-radius: 4px;
    margin-bottom: 15px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.primary-freq-container {
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
    margin-top: 10px;
    gap: 10px;
}

.primary-freq-card {
    flex: 1;
    min-width: 150px;
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    text-align: center;
    border-top: 3px solid #4e73df;
}

.primary-freq-value {
    font-size: 1.8em;
    font-weight: bold;
    color: #2c3e50;
    margin: 10px 0;
}

.freq-unit {
    font-size: 0.7em;
    color: #6c757d;
}

.freq-harmonic {
    font-size: 0.9em;
    color: #6c757d;
    margin-top: 8px;
}

.bar-indicator {
    height: 4px;
    width: 100%;
    background-color: #e9ecef;
    border-radius: 2px;
    margin-top: 8px;
}

.bar-indicator-fill {
    height: 100%;
    border-radius: 2px;
    background-color: #4e73df;
}
</style>
</head>
<body>
    <h1>物體自然頻率分析器</h1>
    
    <div class="container">
        <h2>實驗原理說明</h2>
        <p>此工具用於分析物體的自然頻率。使用方法：</p>
        <ol>
            <li>上傳第一個音檔：純桌面被敲擊的聲音（也可直接錄製）</li>
            <li>上傳第二個音檔：待測物體放在桌面上被敲擊的聲音（也可直接錄製）</li>
            <li>選擇每個音檔中要分析的波形區段</li>
            <li>點擊「分析選定範圍」按鈕進行處理</li>
        </ol>
        <p>系統會顯示兩個音檔的波形圖、頻譜分析（FFT）和功率譜密度（PSD），並識別第二個音檔中獨有的頻率成分，這些頻率即為待測物體的自然頻率。</p>
    </div>
    
    <div class="container">
        <h2>音頻錄製或上傳</h2>
        
        <div class="tab-container">
            <button class="tab-button active" data-target="upload1">上傳檔案</button>
            <button class="tab-button" data-target="record1">錄製音頻</button>
        </div>
        
        <div class="tab-content active" id="upload1">
            <div class="file-upload">
                <div class="upload-box">
                    <label class="upload-label" for="file1">
                        上傳第一個音檔（純桌面）
                        <br><br>
                        <i class="fas fa-cloud-upload-alt" style="font-size: 24px;"></i>
                        <br><br>
                        點擊或拖放文件到此處
                    </label>
                    <input type="file" id="file1" accept="audio/*">
                    <p class="file-name" id="fileName1"></p>
                </div>
                
                <div class="upload-box">
                    <label class="upload-label" for="file2">
                        上傳第二個音檔（物體+桌面）
                        <br><br>
                        <i class="fas fa-cloud-upload-alt" style="font-size: 24px;"></i>
                        <br><br>
                        點擊或拖放文件到此處
                    </label>
                    <input type="file" id="file2" accept="audio/*">
                    <p class="file-name" id="fileName2"></p>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="record1">
            <div class="record-option">
                <h3>錄製第一個音檔（純桌面）<span id="recordStatus1" class="status-message"></span></h3>
                <div class="record-button-container">
                    <button id="startRecord1" class="record-button start">開始錄音</button>
                    <button id="stopRecord1" class="record-button stop" disabled>停止錄音</button>
                    <button id="playRecorded1" class="record-button" disabled>播放錄音</button>
                    <button id="useRecording1" class="record-button use" disabled>使用此錄音</button>
                </div>
                <div class="record-info">
                    <p>錄音時間: <span id="recordTime1" class="record-timer">00:00</span></p>
                </div>
                <div class="record-visualization" id="recordVisual1"></div>
            </div>
            
            <div class="record-option">
                <h3>錄製第二個音檔（物體+桌面）<span id="recordStatus2" class="status-message"></span></h3>
                <div class="record-button-container">
                    <button id="startRecord2" class="record-button start">開始錄音</button>
                    <button id="stopRecord2" class="record-button stop" disabled>停止錄音</button>
                    <button id="playRecorded2" class="record-button" disabled>播放錄音</button>
                    <button id="useRecording2" class="record-button use" disabled>使用此錄音</button>
                </div>
                <div class="record-info">
                    <p>錄音時間: <span id="recordTime2" class="record-timer">00:00</span></p>
                </div>
                <div class="record-visualization" id="recordVisual2"></div>
            </div>
        </div>
    </div>
    
    <!-- 波形預覽與範圍選擇區域 -->
    <div class="container" id="previewContainer" style="display:none;">
        <h2>波形預覽與範圍選擇</h2>
        <p>請在下方波形圖上選擇要分析的時間範圍：</p>
        
        <div class="preview-container">
            <div class="preview-title">第一個音檔（純桌面）</div>
            <div class="waveform-preview">
                <canvas id="preview1"></canvas>
                <div id="selection1" class="selection-overlay"></div>
            </div>
            <div class="slider-container">
                <span>起始：</span>
                <input type="range" id="start1" min="0" max="100" value="0" class="slider">
                <span class="time-display" id="startTime1">0.00 秒</span>
                <span>結束：</span>
                <input type="range" id="end1" min="0" max="100" value="100" class="slider">
                <span class="time-display" id="endTime1">0.00 秒</span>
            </div>
            <div class="button-container">
                <button id="playSelection1">播放選擇區域</button>
                <button id="zoomSelection1">放大選擇區域</button>
                <button id="resetZoom1">重設縮放</button>
            </div>
        </div>
        
        <div class="preview-container">
            <div class="preview-title">第二個音檔（物體+桌面）</div>
            <div class="waveform-preview">
                <canvas id="preview2"></canvas>
                <div id="selection2" class="selection-overlay"></div>
            </div>
            <div class="slider-container">
                <span>起始：</span>
                <input type="range" id="start2" min="0" max="100" value="0" class="slider">
                <span class="time-display" id="startTime2">0.00 秒</span>
                <span>結束：</span>
                <input type="range" id="end2" min="0" max="100" value="100" class="slider">
                <span class="time-display" id="endTime2">0.00 秒</span>
            </div>
            <div class="button-container">
                <button id="playSelection2">播放選擇區域</button>
                <button id="zoomSelection2">放大選擇區域</button>
                <button id="resetZoom2">重設縮放</button>
            </div>
        </div>
        
        <div class="analyze-button-container">
            <button id="analyzeBtn">分析選定範圍</button>
            <div id="statusMessage" class="status-message"></div>
        </div>
        
        <div class="loading" id="loadingIndicator">
            <p>正在處理音頻數據，請稍候...</p>
            <div class="spinner"></div>
        </div>
    </div>
    
    <div class="container" id="resultsContainer" style="display:none;">
        <h2>分析結果</h2>
        
        <div class="mobile-responsive">
        <div class="visualizations">
            <div class="viz-container">
                <h3>波形圖</h3>
                <div class="canvas-container">
                    <canvas id="waveform1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="waveform2"></canvas>
                </div>
            </div>
            
            <div class="viz-container">
                <h3>FFT頻譜分析</h3>
                <div class="canvas-container">
                    <canvas id="fft1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="fft2"></canvas>
                </div>
            </div>
        </div>
        
        <div class="visualizations">
            <div class="viz-container">
                <h3>功率譜密度 (PSD)</h3>
                <div class="canvas-container">
                    <canvas id="psd1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="psd2"></canvas>
                </div>
            </div>
            
            <div class="viz-container result-section">
                <h3>物體自然頻率</h3>
                <div class="frequency-summary" id="frequencySummary">
                    <h4>主要自然頻率</h4>
                    <div class="primary-freq-container" id="primaryFreqContainer">
                        <!-- 主要頻率卡片將在這裡動態生成 -->
                    </div>
                </div>
                <p>在第二個音檔中檢測到的自然頻率組成：</p>
                <table id="frequencyTable" class="frequency-table">
                    <thead>
                        <tr>
                            <th>頻率 (Hz)</th>
                            <th>振幅比例</th>
                            <th>置信度</th>
                        </tr>
                    </thead>
                    <tbody id="frequencyTableBody">
                        <!-- 結果將在這裡動態生成 -->
                    </tbody>
                </table>
            </div>
        </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        // 全局變量
let audioContext;
let file1Data = null;
let file2Data = null;
let audioBuffer1 = null;
let audioBuffer2 = null;
let charts = {};
let audioSource1 = null;
let audioSource2 = null;

// 選擇範圍變量
let selectedRange1 = { start: 0, end: 1 };
let selectedRange2 = { start: 0, end: 1 };

// 縮放變量
let zoom1 = { start: 0, end: 1 };
let zoom2 = { start: 0, end: 1 };

// 錄音相關變量
let mediaRecorder1 = null;
let mediaRecorder2 = null;
let recordedChunks1 = [];
let recordedChunks2 = [];
let recordingStream1 = null;
let recordingStream2 = null;
let recordingStartTime1 = 0;
let recordingStartTime2 = 0;
let recordingTimer1 = null;
let recordingTimer2 = null;
let recordedBlob1 = null;
let recordedBlob2 = null;
let visualizer1 = null;
let visualizer2 = null;
let recording1Ready = false;
let recording2Ready = false;

// 初始化頁面
document.addEventListener('DOMContentLoaded', function() {
    console.log("初始化頁面");
    
    // 檢查瀏覽器是否支持Web Audio API
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
    } catch (e) {
        alert('您的瀏覽器不支持Web Audio API。請使用Chrome、Firefox、Safari或Edge的最新版本。');
    }
    
    // 檢查瀏覽器是否支持MediaRecorder API
    if (!window.MediaRecorder) {
        document.getElementById('record1').innerHTML = '<p>您的瀏覽器不支持錄音功能。請使用Chrome、Firefox、Safari或Edge的最新版本。</p>';
    }
    
    // 設置標籤頁切換
    setupTabs();
    
    // 文件上傳事件處理
    document.getElementById('file1').addEventListener('change', function(e) {
        handleFileUpload(e, 'file1', 'fileName1');
    });
    
    document.getElementById('file2').addEventListener('change', function(e) {
        handleFileUpload(e, 'file2', 'fileName2');
    });
    
    // 拖放事件
    setupDragAndDrop('file1', 'fileName1');
    setupDragAndDrop('file2', 'fileName2');
    
    // 錄音事件處理
    setupRecording(1);
    setupRecording(2);
    
    // 分析按鈕事件
    const analyzeBtn = document.getElementById('analyzeBtn');
    analyzeBtn.addEventListener('click', function() {
        console.log("分析按鈕被點擊");
        analyzeAudio();
    });
    
    // 範圍選擇事件
    setupRangeSelection(1);
    setupRangeSelection(2);
    
    // 播放選擇區域事件
    document.getElementById('playSelection1').addEventListener('click', function() {
        playSelectedAudio(1);
    });
    document.getElementById('playSelection2').addEventListener('click', function() {
        playSelectedAudio(2);
    });
    
    // 縮放事件
    document.getElementById('zoomSelection1').addEventListener('click', function() {
        zoomToSelection(1);
    });
    document.getElementById('zoomSelection2').addEventListener('click', function() {
        zoomToSelection(2);
    });
    
    // 重設縮放
    document.getElementById('resetZoom1').addEventListener('click', function() {
        resetZoom(1);
    });
    document.getElementById('resetZoom2').addEventListener('click', function() {
        resetZoom(2);
    });
    
    // 確保初始狀態下分析按鈕是禁用的
    analyzeBtn.disabled = true;
    updateStatusMessage("請上傳或錄製兩個音檔後再進行分析");
});

// 設置標籤頁切換
function setupTabs() {
    const tabButtons = document.querySelectorAll('.tab-button');
    
    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            // 取得目標標籤頁ID
            const targetId = this.getAttribute('data-target');
            
            // 移除所有標籤頁按鈕的active類
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 隱藏所有標籤頁內容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 添加當前按鈕的active類
            this.classList.add('active');
            
            // 顯示目標標籤頁內容
            document.getElementById(targetId).classList.add('active');
        });
    });
}

// 設置錄音功能
function setupRecording(fileNumber) {
    const startButton = document.getElementById(`startRecord${fileNumber}`);
    const stopButton = document.getElementById(`stopRecord${fileNumber}`);
    const playButton = document.getElementById(`playRecorded${fileNumber}`);
    const useButton = document.getElementById(`useRecording${fileNumber}`);
    const statusDisplay = document.getElementById(`recordStatus${fileNumber}`);
    const timerDisplay = document.getElementById(`recordTime${fileNumber}`);
    const visualizerContainer = document.getElementById(`recordVisual${fileNumber}`);
    
    // 開始錄音按鈕事件
    startButton.addEventListener('click', function() {
        startRecording(fileNumber);
    });
    
    // 停止錄音按鈕事件
    stopButton.addEventListener('click', function() {
        stopRecording(fileNumber);
    });
    
    // 播放錄音按鈕事件
    playButton.addEventListener('click', function() {
        playRecording(fileNumber);
    });
    
    // 使用錄音按鈕事件
    useButton.addEventListener('click', function() {
        useRecording(fileNumber);
    });
}

// 檢測支持的錄音格式
function getSupportedMimeTypes() {
    const possibleTypes = [
        'audio/webm',
        'audio/webm;codecs=opus',
        'audio/ogg',
        'audio/ogg;codecs=opus',
        'audio/mp4',
        'audio/mp4;codecs=aac',
        'audio/wav',
        'audio/wav;codecs=1'
    ];
    
    return possibleTypes.filter(type => {
        try {
            return MediaRecorder.isTypeSupported(type);
        } catch(e) {
            return false;
        }
    });
}

// 開始錄音
async function startRecording(fileNumber) {
    try {
        // 請求麥克風權限
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // 恢復AudioContext（解決移動設備上的問題）
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        // 檢測支持的格式
        const supportedMimeTypes = getSupportedMimeTypes();
        console.log("支持的錄音格式:", supportedMimeTypes);
        
        if (supportedMimeTypes.length === 0) {
            throw new Error("您的瀏覽器不支持任何可用的錄音格式");
        }
        
        // 使用第一個支持的格式
        const mimeType = supportedMimeTypes[0];
        console.log(`使用錄音格式: ${mimeType}`);
        
        // 設置錄音器
        const recorderOptions = { mimeType };
        const recorder = new MediaRecorder(stream, recorderOptions);
        
        // 存儲全局變量
        if (fileNumber === 1) {
            recordedChunks1 = [];
            recordingStream1 = stream;
            mediaRecorder1 = recorder;
            recordingStartTime1 = Date.now();
            
            // 創建可視化
            visualizer1 = createVisualizer(stream, 'recordVisual1');
            
            // 啟動計時器
            startTimer(fileNumber);
            
            // 更新狀態
            document.getElementById('recordStatus1').textContent = "正在錄音...";
            document.getElementById('startRecord1').disabled = true;
            document.getElementById('stopRecord1').disabled = false;
            document.getElementById('playRecorded1').disabled = true;
            document.getElementById('useRecording1').disabled = true;
        } else {
            recordedChunks2 = [];
            recordingStream2 = stream;
            mediaRecorder2 = recorder;
            recordingStartTime2 = Date.now();
            
            // 創建可視化
            visualizer2 = createVisualizer(stream, 'recordVisual2');
            
            // 啟動計時器
            startTimer(fileNumber);
            
            // 更新狀態
            document.getElementById('recordStatus2').textContent = "正在錄音...";
            document.getElementById('startRecord2').disabled = true;
            document.getElementById('stopRecord2').disabled = false;
            document.getElementById('playRecorded2').disabled = true;
            document.getElementById('useRecording2').disabled = true;
        }
        
        // 設置數據處理事件
        recorder.ondataavailable = function(e) {
            if (e.data.size > 0) {
                if (fileNumber === 1) {
                    recordedChunks1.push(e.data);
                } else {
                    recordedChunks2.push(e.data);
                }
            }
        };
        
        // 錄音結束事件
        recorder.onstop = function() {
            if (fileNumber === 1) {
                // 停止流和可視化
                stopMediaTracks(recordingStream1);
                if (visualizer1) {
                    visualizer1.disconnect();
                }
                
                // 停止計時器
                clearInterval(recordingTimer1);
                
                // 創建音頻Blob
                recordedBlob1 = new Blob(recordedChunks1, { type: 'audio/webm' });
                
                // 更新狀態
                document.getElementById('recordStatus1').textContent = "錄音完成";
                document.getElementById('startRecord1').disabled = false;
                document.getElementById('stopRecord1').disabled = true;
                document.getElementById('playRecorded1').disabled = false;
                document.getElementById('useRecording1').disabled = false;
                
                recording1Ready = true;
            } else {
                // 停止流和可視化
                stopMediaTracks(recordingStream2);
                if (visualizer2) {
                    visualizer2.disconnect();
                }
                
                // 停止計時器
                clearInterval(recordingTimer2);
                
                // 創建音頻Blob
                recordedBlob2 = new Blob(recordedChunks2, { type: 'audio/webm' });
                
                // 更新狀態
                document.getElementById('recordStatus2').textContent = "錄音完成";
                document.getElementById('startRecord2').disabled = false;
                document.getElementById('stopRecord2').disabled = true;
                document.getElementById('playRecorded2').disabled = false;
                document.getElementById('useRecording2').disabled = false;
                
                recording2Ready = true;
            }
        };
        
        // 開始錄音，每100毫秒獲取一次數據
        recorder.start(100);
        
    } catch (error) {
        console.error(`錄音時發生錯誤 (音檔${fileNumber}):`, error);
        
        let errorMessage = "";
        if (error.name === "NotAllowedError") {
            errorMessage = "請允許麥克風權限以進行錄音";
        } else if (error.message.includes("mimeType") || error.name === "NotSupportedError") {
            errorMessage = "瀏覽器不支持錄音格式，請嘗試使用Chrome或Firefox";
        } else {
            errorMessage = `錄音錯誤: ${error.message}`;
        }
        
        alert(`無法開始錄音: ${errorMessage}`);
        console.log("錄音錯誤詳情:", error);
        
        // 重設按鈕狀態
        if (fileNumber === 1) {
            document.getElementById('startRecord1').disabled = false;
            document.getElementById('stopRecord1').disabled = true;
            document.getElementById('recordStatus1').textContent = "錄音失敗: " + errorMessage;
        } else {
            document.getElementById('startRecord2').disabled = false;
            document.getElementById('stopRecord2').disabled = true;
            document.getElementById('recordStatus2').textContent = "錄音失敗: " + errorMessage;
        }
    }
}

// 停止錄音
function stopRecording(fileNumber) {
    if (fileNumber === 1 && mediaRecorder1 && mediaRecorder1.state !== 'inactive') {
        mediaRecorder1.stop();
    } else if (fileNumber === 2 && mediaRecorder2 && mediaRecorder2.state !== 'inactive') {
        mediaRecorder2.stop();
    }
}

// 播放錄音
function playRecording(fileNumber) {
    const blob = fileNumber === 1 ? recordedBlob1 : recordedBlob2;
    
    if (!blob) {
        console.error(`沒有可用的錄音 (音檔${fileNumber})`);
        return;
    }
    
    // 創建音頻元素播放
    const audioURL = URL.createObjectURL(blob);
    const audio = new Audio(audioURL);
    audio.play();
    
    // 播放完成後釋放URL
    audio.onended = function() {
        URL.revokeObjectURL(audioURL);
    };
}

// 使用錄音作為音頻源
async function useRecording(fileNumber) {
    const blob = fileNumber === 1 ? recordedBlob1 : recordedBlob2;
    
    if (!blob) {
        console.error(`沒有可用的錄音 (音檔${fileNumber})`);
        return;
    }
    
    try {
        // 將Blob轉換為ArrayBuffer
        const arrayBuffer = await blob.arrayBuffer();
        
        // 處理錄音數據
        if (fileNumber === 1) {
            file1Data = arrayBuffer;
            document.getElementById('fileName1').textContent = "已錄製的音頻";
        } else {
            file2Data = arrayBuffer;
            document.getElementById('fileName2').textContent = "已錄製的音頻";
        }
        
        // 解碼並預覽
        await decodeAndPreview(arrayBuffer, fileNumber);
        
        // 更新狀態
        if (fileNumber === 1) {
            document.getElementById('recordStatus1').textContent = "已使用此錄音";
            
            // 在標籤頁按鈕上添加指示器
            const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
            if (tabButton) {
                if (!tabButton.querySelector('.tab-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'tab-indicator';
                    indicator.textContent = '✓';
                    tabButton.appendChild(indicator);
                }
            }
        } else {
            document.getElementById('recordStatus2').textContent = "已使用此錄音";
        }
        
    } catch (error) {
        console.error(`處理錄音時發生錯誤 (音檔${fileNumber}):`, error);
        alert(`無法處理錄音。錯誤: ${error.message}`);
    }
}

// 啟動錄音計時器
function startTimer(fileNumber) {
    const timerDisplay = document.getElementById(`recordTime${fileNumber}`);
    const startTime = Date.now();
    
    if (fileNumber === 1) {
        // 清除舊計時器
        if (recordingTimer1) {
            clearInterval(recordingTimer1);
        }
        
        // 設置新計時器
        recordingTimer1 = setInterval(function() {
            const elapsedTime = Date.now() - startTime;
            const seconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }, 1000);
    } else {
        // 清除舊計時器
        if (recordingTimer2) {
            clearInterval(recordingTimer2);
        }
        
        // 設置新計時器
        recordingTimer2 = setInterval(function() {
            const elapsedTime = Date.now() - startTime;
            const seconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }, 1000);
    }
}

// 停止媒體軌道
function stopMediaTracks(stream) {
    if (stream) {
        stream.getTracks().forEach(track => {
            track.stop();
        });
    }
}

// 創建音頻可視化
function createVisualizer(stream, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return null;
    
    try {
        // 清空容器
        container.innerHTML = '';
        
        // 創建畫布
        const canvas = document.createElement('canvas');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // 創建音頻分析器
        const audioSource = audioContext.createMediaStreamSource(stream);
        const analyzer = audioContext.createAnalyser();
        analyzer.fftSize = 256;
        
        audioSource.connect(analyzer);
        
        const bufferLength = analyzer.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        // 動畫函數
        function draw() {
            // 獲取畫布尺寸（可能已更改）
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            requestAnimationFrame(draw);
            
            analyzer.getByteFrequencyData(dataArray);
            
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * canvas.height;
                
                // 根據頻率設置顏色漸變
                const r = 50 + (i * 2);
                const g = 50 + (i * 1);
                const b = 200;
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }
        
        draw();
        
        return audioSource;
    } catch (error) {
        console.error('創建可視化時發生錯誤:', error);
        return null;
    }
}

// 更新狀態消息
function updateStatusMessage(message) {
    const statusElement = document.getElementById('statusMessage');
    if (statusElement) {
        statusElement.textContent = message;
    }
}

// 處理文件上傳
function handleFileUpload(event, fileId, fileNameId) {
    const file = event.target.files[0];
    if (!file) return;
    
    document.getElementById(fileNameId).textContent = file.name;
    updateStatusMessage(`正在載入 ${file.name}...`);
    
    const reader = new FileReader();
    reader.onload = function(e) {
        if (fileId === 'file1') {
            file1Data = e.target.result;
            decodeAndPreview(file1Data, 1);
            
            // 在標籤頁按鈕上添加指示器
            const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
            if (tabButton) {
                if (!tabButton.querySelector('.tab-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'tab-indicator';
                    indicator.textContent = '✓';
                    tabButton.appendChild(indicator);
                }
            }
        } else {
            file2Data = e.target.result;
            decodeAndPreview(file2Data, 2);
        }
    };
    reader.onerror = function() {
        updateStatusMessage(`讀取文件 ${file.name} 時出錯`);
    };
    reader.readAsArrayBuffer(file);
}

// 設置拖放功能
function setupDragAndDrop(fileId, fileNameId) {
    const dropZone = document.querySelector(`label[for="${fileId}"]`).parentNode;
    
    dropZone.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '#e3f2fd';
    });
    
    dropZone.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '';
    });
    
    dropZone.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '';
        
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('audio/')) {
            document.getElementById(fileId).files = e.dataTransfer.files;
            document.getElementById(fileNameId).textContent = file.name;
            updateStatusMessage(`正在載入 ${file.name}...`);
            
            const reader = new FileReader();
            reader.onload = function(event) {
                if (fileId === 'file1') {
                    file1Data = event.target.result;
                    decodeAndPreview(file1Data, 1);
                    
                    // 在標籤頁按鈕上添加指示器
                    const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
                    if (tabButton) {
                        if (!tabButton.querySelector('.tab-indicator')) {
                            const indicator = document.createElement('span');
                            indicator.className = 'tab-indicator';
                            indicator.textContent = '✓';
                            tabButton.appendChild(indicator);
                        }
                    }
                } else {
                    file2Data = event.target.result;
                    decodeAndPreview(file2Data, 2);
                }
            };
            reader.onerror = function() {
                updateStatusMessage(`讀取文件 ${file.name} 時出錯`);
            };
            reader.readAsArrayBuffer(file);
        }
    });
}

// 解碼音頻並預覽
async function decodeAndPreview(audioData, fileNumber) {
    try {
        // 顯示預覽容器 (在嘗試解碼前就顯示)
        document.getElementById('previewContainer').style.display = 'block';
        
        // 解碼音頻
        console.log(`開始解碼音頻 ${fileNumber}`);
        const audioBuffer = await decodeAudio(audioData);
        console.log(`音頻 ${fileNumber} 解碼完成，時長: ${audioBuffer.duration} 秒`);
        
        if (fileNumber === 1) {
            audioBuffer1 = audioBuffer;
            // 初始化選擇範圍
            selectedRange1 = { start: 0, end: audioBuffer.duration };
            zoom1 = { start: 0, end: audioBuffer.duration };
            
            // 更新滑塊
            updateSliderValues(1, 0, audioBuffer.duration);
        } else {
            audioBuffer2 = audioBuffer;
            // 初始化選擇範圍
            selectedRange2 = { start: 0, end: audioBuffer.duration };
            zoom2 = { start: 0, end: audioBuffer.duration };
            
            // 更新滑塊
            updateSliderValues(2, 0, audioBuffer.duration);
        }
        
        // 繪製預覽波形
        console.log(`繪製音頻 ${fileNumber} 的波形`);
        drawPreviewWaveform(audioBuffer, fileNumber);
        
        // 檢查兩個文件是否都已上傳
        checkFilesReady();
        
    } catch (error) {
        console.error(`解碼音頻 ${fileNumber} 時發生錯誤:`, error);
        updateStatusMessage(`無法解碼音頻文件 ${fileNumber}: ${error.message}`);
    }
}

// 更新滑塊值
function updateSliderValues(fileNumber, minTime, maxTime) {
    const startSlider = document.getElementById(`start${fileNumber}`);
    const endSlider = document.getElementById(`end${fileNumber}`);
    const startDisplay = document.getElementById(`startTime${fileNumber}`);
    const endDisplay = document.getElementById(`endTime${fileNumber}`);
    
    // 重置滑塊範圍
    startSlider.min = 0;
    startSlider.max = 100;
    startSlider.value = 0;
    
    endSlider.min = 0;
    endSlider.max = 100;
    endSlider.value = 100;
    
    // 更新時間顯示
    startDisplay.textContent = minTime.toFixed(2) + ' 秒';
    endDisplay.textContent = maxTime.toFixed(2) + ' 秒';
    
    // 更新選擇覆蓋層
    updateSelectionOverlay(fileNumber);
}

// 設置範圍選擇
function setupRangeSelection(fileNumber) {
    const startSlider = document.getElementById(`start${fileNumber}`);
    const endSlider = document.getElementById(`end${fileNumber}`);
    
    startSlider.addEventListener('input', function() {
        handleRangeChange(fileNumber);
    });
    
    endSlider.addEventListener('input', function() {
        handleRangeChange(fileNumber);
    });
}

// 處理範圍變化
function handleRangeChange(fileNumber) {
    const startSlider = document.getElementById(`start${fileNumber}`);
    const endSlider = document.getElementById(`end${fileNumber}`);
    const startDisplay = document.getElementById(`startTime${fileNumber}`);
    const endDisplay = document.getElementById(`endTime${fileNumber}`);
    
    // 確保開始值不超過結束值
    if (parseFloat(startSlider.value) > parseFloat(endSlider.value)) {
        startSlider.value = endSlider.value;
    }
    
    // 獲取當前縮放範圍
    const zoomRange = fileNumber === 1 ? zoom1 : zoom2;
    const duration = zoomRange.end - zoomRange.start;
    
    // 計算選擇的實際時間範圍
    const startPercent = parseFloat(startSlider.value) / 100;
    const endPercent = parseFloat(endSlider.value) / 100;
    const startTime = zoomRange.start + (duration * startPercent);
    const endTime = zoomRange.start + (duration * endPercent);
    
    // 更新顯示
    startDisplay.textContent = startTime.toFixed(2) + ' 秒';
    endDisplay.textContent = endTime.toFixed(2) + ' 秒';
    
    // 更新選擇範圍
    if (fileNumber === 1) {
        selectedRange1 = { start: startTime, end: endTime };
    } else {
        selectedRange2 = { start: startTime, end: endTime };
    }
    
    // 更新選擇覆蓋層
    updateSelectionOverlay(fileNumber);
}

// 更新選擇覆蓋層
function updateSelectionOverlay(fileNumber) {
    const canvas = document.getElementById(`preview${fileNumber}`);
    const overlay = document.getElementById(`selection${fileNumber}`);
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    const zoomRange = fileNumber === 1 ? zoom1 : zoom2;
    const duration = zoomRange.end - zoomRange.start;
    
    // 計算相對於當前縮放的百分比
    const startPercent = (range.start - zoomRange.start) / duration * 100;
    const endPercent = (range.end - zoomRange.start) / duration * 100;
    
    // 更新覆蓋層位置和寬度
    overlay.style.left = `${startPercent}%`;
    overlay.style.width = `${endPercent - startPercent}%`;
}

// 縮放到選擇範圍
function zoomToSelection(fileNumber) {
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    
    if (fileNumber === 1) {
        zoom1 = { start: range.start, end: range.end };
        drawPreviewWaveform(audioBuffer1, 1);
        updateSliderValues(1, range.start, range.end);
    } else {
        zoom2 = { start: range.start, end: range.end };
        drawPreviewWaveform(audioBuffer2, 2);
        updateSliderValues(2, range.start, range.end);
    }
    
    // 重置選擇滑塊為全範圍
    document.getElementById(`start${fileNumber}`).value = 0;
    document.getElementById(`end${fileNumber}`).value = 100;
    
    // 更新選擇範圍
    if (fileNumber === 1) {
        selectedRange1 = { start: range.start, end: range.end };
    } else {
        selectedRange2 = { start: range.start, end: range.end };
    }
    
    // 更新覆蓋層
    updateSelectionOverlay(fileNumber);
}

// 重設縮放
function resetZoom(fileNumber) {
    const buffer = fileNumber === 1 ? audioBuffer1 : audioBuffer2;
    if (!buffer) return;
    
    if (fileNumber === 1) {
        zoom1 = { start: 0, end: buffer.duration };
        drawPreviewWaveform(buffer, 1);
        updateSliderValues(1, 0, buffer.duration);
    } else {
        zoom2 = { start: 0, end: buffer.duration };
        drawPreviewWaveform(buffer, 2);
        updateSliderValues(2, 0, buffer.duration);
    }
}

// 播放選擇的音頻
function playSelectedAudio(fileNumber) {
    // 停止當前正在播放的音頻
    if (fileNumber === 1 && audioSource1) {
        audioSource1.stop();
        audioSource1 = null;
    } else if (fileNumber === 2 && audioSource2) {
        audioSource2.stop();
        audioSource2 = null;
    }
    
    const buffer = fileNumber === 1 ? audioBuffer1 : audioBuffer2;
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    
    if (!buffer) return;
    
    try {
        // 確保AudioContext處於運行狀態
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // 創建音頻源
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        
        // 存儲音頻源以便之後停止
        if (fileNumber === 1) {
            audioSource1 = source;
        } else {
            audioSource2 = source;
        }
        
        // 播放選擇的部分
        source.start(0, range.start, range.end - range.start);
        
        // 播放完成後清理
        source.onended = function() {
            if (fileNumber === 1) {
                audioSource1 = null;
            } else {
                audioSource2 = null;
            }
        };
    } catch (error) {
        console.error('播放音頻時發生錯誤:', error);
        updateStatusMessage(`播放音頻時發生錯誤: ${error.message}`);
    }
}

// 檢查兩個文件是否都已上傳
function checkFilesReady() {
    const analyzeBtn = document.getElementById('analyzeBtn');
    
    if (audioBuffer1 && audioBuffer2) {
        console.log("兩個音頻檔案都已上傳並解碼完成，啟用分析按鈕");
        analyzeBtn.disabled = false;
        updateStatusMessage("兩個音檔已上傳，可以進行分析");
    } else {
        console.log("尚未上傳完兩個音頻檔案，分析按鈕保持禁用");
        analyzeBtn.disabled = true;
        if (audioBuffer1) {
            updateStatusMessage("已上傳第一個音檔，請上傳第二個音檔");
        } else if (audioBuffer2) {
            updateStatusMessage("已上傳第二個音檔，請上傳第一個音檔");
        } else {
            updateStatusMessage("請上傳兩個音檔後再進行分析");
        }
    }
}

// 繪製預覽波形
function drawPreviewWaveform(audioBuffer, fileNumber) {
    const canvas = document.getElementById(`preview${fileNumber}`);
    if (!canvas) {
        console.error(`Canvas element preview${fileNumber} not found`);
        return;
    }
    
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error(`Could not get 2D context for canvas preview${fileNumber}`);
        return;
    }
    
    // 獲取音頻數據
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600; // 預設寬度以防父元素寬度未設置
    canvas.width = parentWidth;
    canvas.height = 150;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 獲取當前縮放範圍
    const zoomRange = fileNumber === 1 ? zoom1 : zoom2;
    const startSample = Math.floor(zoomRange.start * sampleRate);
    const endSample = Math.min(Math.floor(zoomRange.end * sampleRate), channelData.length);
    
    // 計算每個像素對應的樣本數
    const samplesPerPixel = Math.max(1, Math.ceil((endSample - startSample) / canvas.width));
    
    // 繪製波形
    ctx.strokeStyle = '#3498db';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    for (let i = 0; i < canvas.width; i++) {
        // 計算當前像素對應的樣本範圍
        const sampleStart = startSample + i * samplesPerPixel;
        const sampleEnd = Math.min(sampleStart + samplesPerPixel, endSample);
        
        // 在樣本範圍內尋找最大和最小值
        let min = Infinity;
        let max = -Infinity;
        
        for (let j = sampleStart; j < sampleEnd; j++) {
            if (j < channelData.length) {
                const value = channelData[j];
                if (value < min) min = value;
                if (value > max) max = value;
            }
        }
        
        // 如果沒有找到有效值，設置為0
        if (min === Infinity) min = 0;
        if (max === -Infinity) max = 0;
        
        // 將值映射到畫布高度
        const y1 = (1 + min) * canvas.height / 2;
        const y2 = (1 + max) * canvas.height / 2;
        
        // 繪製垂直線段
        ctx.moveTo(i, y1);
        ctx.lineTo(i, y2);
    }
    
    ctx.stroke();
}

// 分析音頻
function analyzeAudio() {
    console.log("執行音頻分析");
    
    // 確保有可分析的數據
    if (!audioBuffer1 || !audioBuffer2) {
        console.error("缺少音頻數據，無法分析");
        alert('請先上傳兩個音頻文件。');
        return;
    }
    
    // 顯示載入指示器
    document.getElementById('loadingIndicator').style.display = 'block';
    document.getElementById('analyzeBtn').disabled = true;
    updateStatusMessage("正在分析音頻數據...");
    
    // 清除先前的圖表
    Object.values(charts).forEach(chart => {
        if (chart) chart.destroy();
    });
    
    try {
        console.log("提取選定範圍的數據");
        // 提取選定範圍的數據
        const selectedData1 = extractSelectedData(audioBuffer1, selectedRange1);
        const selectedData2 = extractSelectedData(audioBuffer2, selectedRange2);
        
        console.log("繪製波形圖");
        // 繪製波形圖
        drawWaveform(selectedData1, 'waveform1', '純桌面波形');
        drawWaveform(selectedData2, 'waveform2', '物體+桌面波形');
        
        console.log("計算FFT");
        // 進行FFT分析
        const fftData1 = calculateFFT(selectedData1);
        const fftData2 = calculateFFT(selectedData2);
        
        console.log("繪製FFT圖");
        // 繪製FFT圖
        drawFFT(fftData1, 'fft1', '純桌面頻譜');
        drawFFT(fftData2, 'fft2', '物體+桌面頻譜');
        
        console.log("計算PSD");
        // 計算PSD
        const psdData1 = calculatePSD(selectedData1);
        const psdData2 = calculatePSD(selectedData2);
        
        console.log("繪製PSD圖");
        // 繪製PSD圖
        drawPSD(psdData1, 'psd1', '純桌面功率譜密度');
        drawPSD(psdData2, 'psd2', '物體+桌面功率譜密度');
        
        console.log("識別自然頻率");
        // 識別自然頻率
        identifyNaturalFrequencies(fftData1, fftData2, psdData1, psdData2);
        
        console.log("顯示結果容器");
        // 顯示結果容器
        document.getElementById('resultsContainer').style.display = 'block';
        
        // 滾動到結果區域
        document.getElementById('resultsContainer').scrollIntoView({ behavior: 'smooth' });
        
        updateStatusMessage("分析完成");
        
    } catch (error) {
        console.error('分析過程中發生錯誤:', error);
        alert('分析過程中發生錯誤: ' + error.message);
        updateStatusMessage(`分析過程中發生錯誤: ${error.message}`);
    } finally {
        // 隱藏載入指示器
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('analyzeBtn').disabled = false;
    }
}

// 從AudioBuffer中提取選定範圍的數據
function extractSelectedData(audioBuffer, range) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 計算選擇的樣本範圍
    const startSample = Math.floor(range.start * sampleRate);
    const endSample = Math.min(Math.floor(range.end * sampleRate), channelData.length);
    const sampleCount = endSample - startSample;
    
    if (sampleCount <= 0) {
        throw new Error("選擇的範圍無效或太小");
    }
    
    // 創建新的AudioBuffer
    const newBuffer = audioContext.createBuffer(
        audioBuffer.numberOfChannels,
        sampleCount,
        sampleRate
    );
    
    // 複製選擇範圍的數據
    const newChannelData = newBuffer.getChannelData(0);
    for (let i = 0; i < sampleCount; i++) {
        newChannelData[i] = channelData[startSample + i];
    }
    
    return newBuffer;
}

// 解碼音頻
async function decodeAudio(audioData) {
    return new Promise((resolve, reject) => {
        try {
            // 確保有有效的音頻數據
            if (!audioData || audioData.byteLength === 0) {
                reject(new Error("無效的音頻數據"));
                return;
            }
            
            // 嘗試解碼
            audioContext.decodeAudioData(
                audioData.slice(0), 
                (buffer) => {
                    if (buffer) {
                        resolve(buffer);
                    } else {
                        reject(new Error("解碼音頻失敗"));
                    }
                },
                (error) => {
                    reject(error || new Error("解碼音頻時發生未知錯誤"));
                }
            );
        } catch (error) {
            reject(error);
        }
    });
}

// 繪製波形圖
function drawWaveform(audioBuffer, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 獲取音頻數據
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600;
    canvas.width = parentWidth;
    canvas.height = 200;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 繪製波形
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    // 對數據進行下採樣以適應畫布寬度
    const downsampleFactor = Math.max(1, Math.ceil(channelData.length / canvas.width));
    const downsampledData = [];
    
    for (let i = 0; i < canvas.width; i++) {
        const startIndex = i * downsampleFactor;
        const endIndex = Math.min((i + 1) * downsampleFactor, channelData.length);
        
        // 在每個區間內尋找最大和最小值
        let min = Infinity;
        let max = -Infinity;
        
        for (let j = startIndex; j < endIndex; j++) {
            if (j < channelData.length) {
                const value = channelData[j];
                if (value < min) min = value;
                if (value > max) max = value;
            }
        }
        
        // 如果沒有找到有效值，設置為0
        if (min === Infinity) min = 0;
        if (max === -Infinity) max = 0;
        
        downsampledData.push({
            x: i / canvas.width * audioBuffer.duration,
            min: min,
            max: max
        });
    }
    
    // 使用Chart.js創建波形圖
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: label,
                data: downsampledData,
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1,
                pointRadius: 0,
                fill: false,
                tension: 0.1
            }]
        },
        options: {
            parsing: {
                xAxisKey: 'x',
                yAxisKey: 'max'
            },
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '時間 (秒)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: '振幅'
                    },
                    min: -1,
                    max: 1
                }
            },
            plugins: {
                legend: {
                    display: true
                }
            },
            animation: false,
            responsive: true,
            maintainAspectRatio: false
        }
    });
}

// FFT 類實現
class FFT {
    constructor(size) {
        this.size = size;
        this.csize = size * 2;
        
        // 預計算反轉位元表
        this.reverseBits = new Array(size);
        for (let i = 0; i < size; i++) {
            this.reverseBits[i] = this.calculateReverseBits(i, Math.log2(size));
        }
        
        // 預計算旋轉因子
        this.cosTable = new Array(size / 2);
        this.sinTable = new Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
            this.cosTable[i] = Math.cos(2 * Math.PI * i / size);
            this.sinTable[i] = Math.sin(2 * Math.PI * i / size);
        }
    }
    
    // 計算反轉位元
    calculateReverseBits(x, bits) {
        let res = 0;
        for (let i = 0; i < bits; i++) {
            res = (res << 1) | (x & 1);
            x >>= 1;
        }
        return res;
    }
    
    // 執行FFT
    forward(input) {
        // 創建複數數組 (實部+虛部)
        const complex = new Float32Array(this.csize);
        
        // 填充實部，虛部為零
        for (let i = 0; i < this.size; i++) {
            complex[2 * this.reverseBits[i]] = input[i];
        }
        
        // 蝴蝶運算
        for (let len = 2; len <= this.size; len *= 2) {
            const halfLen = len / 2;
            const tablestep = this.size / len;
            
            for (let i = 0; i < this.size; i += len) {
                for (let j = 0; j < halfLen; j++) {
                    const idx1 = 2 * (i + j);
                    const idx2 = 2 * (i + j + halfLen);
                    
                    const k = j * tablestep;
                    const cosVal = this.cosTable[k];
                    const sinVal = this.sinTable[k];
                    
                    const re = complex[idx2] * cosVal + complex[idx2 + 1] * sinVal;
                    const im = complex[idx2 + 1] * cosVal - complex[idx2] * sinVal;
                    
                    complex[idx2] = complex[idx1] - re;
                    complex[idx2 + 1] = complex[idx1 + 1] - im;
                    complex[idx1] += re;
                    complex[idx1 + 1] += im;
                }
            }
        }
        
        // 計算幅度
        const magnitudes = new Float32Array(this.size);
        for (let i = 0; i < this.size; i++) {
            const re = complex[2 * i];
            const im = complex[2 * i + 1];
            magnitudes[i] = Math.sqrt(re * re + im * im) / this.size;
        }
        
        return magnitudes;
    }
}

// 計算FFT
function calculateFFT(audioBuffer) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 確定FFT大小（2的冪次方）
    const fftSize = Math.pow(2, Math.ceil(Math.log2(channelData.length)));
    
    // 創建FFT對象
    const fft = new FFT(fftSize);
    
    // 準備輸入數據（用零填充）
    const fftInput = new Float32Array(fftSize);
    fftInput.set(channelData.slice(0, fftSize));
    
    // 在執行FFT前應用窗口函數（漢寧窗）
    applyHannWindow(fftInput);
    
    // 執行FFT
    const fftOutput = fft.forward(fftInput);
    
    // 計算頻率分辨率
    const freqStep = sampleRate / fftSize;
    
    // 準備結果數據（只取前半部分，因為FFT結果是對稱的）
    const result = {
        frequencies: [],
        magnitudes: [],
        sampleRate: sampleRate
    };
    
    for (let i = 0; i < fftSize / 2; i++) {
        result.frequencies.push(i * freqStep);
        result.magnitudes.push(fftOutput[i]);
    }
    
    return result;
}

// 應用漢寧窗
function applyHannWindow(buffer) {
    for (let i = 0; i < buffer.length; i++) {
        const multiplier = 0.5 * (1 - Math.cos(2 * Math.PI * i / (buffer.length - 1)));
        buffer[i] *= multiplier;
    }
}

// 計算功率譜密度 (PSD)
function calculatePSD(audioBuffer) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 確定FFT大小（2的冪次方）
    const fftSize = Math.pow(2, Math.ceil(Math.log2(channelData.length)));
    
    // 創建FFT對象
    const fft = new FFT(fftSize);
    
    // 準備輸入數據（用零填充）
    const fftInput = new Float32Array(fftSize);
    fftInput.set(channelData.slice(0, fftSize));
    
    // 在執行FFT前應用窗口函數（漢寧窗）
    applyHannWindow(fftInput);
    
    // 執行FFT
    const fftOutput = fft.forward(fftInput);
    
    // 計算頻率分辨率
    const freqStep = sampleRate / fftSize;
    
    // 準備結果數據（只取前半部分，因為FFT結果是對稱的）
    const result = {
        frequencies: [],
        psd: [],
        sampleRate: sampleRate
    };
    
    for (let i = 0; i < fftSize / 2; i++) {
        result.frequencies.push(i * freqStep);
        // 計算功率譜密度（幅度的平方除以頻率分辨率）
        result.psd.push((fftOutput[i] * fftOutput[i]) / freqStep);
    }
    
    return result;
}

// 繪製FFT圖
function drawFFT(fftData, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600;
    canvas.width = parentWidth;
    canvas.height = 200;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 創建數據點
    const dataPoints = [];
    const maxFreq = 5000; // 最大顯示頻率 (Hz)
    
    for (let i = 0; i < fftData.frequencies.length; i++) {
        if (fftData.frequencies[i] <= maxFreq) {
            dataPoints.push({
                x: fftData.frequencies[i],
                y: fftData.magnitudes[i]
            });
        }
    }
    
    // 使用Chart.js創建FFT圖
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: label,
                data: dataPoints,
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                pointRadius: 0,
                fill: false
            }]
        },
        options: {
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '頻率 (Hz)'
                    }
                },
                y: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '振幅'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true
                }
            },
            animation: false,
            responsive: true,
            maintainAspectRatio: false
        }
    });
}

// 繪製PSD圖
function drawPSD(psdData, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600;
    canvas.width = parentWidth;
    canvas.height = 200;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 創建數據點
    const dataPoints = [];
    const maxFreq = 5000; // 最大顯示頻率 (Hz)
    
    for (let i = 0; i < psdData.frequencies.length; i++) {
        if (psdData.frequencies[i] <= maxFreq) {
            dataPoints.push({
                x: psdData.frequencies[i],
                y: 10 * Math.log10(psdData.psd[i] + 1e-10) // 轉換為dB，避免log(0)
            });
        }
    }
    
    // 使用Chart.js創建PSD圖
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: label,
                data: dataPoints,
                borderColor: 'rgba(153, 102, 255, 1)',
                borderWidth: 1,
                pointRadius: 0,
                fill: false
            }]
        },
        options: {
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '頻率 (Hz)'
                    }
                },
                y: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: 'PSD (dB/Hz)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true
                }
            },
            animation: false,
            responsive: true,
            maintainAspectRatio: false
        }
    });
}

// 優化的自然頻率識別算法
function identifyNaturalFrequencies(fftData1, fftData2, psdData1, psdData2) {
    // 動態計算噪聲下限
    let sumMag = 0;
    for (let i = 0; i < fftData2.magnitudes.length; i++) {
        sumMag += fftData2.magnitudes[i];
    }
    const avgMag = sumMag / fftData2.magnitudes.length;
    
    // 設定參數 - 根據信號特性自適應調整
    const noiseFloor = avgMag * 0.05;               // 噪聲下限為平均振幅的5%
    const frequencyTolerance = 5;                   // 頻率容許誤差
    const localPeakRange = Math.max(3, Math.floor(fftData2.frequencies.length / 1000));  // 局部峰值檢測範圍
    
    // 自適應振幅比例閾值
    let amplitudeRatios = [];
    for (let i = 0; i < fftData2.frequencies.length; i++) {
        const freq2 = fftData2.frequencies[i];
        if (freq2 < 30) continue; // 忽略極低頻
        
        // 找到第一個FFT中對應的頻率
        let closestIndex = -1;
        let minFreqDiff = Infinity;
        
        for (let j = 0; j < fftData1.frequencies.length; j++) {
            const freqDiff = Math.abs(fftData1.frequencies[j] - freq2);
            if (freqDiff < minFreqDiff && freqDiff <= frequencyTolerance) {
                minFreqDiff = freqDiff;
                closestIndex = j;
            }
        }
        
        if (closestIndex >= 0) {
            const mag1 = fftData1.magnitudes[closestIndex];
            const mag2 = fftData2.magnitudes[i];
            if (mag1 > noiseFloor && mag2 > noiseFloor) {
                amplitudeRatios.push(mag2 / (mag1 + 0.000001));
            }
        }
    }
    
    // 計算振幅比例分佈
    amplitudeRatios.sort((a, b) => a - b);
    const ratioMedian = amplitudeRatios[Math.floor(amplitudeRatios.length / 2)] || 1;
    const ratioQ3 = amplitudeRatios[Math.floor(amplitudeRatios.length * 0.75)] || ratioMedian * 1.5;
    
    // 設定自適應閾值 - 降低門檻以顯示更多頻率
    const differenceThreshold = Math.max(1.02, ratioMedian * 0.8); // 降低差異門檻
    const highRatioThreshold = Math.max(1.3, ratioQ3 * 0.9);      // 降低高比率門檻
    
    // 尋找所有峰值頻率
    const naturalFrequencies = [];
    
    // 分析所有頻率
    for (let i = 5; i < fftData2.frequencies.length; i++) {
        const freq2 = fftData2.frequencies[i];
        const mag2 = fftData2.magnitudes[i];
        
        // 忽略極低頻率（<30Hz，通常是環境噪聲或裝置振動）
        if (freq2 < 30) continue;
        
        // 忽略低於噪聲下限的振幅
        if (mag2 < noiseFloor) continue;
        
        // 峰值檢測 - 使用改進的算法
        let isPeak = false;
        
        // 1. 局部最大值檢測（左右各localPeakRange點範圍內的最大值）
        let isLocalMax = true;
        for (let j = Math.max(0, i - localPeakRange); j <= Math.min(fftData2.magnitudes.length - 1, i + localPeakRange); j++) {
            if (j !== i && fftData2.magnitudes[j] > mag2) {
                isLocalMax = false;
                break;
            }
        }
        
        // 2. 相對於局部平均值的突出度
        const localRangeWider = Math.max(10, Math.floor(fftData2.frequencies.length / 500));
        let sum = 0;
        let count = 0;
        
        for (let j = Math.max(0, i - localRangeWider); j <= Math.min(fftData2.magnitudes.length - 1, i + localRangeWider); j++) {
            if (Math.abs(j - i) > localPeakRange) { // 排除中心點附近的值
                sum += fftData2.magnitudes[j];
                count++;
            }
        }
        
        const localAvg = count > 0 ? sum / count : 0;
        // 自適應突出度閾值 - 基於信號整體特性
        const prominenceThreshold = Math.max(1.5, 3 * (1 - Math.exp(-localAvg * 10)));
        const significantlyAboveAvg = mag2 > localAvg * prominenceThreshold;
        
        // 3. 觀察導數變化 - 檢測峰值的形狀
        let derivativePeak = false;
        if (i > 0 && i < fftData2.magnitudes.length - 1) {
            const leftDeriv = mag2 - fftData2.magnitudes[i-1];
            const rightDeriv = fftData2.magnitudes[i+1] - mag2;
            // 左導數為正，右導數為負，表示這是一個峰值
            derivativePeak = (leftDeriv > 0 && rightDeriv < 0);
        }
        
        // 綜合多種峰值檢測方法
        isPeak = isLocalMax || significantlyAboveAvg || derivativePeak;
        
        // 找到最接近的頻率在第一個FFT中的索引
        let closestIndex = -1;
        let minFreqDiff = Infinity;
        
        for (let j = 0; j < fftData1.frequencies.length; j++) {
            const freqDiff = Math.abs(fftData1.frequencies[j] - freq2);
            if (freqDiff < minFreqDiff && freqDiff <= frequencyTolerance) {
                minFreqDiff = freqDiff;
                closestIndex = j;
            }
        }
        
        let amplitudeRatio = 0;
        let confidence = "低";
        
        if (closestIndex >= 0) {
            const mag1 = fftData1.magnitudes[closestIndex];
            amplitudeRatio = mag2 / (mag1 + 0.000001);
            
            // 自適應置信度標準 - 基於信號特性
            if (amplitudeRatio >= highRatioThreshold * 2) {
                confidence = "非常高";
            } else if (amplitudeRatio >= highRatioThreshold) {
                confidence = "高";
            } else if (amplitudeRatio >= differenceThreshold * 1.5) {
                confidence = "中";
            } else if (amplitudeRatio >= differenceThreshold) {
                confidence = "低";
            } else {
                continue; // 忽略過小的比值
            }
        } else {
            // 在第一個FFT中沒有找到對應頻率，這是新增的頻率
            amplitudeRatio = Infinity;
            confidence = "非常高";
        }
        
        // 結合PSD數據進行判斷
        let psdRatio = 1;
        if (closestIndex >= 0 && closestIndex < psdData1.psd.length && i < psdData2.psd.length) {
            psdRatio = (psdData2.psd[i] + 1e-10) / (psdData1.psd[closestIndex] + 1e-10);
            
            // 根據PSD比值調整置信度
            if (psdRatio > 5) {
                if (confidence === "低") confidence = "中";
                else if (confidence === "中") confidence = "高";
            } else if (psdRatio < 1.2 && confidence !== "非常高") {
                if (confidence === "高") confidence = "中";
                else if (confidence === "中") confidence = "低";
            }
        }
        
        // 添加到結果列表
        if ((amplitudeRatio >= differenceThreshold || amplitudeRatio === Infinity) && isPeak) {
            naturalFrequencies.push({
                frequency: freq2.toFixed(1),
                amplitudeRatio: amplitudeRatio === Infinity ? "新增頻率" : amplitudeRatio.toFixed(2),
                confidence: confidence,
                psdRatio: psdRatio.toFixed(2),
                magnitude: mag2,
                index: i
            });
        }
    }
    
    // 調整排序方式，優先考慮振幅比例
    naturalFrequencies.sort((a, b) => {
        // 首先按照振幅比例排序
        const aRatio = a.amplitudeRatio === "新增頻率" ? 100 : parseFloat(a.amplitudeRatio);
        const bRatio = b.amplitudeRatio === "新增頻率" ? 100 : parseFloat(b.amplitudeRatio);
        
        // 然後才考慮幅值和置信度
        const aScore = aRatio * 5 + a.magnitude * getConfidenceScore(a.confidence);
        const bScore = bRatio * 5 + b.magnitude * getConfidenceScore(b.confidence);
        return bScore - aScore;
    });
    
    // 増加保留的頻率數量
    const significantFreqs = naturalFrequencies.slice(0, 25);
    
    // 按頻率排序用於顯示
    significantFreqs.sort((a, b) => parseFloat(a.frequency) - parseFloat(b.frequency));
    
    // 改善接近頻率的處理方式，允許更多頻率顯示
    const uniqueFrequencies = [];
    const processedIndices = new Set(); // 追踪已處理的頻率索引
    
    // 首先按照頻率排序，以便正確地比較相鄰頻率
    const sortedFreqs = [...significantFreqs].sort((a, b) => 
        parseFloat(a.frequency) - parseFloat(b.frequency)
    );
    
    for (let i = 0; i < sortedFreqs.length; i++) {
        if (processedIndices.has(i)) continue; // 跳過已處理的頻率
        
        const currentFreq = parseFloat(sortedFreqs[i].frequency);
        const current = sortedFreqs[i];
        
        // 尋找附近的頻率
        const nearbyFreqs = [];
        for (let j = i + 1; j < sortedFreqs.length; j++) {
            const nextFreq = parseFloat(sortedFreqs[j].frequency);
            
            // 自適應合併閾值 - 對於高頻允許更大的差距
            const mergeThreshold = Math.min(15, 3 + currentFreq / 600);
            
            // 如果頻率接近
            if (Math.abs(nextFreq - currentFreq) <= mergeThreshold) {
                nearbyFreqs.push({index: j, freq: sortedFreqs[j]});
            } else {
                break; // 如果超過閾值就停止搜索
            }
        }
        
        // 若附近沒有頻率，則直接添加當前頻率
        if (nearbyFreqs.length === 0) {
            uniqueFrequencies.push(current);
            processedIndices.add(i);
            continue;
        }
        
        // 找出振幅比例最大的頻率
        let bestIndex = i;
        let bestRatio = current.amplitudeRatio === "新增頻率" ? 100 : parseFloat(current.amplitudeRatio);
        
        for (const {index, freq} of nearbyFreqs) {
            const ratio = freq.amplitudeRatio === "新增頻率" ? 100 : parseFloat(freq.amplitudeRatio);
            
            // 如果這個附近頻率的振幅比例明顯較大（增大超過15%）
            if (ratio > bestRatio * 1.15) {
                bestIndex = index;
                bestRatio = ratio;
            }
            // 標記為已處理
            processedIndices.add(index);
        }
        
        // 添加最佳頻率
        uniqueFrequencies.push(sortedFreqs[bestIndex]);
        processedIndices.add(i);
    }
    
    // 重新按照振幅比例排序
    uniqueFrequencies.sort((a, b) => {
        const aRatio = a.amplitudeRatio === "新增頻率" ? 100 : parseFloat(a.amplitudeRatio);
        const bRatio = b.amplitudeRatio === "新增頻率" ? 100 : parseFloat(b.amplitudeRatio);
        return bRatio - aRatio;
    });
    
    // 分析頻率之間的關係，找出可能的諧波關係
    analyzeHarmonicRelationships(uniqueFrequencies);
    
    // 顯示主要頻率
    displayPrimaryFrequencies(uniqueFrequencies);
    
    // 將結果顯示在表格中
    const tableBody = document.getElementById('frequencyTableBody');
    tableBody.innerHTML = '';
    
    if (uniqueFrequencies.length === 0) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 3;
        cell.textContent = '未檢測到明顯的自然頻率。';
        cell.style.textAlign = 'center';
        row.appendChild(cell);
        tableBody.appendChild(row);
    } else {
        uniqueFrequencies.forEach(freq => {
            const row = document.createElement('tr');
            
            // 根據置信度添加行類別
            if (freq.confidence === "非常高") {
                row.classList.add('confidence-very-high');
            } else if (freq.confidence === "高") {
                row.classList.add('confidence-high');
            } else if (freq.confidence === "中") {
                row.classList.add('confidence-medium');
            } else {
                row.classList.add('confidence-low');
            }
            
            const freqCell = document.createElement('td');
            freqCell.innerHTML = `<span class="freq-value">${freq.frequency}</span> <span class="freq-unit">Hz</span>`;
            if (freq.isHarmonic) {
                freqCell.innerHTML += `<div class="freq-harmonic">${freq.harmonicRelation}</div>`;
            }
            
            const ratioCell = document.createElement('td');
            ratioCell.innerHTML = `<span class="amplitude-ratio">${freq.amplitudeRatio}</span>`;
            
            const confCell = document.createElement('td');
            let badgeClass = '';
            switch (freq.confidence) {
                case "非常高": badgeClass = 'badge-very-high'; break;
                case "高": badgeClass = 'badge-high'; break;
                case "中": badgeClass = 'badge-medium'; break;
                case "低": badgeClass = 'badge-low'; break;
            }
            confCell.innerHTML = `<span class="confidence-badge ${badgeClass}">${freq.confidence}</span>`;
            
            row.appendChild(freqCell);
            row.appendChild(ratioCell);
            row.appendChild(confCell);
            
            tableBody.appendChild(row);
        });
    }
    
    // 輔助函數：獲取置信度分數
    function getConfidenceScore(confidence) {
        switch (confidence) {
            case "非常高": return 4;
            case "高": return 3;
            case "中": return 2;
            case "低": return 1;
            default: return 0.5;
        }
    }
    
    // 分析諧波關係並標記
    function analyzeHarmonicRelationships(frequencies) {
        // 按頻率排序
        const sortedFreqs = [...frequencies].sort((a, b) => 
            parseFloat(a.frequency) - parseFloat(b.frequency)
        );
        
        if (sortedFreqs.length < 2) return;
        
        // 找出最低頻率作為可能的基頻
        const possibleFundamentals = sortedFreqs.slice(0, Math.min(3, sortedFreqs.length));
        
        for (const fund of possibleFundamentals) {
            const fundFreq = parseFloat(fund.frequency);
            
            // 檢查每個頻率是否為此基頻的諧波
            for (let i = 0; i < sortedFreqs.length; i++) {
                const freq = parseFloat(sortedFreqs[i].frequency);
                if (freq <= fundFreq) continue;
                
                // 計算比率
                const ratio = freq / fundFreq;
                const nearestInteger = Math.round(ratio);
                
                // 如果比率接近整數（誤差<5%），則可能是諧波關係
                if (Math.abs(ratio - nearestInteger) < 0.05 * nearestInteger && nearestInteger > 1 && nearestInteger <= 10) {
                    sortedFreqs[i].isHarmonic = true;
                    sortedFreqs[i].harmonicRelation = `${nearestInteger}倍於 ${fundFreq.toFixed(1)}Hz`;
                    sortedFreqs[i].harmonicBase = fundFreq;
                    sortedFreqs[i].harmonicMultiple = nearestInteger;
                }
            }
        }
    }
    
    // 顯示主要頻率卡片
    function displayPrimaryFrequencies(frequencies) {
        // 清空容器
        const container = document.getElementById('primaryFreqContainer');
        container.innerHTML = '';
        
        // 取出高置信度的前3個頻率
        const highConfFreqs = frequencies.filter(f => 
            f.confidence === "非常高" || f.confidence === "高"
        ).slice(0, 3);
        
        // 如果沒有高置信度頻率，則取所有頻率中排名最高的最多3個
        const primaryFreqs = highConfFreqs.length > 0 ? 
            highConfFreqs : frequencies.slice(0, Math.min(3, frequencies.length));
        
        // 如果沒有檢測到頻率，顯示提示信息
        if (primaryFreqs.length === 0) {
            const noFreqDiv = document.createElement('div');
            noFreqDiv.className = 'primary-freq-card';
            noFreqDiv.textContent = '未檢測到明顯的自然頻率';
            container.appendChild(noFreqDiv);
            return;
        }
        
        // 創建頻率卡片
        primaryFreqs.forEach((freq, index) => {
            const card = document.createElement('div');
            card.className = 'primary-freq-card';
            
            // 標題
            const title = document.createElement('div');
            title.textContent = index === 0 ? '主要頻率' : `頻率 ${index + 1}`;
            card.appendChild(title);
            
            // 頻率值
            const value = document.createElement('div');
            value.className = 'primary-freq-value';
            value.innerHTML = `${freq.frequency}<span class="freq-unit">Hz</span>`;
            card.appendChild(value);
            
            // 置信度標記
            const confBadge = document.createElement('div');
            let badgeClass = '';
            switch (freq.confidence) {
                case "非常高": badgeClass = 'badge-very-high'; break;
                case "高": badgeClass = 'badge-high'; break;
                case "中": badgeClass = 'badge-medium'; break;
                case "低": badgeClass = 'badge-low'; break;
            }
            confBadge.className = `confidence-badge ${badgeClass}`;
            confBadge.textContent = freq.confidence;
            card.appendChild(confBadge);
            
            // 諧波關係
            if (freq.isHarmonic) {
                const harmonic = document.createElement('div');
                harmonic.className = 'freq-harmonic';
                harmonic.textContent = freq.harmonicRelation;
                card.appendChild(harmonic);
            }
            
            // 振幅比例指示條
            const barContainer = document.createElement('div');
            barContainer.className = 'bar-indicator';
            
            const barFill = document.createElement('div');
            barFill.className = 'bar-indicator-fill';
            
            // 計算填充比例
            let fillPercent = 0;
            if (freq.amplitudeRatio === "新增頻率") {
                fillPercent = 100;
            } else {
                const ratio = parseFloat(freq.amplitudeRatio);
                fillPercent = Math.min(100, (ratio / 5) * 100);
            }
            
            barFill.style.width = `${fillPercent}%`;
            barContainer.appendChild(barFill);
            card.appendChild(barContainer);
            
            container.appendChild(card);
        });
    }
}
    </script>    
</body>
</html>