<!DOCTYPE html>
<html lang="zh-TW">
<head>
     <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物體自然頻率AI分析器</title>
    <!-- 添加noUiSlider庫 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.6.1/nouislider.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.6.1/nouislider.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    
<style>
   body {
    font-family: 'Microsoft JhengHei', Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f5f5f5;
}

h1, h2, h3 {
    color: #2c3e50;
}

.container {
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.file-upload {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-bottom: 20px;
}

.upload-box {
    flex: 1;
    min-width: 300px;
    border: 2px dashed #3498db;
    border-radius: 5px;
    padding: 20px;
    text-align: center;
    transition: all 0.3s;
}

.upload-box:hover {
    border-color: #2980b9;
    background-color: #f0f7fc;
}

input[type="file"] {
    display: none;
}

.upload-label {
    display: block;
    cursor: pointer;
    font-weight: bold;
    color: #3498db;
}

button {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    margin-right: 10px;
    margin-bottom: 10px;
}

button:hover {
    background-color: #2980b9;
}

button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
}

.visualizations {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
}

.viz-container {
    flex: 1;
    min-width: 400px;
    margin-bottom: 20px;
}

@media (max-width: 768px) {
    .viz-container {
        min-width: 100%;
    }
}

.loading {
    display: none;
    text-align: center;
    margin: 20px 0;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 2s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.file-name {
    margin-top: 10px;
    font-style: italic;
    word-break: break-all;
}

.canvas-container {
    overflow-x: auto;
    margin-top: 10px;
    position: relative;
}

/* 錄音相關樣式 */
.record-option {
    margin-top: 10px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.record-button-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
}

.record-button {
    flex: 1;
    min-width: 80px;
    padding: 12px;
}

.record-button.start {
    background-color: #e74c3c;
}

.record-button.start:hover {
    background-color: #c0392b;
}

.record-button.stop {
    background-color: #7f8c8d;
}

.record-button.stop:hover {
    background-color: #636e72;
}

.record-button.use {
    background-color: #27ae60;
}

.record-button.use:hover {
    background-color: #2ecc71;
}

.record-info {
    margin-top: 10px;
    font-size: 14px;
    color: #666;
}

.record-timer {
    font-weight: bold;
}

.record-visualization {
    width: 100%;
    height: 60px;
    background-color: #000;
    border-radius: 5px;
    margin-top: 10px;
    position: relative;
    overflow: hidden;
}

/* 波形預覽與選擇區域樣式 */
.preview-container {
    margin-top: 20px;
    padding: 10px;
    border: 1px solid #e0e0e0;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.preview-title {
    font-weight: bold;
    margin-bottom: 10px;
}

.waveform-preview {
    position: relative;
    width: 100%;
    height: 150px;
    margin-bottom: 20px;
    border: 1px solid #ddd;
    background-color: #fff;
}

.selection-overlay {
    position: absolute;
    top: 0;
    background-color: rgba(52, 152, 219, 0.3);
    border: 1px solid rgba(52, 152, 219, 0.7);
    height: 100%;
    pointer-events: none;
}

.slider-container {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    margin: 10px 0;
}

@media (max-width: 768px) {
    .slider-container {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .slider-container .slider {
        width: 100%;
        margin: 5px 0;
    }
    
    .slider-container .time-display {
        margin: 5px 0;
    }
}

.time-display {
    margin: 0 10px;
    min-width: 120px;
    text-align: center;
}

.slider {
    flex-grow: 1;
    margin: 0 10px;
}

input[type="range"] {
    width: 100%;
}

.button-container {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.tab-container {
    margin-bottom: 15px;
}

.tab-button {
    border: none;
    background-color: #f2f2f2;
    padding: 10px 20px;
    border-radius: 5px 5px 0 0;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    margin-right: 5px;
}

.tab-button.active {
    background-color: #3498db;
    color: white;
}

.tab-content {
    display: none;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 0 5px 5px 5px;
}

.tab-content.active {
    display: block;
}

.debug-info {
    font-size: 12px;
    color: #666;
    margin-top: 5px;
    font-family: monospace;
}

.analyze-button-container {
    margin-top: 20px;
    text-align: center;
}

.analyze-button-container button {
    padding: 12px 30px;
    font-size: 18px;
}

.primary-button {
    background-color: #9b59b6;
}

.primary-button:hover {
    background-color: #8e44ad;
}

.secondary-button {
    background-color: #27ae60;
}

.secondary-button:hover {
    background-color: #2ecc71;
}

.status-message {
    color: #666;
    font-style: italic;
    margin-top: 5px;
}

.mobile-responsive {
    overflow-x: auto;
}

@media (max-width: 768px) {
    h1 {
        font-size: 24px;
    }
    
    h2 {
        font-size: 20px;
    }
    
    h3 {
        font-size: 18px;
    }
    
    .container {
        padding: 15px;
    }
    
    button {
        padding: 8px 16px;
        font-size: 14px;
    }
    
    .analyze-button-container button {
        padding: 10px 20px;
        font-size: 16px;
    }
}

.tab-indicator {
    background-color: #2ecc71;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    font-size: 12px;
    margin-left: 5px;
}

/* AI分析結果樣式 */
.ai-analysis-result {
    background-color: #f8f9fc;
    border-left: 4px solid #9b59b6;
    padding: 20px;
    border-radius: 8px;
    margin: 20px 0;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.ai-analysis-title {
    color: #9b59b6;
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
    padding-bottom: 10px;
}

.ai-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 20px 0;
}

.ai-loading .spinner {
    border-top-color: #9b59b6;
    margin-right: 15px;
}

.ai-freq-highlight {
    background-color: #9b59b625;
    border-left: 4px solid #9b59b6;
    padding: 15px;
    margin: 15px 0;
    border-radius: 4px;
}

.ai-freq-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding: 10px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.ai-freq-value {
    font-size: 18px;
    font-weight: bold;
    color: #2c3e50;
}

.ai-freq-reason {
    margin-top: 10px;
    padding: 10px;
    background-color: #f1f1f1;
    border-radius: 4px;
    font-style: italic;
}

.ai-suggestion {
    background-color: #eef7ee;
    padding: 15px;
    border-radius: 8px;
    margin-top: 20px;
    border-left: 4px solid #27ae60;
}

/* noUiSlider 樣式 */
.noui-slider {
    height: 10px;
    width: 100%;
    margin: 15px 0;
}

.noUi-connect {
    background: #3498db;
}

.noUi-horizontal {
    height: 10px;
}

.noUi-handle {
    border: 1px solid #3498db;
    background: #fff;
    border-radius: 50%;
    cursor: pointer;
    width: 20px !important;
    height: 20px !important;
    top: -5px !important;
    right: -10px !important;
}

.noUi-handle:before,
.noUi-handle:after {
    display: none;
}

.noUi-tooltip {
    display: none;
}

.noUi-active .noUi-tooltip {
    display: block;
}

.canvas-container {
    height: 220px !important; /* 給圖表高度加上一些額外空間 */
    margin-bottom: 15px;
}

.frequency-range-container {
    margin: 20px 0;
    padding: 15px;
    background-color: #f0f7fc;
    border-radius: 8px;
    border: 1px solid #d1e6f9;
}

.freq-options {
    margin-top: 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.freq-preset-btn {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.3s;
}

.freq-preset-btn:hover {
    background-color: #2980b9;
}

.freq-display {
    margin: 0 10px;
    min-width: 120px;
    text-align: center;
    font-weight: bold;
}

.export-data-container {
    margin-top: 30px;
    padding: 15px;
    background-color: #f8f9fc;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
}

.export-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 15px;
}

.export-btn {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
}

.export-btn:hover {
    background-color: #2980b9;
}

.export-btn.primary-button {
    background-color: #9b59b6;
}

.export-btn.primary-button:hover {
    background-color: #8e44ad;
}
</style>
</head>
<body>
    <h1>物體自然頻率AI分析器</h1>
    
    <div class="container">
        <h2>實驗原理說明</h2>
        <p>此工具用於分析物體的自然頻率。使用方法：</p>
        <ol>
            <li>上傳第一個音檔：純桌面被敲擊的聲音（也可直接錄製）</li>
            <li>上傳第二個音檔：待測物體放在桌面上被敲擊的聲音（也可直接錄製）</li>
            <li>選擇每個音檔中要分析的波形區段</li>
            <li>點擊「分析並取得AI解讀」按鈕進行處理</li>
        </ol>
        <p>系統會顯示兩個音檔的波形圖、頻譜分析（FFT）和功率譜密度（PSD），並使用AI分析識別第二個音檔中獨有的頻率成分，這些頻率即為待測物體的自然頻率。</p>
    </div>
    
    <div class="container">
        <h2>音頻錄製或上傳</h2>
        
        <div class="tab-container">
            <button class="tab-button active" data-target="upload1">上傳檔案</button>
            <button class="tab-button" data-target="record1">錄製音頻</button>
        </div>
        
        <div class="tab-content active" id="upload1">
            <div class="file-upload">
                <div class="upload-box">
                    <label class="upload-label" for="file1">
                        上傳第一個音檔（純桌面）
                        <br><br>
                        <i class="fas fa-cloud-upload-alt" style="font-size: 24px;"></i>
                        <br><br>
                        點擊或拖放文件到此處
                    </label>
                    <input type="file" id="file1" accept="audio/*">
                    <p class="file-name" id="fileName1"></p>
                </div>
                
                <div class="upload-box">
                    <label class="upload-label" for="file2">
                        上傳第二個音檔（物體+桌面）
                        <br><br>
                        <i class="fas fa-cloud-upload-alt" style="font-size: 24px;"></i>
                        <br><br>
                        點擊或拖放文件到此處
                    </label>
                    <input type="file" id="file2" accept="audio/*">
                    <p class="file-name" id="fileName2"></p>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="record1">
            <div class="record-option">
                <h3>錄製第一個音檔（純桌面）<span id="recordStatus1" class="status-message"></span></h3>
                <div class="record-button-container">
                    <button id="startRecord1" class="record-button start">開始錄音</button>
                    <button id="stopRecord1" class="record-button stop" disabled>停止錄音</button>
                    <button id="playRecorded1" class="record-button" disabled>播放錄音</button>
                    <button id="useRecording1" class="record-button use" disabled>使用此錄音</button>
                </div>
                <div class="record-info">
                    <p>錄音時間: <span id="recordTime1" class="record-timer">00:00</span></p>
                </div>
                <div class="record-visualization" id="recordVisual1"></div>
            </div>
            
            <div class="record-option">
                <h3>錄製第二個音檔（物體+桌面）<span id="recordStatus2" class="status-message"></span></h3>
                <div class="record-button-container">
                    <button id="startRecord2" class="record-button start">開始錄音</button>
                    <button id="stopRecord2" class="record-button stop" disabled>停止錄音</button>
                    <button id="playRecorded2" class="record-button" disabled>播放錄音</button>
                    <button id="useRecording2" class="record-button use" disabled>使用此錄音</button>
                </div>
                <div class="record-info">
                    <p>錄音時間: <span id="recordTime2" class="record-timer">00:00</span></p>
                </div>
                <div class="record-visualization" id="recordVisual2"></div>
            </div>
        </div>
    </div>
    
    <!-- 波形預覽與範圍選擇區域 -->
 <!-- 波形預覽與範圍選擇區域 -->
<div class="container" id="previewContainer" style="display:none;">
    <h2>波形預覽與範圍選擇</h2>
    <p>請在下方波形圖上選擇要分析的時間範圍：</p>
    
    <div class="preview-container">
        <div class="preview-title">第一個音檔（純桌面）</div>
        <div class="waveform-preview">
            <canvas id="preview1"></canvas>
            <div id="selection1" class="selection-overlay"></div>
        </div>
        <div class="slider-container">
            <span>時間範圍：</span>
            <div id="slider1" class="noui-slider"></div>
            <div class="time-display">
                <span id="startTime1">0.00 秒</span> - <span id="endTime1">0.00 秒</span>
            </div>
        </div>
        <div class="button-container">
            <button id="playSelection1">播放選擇區域</button>
            <button id="zoomSelection1">放大選擇區域</button>
            <button id="resetZoom1">重設縮放</button>
        </div>
    </div>
        
     <div class="preview-container">
        <div class="preview-title">第二個音檔（物體+桌面）</div>
        <div class="waveform-preview">
            <canvas id="preview2"></canvas>
            <div id="selection2" class="selection-overlay"></div>
        </div>
        <div class="slider-container">
            <span>時間範圍：</span>
            <div id="slider2" class="noui-slider"></div>
            <div class="time-display">
                <span id="startTime2">0.00 秒</span> - <span id="endTime2">0.00 秒</span>
            </div>
        </div>
        <div class="button-container">
            <button id="playSelection2">播放選擇區域</button>
            <button id="zoomSelection2">放大選擇區域</button>
            <button id="resetZoom2">重設縮放</button>
        </div>
    </div>

    <div class="frequency-range-container">
    <h3>頻率分析範圍設置</h3>
    <p>選擇要分析的頻率範圍（0~5000Hz）：</p>
    
    <div class="slider-container">
        <span>頻率範圍：</span>
        <div id="freqRangeSlider" class="noui-slider"></div>
        <div class="freq-display">
            <span id="minFreq">0</span> - <span id="maxFreq">5000</span> Hz
        </div>
    </div>
    
    <div class="freq-options">
        <button id="fullRangeBtn" class="freq-preset-btn">全範圍 (0-5000Hz)</button>
        <button id="lowRangeBtn" class="freq-preset-btn">低頻 (0-500Hz)</button>
        <button id="midRangeBtn" class="freq-preset-btn">中頻 (500-2000Hz)</button>
        <button id="highRangeBtn" class="freq-preset-btn">高頻 (2000-5000Hz)</button>
    </div>
</div>
        
          <div class="analyze-button-container">
        <button id="analyzeBtn" class="primary-button">分析並取得AI解讀</button>
        <div id="statusMessage" class="status-message"></div>
    </div>
        
         <div class="loading" id="loadingIndicator">
        <p>正在處理音頻數據，請稍候...</p>
        <div class="spinner"></div>
    </div>
</div>
    
    <div class="container" id="resultsContainer" style="display:none;">
        <h2>分析結果</h2>
        
        <div class="mobile-responsive">
        <div class="visualizations">
            <div class="viz-container">
                <h3>波形圖</h3>
                <div class="canvas-container">
                    <canvas id="waveform1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="waveform2"></canvas>
                </div>
            </div>
            
            <div class="viz-container">
                <h3>FFT頻譜分析</h3>
                <div class="canvas-container">
                    <canvas id="fft1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="fft2"></canvas>
                </div>
            </div>
        </div>
        
        <div class="visualizations">
            <div class="viz-container">
                <h3>功率譜密度 (PSD)</h3>
                <div class="canvas-container">
                    <canvas id="psd1"></canvas>
                </div>
                <div class="canvas-container">
                    <canvas id="psd2"></canvas>
                </div>
            </div>
            
            <div class="viz-container result-section">
                <h3>AI自然頻率分析</h3>
                <div id="aiAnalysisResult" class="ai-analysis-result">
                    <div id="aiAnalysisContent">
                        <div class="ai-loading">
                            <div class="spinner"></div>
                            <p>AI正在分析數據，請稍候...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>

       <div class="export-data-container">
    <h3>實驗數據導出</h3>
    <div class="export-buttons">
        <button id="exportFFTBtn" class="export-btn">導出FFT數據</button>
        <button id="exportPSDBtn" class="export-btn">導出PSD數據</button>
        <button id="exportAllBtn" class="export-btn primary-button">取得所有數據</button>
    </div>
</div>

    </div>



<script>

// 全局變量
let audioContext;
let file1Data = null;
let file2Data = null;
let audioBuffer1 = null;
let audioBuffer2 = null;
let charts = {};
let audioSource1 = null;
let audioSource2 = null;
let fftData1 = null;
let fftData2 = null;
let psdData1 = null;
let psdData2 = null;

// 選擇範圍變量
let selectedRange1 = { start: 0, end: 1 };
let selectedRange2 = { start: 0, end: 1 };

// 縮放變量
let zoom1 = { start: 0, end: 1 };
let zoom2 = { start: 0, end: 1 };

// 錄音相關變量
let mediaRecorder1 = null;
let mediaRecorder2 = null;
let recordedChunks1 = [];
let recordedChunks2 = [];
let recordingStream1 = null;
let recordingStream2 = null;
let recordingStartTime1 = 0;
let recordingStartTime2 = 0;
let recordingTimer1 = null;
let recordingTimer2 = null;
let recordedBlob1 = null;
let recordedBlob2 = null;
let visualizer1 = null;
let visualizer2 = null;
let recording1Ready = false;
let recording2Ready = false;

// 頻率範圍選擇相關變量
let freqRangeMin = 0;
let freqRangeMax = 5000;

// 統一的頁面初始化函數
document.addEventListener('DOMContentLoaded', function() {
    console.log("頁面初始化開始");
    
    // 檢查瀏覽器是否支持Web Audio API
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContext();
    } catch (e) {
        alert('您的瀏覽器不支持Web Audio API。請使用Chrome、Firefox、Safari或Edge的最新版本。');
    }
    
    // 檢查瀏覽器是否支持MediaRecorder API
    if (!window.MediaRecorder) {
        document.getElementById('record1').innerHTML = '<p>您的瀏覽器不支持錄音功能。請使用Chrome、Firefox、Safari或Edge的最新版本。</p>';
    }
    
    // 設置標籤頁切換
    setupTabs();
    
    // 文件上傳事件處理
    document.getElementById('file1').addEventListener('change', function(e) {
        handleFileUpload(e, 'file1', 'fileName1');
    });
    
    document.getElementById('file2').addEventListener('change', function(e) {
        handleFileUpload(e, 'file2', 'fileName2');
    });
    
    // 拖放事件
    setupDragAndDrop('file1', 'fileName1');
    setupDragAndDrop('file2', 'fileName2');
    
    // 錄音事件處理
    setupRecording(1);
    setupRecording(2);
    
    // 分析按鈕事件
    const analyzeBtn = document.getElementById('analyzeBtn');
    analyzeBtn.addEventListener('click', function() {
        console.log("分析按鈕被點擊");
        analyzeAudioWithAI();
    });
    
    // 範圍選擇事件
    setupRangeSelection(1);
    setupRangeSelection(2);
    
    // 播放選擇區域事件
    document.getElementById('playSelection1').addEventListener('click', function() {
        playSelectedAudio(1);
    });
    document.getElementById('playSelection2').addEventListener('click', function() {
        playSelectedAudio(2);
    });
    
    // 縮放事件
    document.getElementById('zoomSelection1').addEventListener('click', function() {
        zoomToSelection(1);
    });
    document.getElementById('zoomSelection2').addEventListener('click', function() {
        zoomToSelection(2);
    });
    
    // 重設縮放
    document.getElementById('resetZoom1').addEventListener('click', function() {
        resetZoom(1);
    });
    document.getElementById('resetZoom2').addEventListener('click', function() {
        resetZoom(2);
    });
    
    // 初始化頻率範圍滑塊
    initFrequencyRangeSlider();
    
    // 設置頻率範圍按鈕
    setupFrequencyRangeButtons();
    
    // 添加導出相關的CSS樣式
    addExportStyles();
    
    // 初始化導出按鈕事件監聽器
    setupExportButtons();
    
    // 確保初始狀態下分析按鈕是禁用的
    analyzeBtn.disabled = true;
    updateStatusMessage("請上傳或錄製音檔後再進行分析");
    
    console.log("頁面初始化完成");
});

// 初始化頻率範圍滑塊
function initFrequencyRangeSlider() {
    const sliderElement = document.getElementById('freqRangeSlider');
    
    // 如果已經初始化，則銷毀
    if (sliderElement.noUiSlider) {
        sliderElement.noUiSlider.destroy();
    }
    
    // 創建noUiSlider
    noUiSlider.create(sliderElement, {
        start: [freqRangeMin, freqRangeMax],
        connect: true,
        range: {
            'min': 0,
            'max': 5000
        },
        step: 10,
        format: {
            to: function (value) {
                return parseInt(value);
            },
            from: function (value) {
                return parseInt(value);
            }
        }
    });
    
    // 監聽滑塊變化
    sliderElement.noUiSlider.on('update', function (values) {
        freqRangeMin = values[0];
        freqRangeMax = values[1];
        
        // 更新顯示
        document.getElementById('minFreq').textContent = freqRangeMin;
        document.getElementById('maxFreq').textContent = freqRangeMax;
    });
}

// 設置頻率範圍按鈕
function setupFrequencyRangeButtons() {
    document.getElementById('fullRangeBtn').addEventListener('click', function() {
        setFrequencyRange(0, 5000);
    });
    
    document.getElementById('lowRangeBtn').addEventListener('click', function() {
        setFrequencyRange(0, 500);
    });
    
    document.getElementById('midRangeBtn').addEventListener('click', function() {
        setFrequencyRange(500, 2000);
    });
    
    document.getElementById('highRangeBtn').addEventListener('click', function() {
        setFrequencyRange(2000, 5000);
    });
}

// 設置頻率範圍
function setFrequencyRange(min, max) {
    const slider = document.getElementById('freqRangeSlider');
    if (slider.noUiSlider) {
        slider.noUiSlider.set([min, max]);
    }
}

// 設置標籤頁切換
function setupTabs() {
    const tabButtons = document.querySelectorAll('.tab-button');
    
    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            // 取得目標標籤頁ID
            const targetId = this.getAttribute('data-target');
            
            // 移除所有標籤頁按鈕的active類
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 隱藏所有標籤頁內容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 添加當前按鈕的active類
            this.classList.add('active');
            
            // 顯示目標標籤頁內容
            document.getElementById(targetId).classList.add('active');
        });
    });
}

// 設置錄音功能
function setupRecording(fileNumber) {
    const startButton = document.getElementById(`startRecord${fileNumber}`);
    const stopButton = document.getElementById(`stopRecord${fileNumber}`);
    const playButton = document.getElementById(`playRecorded${fileNumber}`);
    const useButton = document.getElementById(`useRecording${fileNumber}`);
    const statusDisplay = document.getElementById(`recordStatus${fileNumber}`);
    const timerDisplay = document.getElementById(`recordTime${fileNumber}`);
    const visualizerContainer = document.getElementById(`recordVisual${fileNumber}`);
    
    // 開始錄音按鈕事件
    startButton.addEventListener('click', function() {
        startRecording(fileNumber);
    });
    
    // 停止錄音按鈕事件
    stopButton.addEventListener('click', function() {
        stopRecording(fileNumber);
    });
    
    // 播放錄音按鈕事件
    playButton.addEventListener('click', function() {
        playRecording(fileNumber);
    });
    
    // 使用錄音按鈕事件
    useButton.addEventListener('click', function() {
        useRecording(fileNumber);
    });
}

// 檢測支持的錄音格式
function getSupportedMimeTypes() {
    const possibleTypes = [
        'audio/webm',
        'audio/webm;codecs=opus',
        'audio/ogg',
        'audio/ogg;codecs=opus',
        'audio/mp4',
        'audio/mp4;codecs=aac',
        'audio/wav',
        'audio/wav;codecs=1'
    ];
    
    return possibleTypes.filter(type => {
        try {
            return MediaRecorder.isTypeSupported(type);
        } catch(e) {
            return false;
        }
    });
}

// 開始錄音
async function startRecording(fileNumber) {
    try {
        // 請求麥克風權限
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // 恢復AudioContext（解決移動設備上的問題）
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        // 檢測支持的格式
        const supportedMimeTypes = getSupportedMimeTypes();
        console.log("支持的錄音格式:", supportedMimeTypes);
        
        if (supportedMimeTypes.length === 0) {
            throw new Error("您的瀏覽器不支持任何可用的錄音格式");
        }
        
        // 使用第一個支持的格式
        const mimeType = supportedMimeTypes[0];
        console.log(`使用錄音格式: ${mimeType}`);
        
        // 設置錄音器
        const recorderOptions = { mimeType };
        const recorder = new MediaRecorder(stream, recorderOptions);
        
        // 存儲全局變量
        if (fileNumber === 1) {
            recordedChunks1 = [];
            recordingStream1 = stream;
            mediaRecorder1 = recorder;
            recordingStartTime1 = Date.now();
            
            // 創建可視化
            visualizer1 = createVisualizer(stream, 'recordVisual1');
            
            // 啟動計時器
            startTimer(fileNumber);
            
            // 更新狀態
            document.getElementById('recordStatus1').textContent = "正在錄音...";
            document.getElementById('startRecord1').disabled = true;
            document.getElementById('stopRecord1').disabled = false;
            document.getElementById('playRecorded1').disabled = true;
            document.getElementById('useRecording1').disabled = true;
        } else {
            recordedChunks2 = [];
            recordingStream2 = stream;
            mediaRecorder2 = recorder;
            recordingStartTime2 = Date.now();
            
            // 創建可視化
            visualizer2 = createVisualizer(stream, 'recordVisual2');
            
            // 啟動計時器
            startTimer(fileNumber);
            
            // 更新狀態
            document.getElementById('recordStatus2').textContent = "正在錄音...";
            document.getElementById('startRecord2').disabled = true;
            document.getElementById('stopRecord2').disabled = false;
            document.getElementById('playRecorded2').disabled = true;
            document.getElementById('useRecording2').disabled = true;
        }
        
        // 設置數據處理事件
        recorder.ondataavailable = function(e) {
            if (e.data.size > 0) {
                if (fileNumber === 1) {
                    recordedChunks1.push(e.data);
                } else {
                    recordedChunks2.push(e.data);
                }
            }
        };
        
        // 錄音結束事件
        recorder.onstop = function() {
            if (fileNumber === 1) {
                // 停止流和可視化
                stopMediaTracks(recordingStream1);
                if (visualizer1) {
                    visualizer1.disconnect();
                }
                
                // 停止計時器
                clearInterval(recordingTimer1);
                
                // 創建音頻Blob，使用實際使用的MIME類型
                const actualType = mediaRecorder1.mimeType || 'audio/webm';
                recordedBlob1 = new Blob(recordedChunks1, { type: actualType });
                
                // 更新狀態
                document.getElementById('recordStatus1').textContent = "錄音完成";
                document.getElementById('startRecord1').disabled = false;
                document.getElementById('stopRecord1').disabled = true;
                document.getElementById('playRecorded1').disabled = false;
                document.getElementById('useRecording1').disabled = false;
                
                recording1Ready = true;
            } else {
                // 停止流和可視化
                stopMediaTracks(recordingStream2);
                if (visualizer2) {
                    visualizer2.disconnect();
                }
                
                // 停止計時器
                clearInterval(recordingTimer2);
                
                // 創建音頻Blob，使用實際使用的MIME類型
                const actualType = mediaRecorder2.mimeType || 'audio/webm';
                recordedBlob2 = new Blob(recordedChunks2, { type: actualType });
                
                // 更新狀態
                document.getElementById('recordStatus2').textContent = "錄音完成";
                document.getElementById('startRecord2').disabled = false;
                document.getElementById('stopRecord2').disabled = true;
                document.getElementById('playRecorded2').disabled = false;
                document.getElementById('useRecording2').disabled = false;
                
                recording2Ready = true;
            }
        };
        
        // 開始錄音，每100毫秒獲取一次數據
        recorder.start(100);
        
    } catch (error) {
        console.error(`錄音時發生錯誤 (音檔${fileNumber}):`, error);
        
        let errorMessage = "";
        if (error.name === "NotAllowedError") {
            errorMessage = "請允許麥克風權限以進行錄音";
        } else if (error.message.includes("mimeType") || error.name === "NotSupportedError") {
            errorMessage = "瀏覽器不支持錄音格式，請嘗試使用Chrome或Firefox";
        } else {
            errorMessage = `錄音錯誤: ${error.message}`;
        }
        
        alert(`無法開始錄音: ${errorMessage}`);
        console.log("錄音錯誤詳情:", error);
        
        // 重設按鈕狀態
        if (fileNumber === 1) {
            document.getElementById('startRecord1').disabled = false;
            document.getElementById('stopRecord1').disabled = true;
            document.getElementById('recordStatus1').textContent = "錄音失敗: " + errorMessage;
        } else {
            document.getElementById('startRecord2').disabled = false;
            document.getElementById('stopRecord2').disabled = true;
            document.getElementById('recordStatus2').textContent = "錄音失敗: " + errorMessage;
        }
    }
}

// 停止錄音
function stopRecording(fileNumber) {
    if (fileNumber === 1 && mediaRecorder1 && mediaRecorder1.state !== 'inactive') {
        mediaRecorder1.stop();
    } else if (fileNumber === 2 && mediaRecorder2 && mediaRecorder2.state !== 'inactive') {
        mediaRecorder2.stop();
    }
}

// 播放錄音
function playRecording(fileNumber) {
    const blob = fileNumber === 1 ? recordedBlob1 : recordedBlob2;
    
    if (!blob) {
        console.error(`沒有可用的錄音 (音檔${fileNumber})`);
        return;
    }
    
    // 創建音頻元素播放
    const audioURL = URL.createObjectURL(blob);
    const audio = new Audio(audioURL);
    audio.play();
    
    // 播放完成後釋放URL
    audio.onended = function() {
        URL.revokeObjectURL(audioURL);
    };
}

// 使用錄音作為音頻源
async function useRecording(fileNumber) {
    const blob = fileNumber === 1 ? recordedBlob1 : recordedBlob2;
    
    if (!blob) {
        console.error(`沒有可用的錄音 (音檔${fileNumber})`);
        return;
    }
    
    try {
        // 將Blob轉換為ArrayBuffer
        const arrayBuffer = await blob.arrayBuffer();
        
        // 處理錄音數據
        if (fileNumber === 1) {
            file1Data = arrayBuffer;
            document.getElementById('fileName1').textContent = "已錄製的音頻";
        } else {
            file2Data = arrayBuffer;
            document.getElementById('fileName2').textContent = "已錄製的音頻";
        }
        
        // 解碼並預覽
        await decodeAndPreview(arrayBuffer, fileNumber);
        
        // 更新狀態
        if (fileNumber === 1) {
            document.getElementById('recordStatus1').textContent = "已使用此錄音";
            
            // 在標籤頁按鈕上添加指示器
            const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
            if (tabButton) {
                if (!tabButton.querySelector('.tab-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'tab-indicator';
                    indicator.textContent = '✓';
                    tabButton.appendChild(indicator);
                }
            }
        } else {
            document.getElementById('recordStatus2').textContent = "已使用此錄音";
        }
        
    } catch (error) {
        console.error(`處理錄音時發生錯誤 (音檔${fileNumber}):`, error);
        alert(`無法處理錄音。錯誤: ${error.message}`);
    }
}

// 啟動錄音計時器
function startTimer(fileNumber) {
    const timerDisplay = document.getElementById(`recordTime${fileNumber}`);
    const startTime = Date.now();
    
    if (fileNumber === 1) {
        // 清除舊計時器
        if (recordingTimer1) {
            clearInterval(recordingTimer1);
        }
        
        // 設置新計時器
        recordingTimer1 = setInterval(function() {
            const elapsedTime = Date.now() - startTime;
            const seconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }, 1000);
    } else {
        // 清除舊計時器
        if (recordingTimer2) {
            clearInterval(recordingTimer2);
        }
        
        // 設置新計時器
        recordingTimer2 = setInterval(function() {
            const elapsedTime = Date.now() - startTime;
            const seconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }, 1000);
    }
}

// 停止媒體軌道
function stopMediaTracks(stream) {
    if (stream) {
        stream.getTracks().forEach(track => {
            track.stop();
        });
    }
}

// 創建音頻可視化
function createVisualizer(stream, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return null;
    
    try {
        // 清空容器
        container.innerHTML = '';
        
        // 創建畫布
        const canvas = document.createElement('canvas');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        container.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        
        // 創建音頻分析器
        const audioSource = audioContext.createMediaStreamSource(stream);
        const analyzer = audioContext.createAnalyser();
        analyzer.fftSize = 256;
        
        audioSource.connect(analyzer);
        
        const bufferLength = analyzer.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        // 動畫函數
        function draw() {
            // 獲取畫布尺寸（可能已更改）
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            requestAnimationFrame(draw);
            
            analyzer.getByteFrequencyData(dataArray);
            
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * canvas.height;
                
                // 根據頻率設置顏色漸變
                const r = 50 + (i * 2);
                const g = 50 + (i * 1);
                const b = 200;
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }
        
        draw();
        
        return audioSource;
    } catch (error) {
        console.error('創建可視化時發生錯誤:', error);
        return null;
    }
}

// 更新狀態消息
function updateStatusMessage(message) {
    const statusElement = document.getElementById('statusMessage');
    if (statusElement) {
        statusElement.textContent = message;
    }
}

// 處理文件上傳
function handleFileUpload(event, fileId, fileNameId) {
    const file = event.target.files[0];
    if (!file) return;
    
    document.getElementById(fileNameId).textContent = file.name;
    updateStatusMessage(`正在載入 ${file.name}...`);
    
    const reader = new FileReader();
    reader.onload = function(e) {
        if (fileId === 'file1') {
            file1Data = e.target.result;
            decodeAndPreview(file1Data, 1);
            
            // 在標籤頁按鈕上添加指示器
            const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
            if (tabButton) {
                if (!tabButton.querySelector('.tab-indicator')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'tab-indicator';
                    indicator.textContent = '✓';
                    tabButton.appendChild(indicator);
                }
            }
        } else {
            file2Data = e.target.result;
            decodeAndPreview(file2Data, 2);
        }
    };
    reader.onerror = function() {
        updateStatusMessage(`讀取文件 ${file.name} 時出錯`);
    };
    reader.readAsArrayBuffer(file);
}

// 設置拖放功能
function setupDragAndDrop(fileId, fileNameId) {
    const dropZone = document.querySelector(`label[for="${fileId}"]`).parentNode;
    
    dropZone.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '#e3f2fd';
    });
    
    dropZone.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '';
    });
    
    dropZone.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.style.background = '';
        
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('audio/')) {
            document.getElementById(fileId).files = e.dataTransfer.files;
            document.getElementById(fileNameId).textContent = file.name;
            updateStatusMessage(`正在載入 ${file.name}...`);
            
            const reader = new FileReader();
            reader.onload = function(event) {
                if (fileId === 'file1') {
                    file1Data = event.target.result;
                    decodeAndPreview(file1Data, 1);
                    
                    // 在標籤頁按鈕上添加指示器
                    const tabButton = document.querySelector(`.tab-button[data-target="upload1"]`);
                    if (tabButton) {
                        if (!tabButton.querySelector('.tab-indicator')) {
                            const indicator = document.createElement('span');
                            indicator.className = 'tab-indicator';
                            indicator.textContent = '✓';
                            tabButton.appendChild(indicator);
                        }
                    }
                } else {
                    file2Data = event.target.result;
                    decodeAndPreview(file2Data, 2);
                }
            };
            reader.onerror = function() {
                updateStatusMessage(`讀取文件 ${file.name} 時出錯`);
            };
            reader.readAsArrayBuffer(file);
        }
    });
}

// 解碼音頻並預覽
async function decodeAndPreview(audioData, fileNumber) {
    try {
        // 顯示預覽容器 (在嘗試解碼前就顯示)
        document.getElementById('previewContainer').style.display = 'block';
        
        // 解碼音頻
        console.log(`開始解碼音頻 ${fileNumber}`);
        const audioBuffer = await decodeAudio(audioData);
        console.log(`音頻 ${fileNumber} 解碼完成，時長: ${audioBuffer.duration} 秒`);
        
        if (fileNumber === 1) {
            audioBuffer1 = audioBuffer;
            // 初始化選擇範圍
            selectedRange1 = { start: 0, end: audioBuffer.duration };
            zoom1 = { start: 0, end: audioBuffer.duration };
            
        } else {
            audioBuffer2 = audioBuffer;
            // 初始化選擇範圍
            selectedRange2 = { start: 0, end: audioBuffer.duration };
            zoom2 = { start: 0, end: audioBuffer.duration };
        }
        
        // 繪製預覽波形
        console.log(`繪製音頻 ${fileNumber} 的波形`);
        drawPreviewWaveform(audioBuffer, fileNumber);
        
        // 初始化範圍滑桿
        initializeNoUiSlider(fileNumber, 0, audioBuffer.duration);
        
        // 檢查兩個文件是否都已上傳
        checkFilesReady();
        
    } catch (error) {
        console.error(`解碼音頻 ${fileNumber} 時發生錯誤:`, error);
        updateStatusMessage(`無法解碼音頻文件 ${fileNumber}: ${error.message}`);
    }
}

// 初始化noUiSlider
function initializeNoUiSlider(fileNumber, minTime, maxTime) {
    const sliderElement = document.getElementById(`slider${fileNumber}`);
    
    // 如果已經初始化，則銷毀
    if (sliderElement.noUiSlider) {
        sliderElement.noUiSlider.destroy();
    }
    
    // 創建noUiSlider
    noUiSlider.create(sliderElement, {
        start: [minTime, maxTime],
        connect: true,
        range: {
            'min': minTime,
            'max': maxTime
        },
        step: 0.01,
        format: {
            to: function (value) {
                return parseFloat(value.toFixed(2));
            },
            from: function (value) {
                return parseFloat(value);
            }
        }
    });
    
    // 監聽滑塊變化
    sliderElement.noUiSlider.on('update', function (values) {
        const startTime = values[0];
        const endTime = values[1];
        
        // 更新顯示
        document.getElementById(`startTime${fileNumber}`).textContent = startTime.toFixed(2) + ' 秒';
        document.getElementById(`endTime${fileNumber}`).textContent = endTime.toFixed(2) + ' 秒';
        
        // 更新選擇範圍
        if (fileNumber === 1) {
            selectedRange1 = { start: startTime, end: endTime };
        } else {
            selectedRange2 = { start: startTime, end: endTime };
        }
        
        // 更新選擇覆蓋層
        updateSelectionOverlay(fileNumber);
    });
}

// 設置範圍選擇
function setupRangeSelection(fileNumber) {
    // 注意: 這個函數在使用noUiSlider後不再需要設置事件監聽器
    // 但保留函數以保持與原代碼的兼容性
}

// 更新選擇覆蓋層
function updateSelectionOverlay(fileNumber) {
    const canvas = document.getElementById(`preview${fileNumber}`);
    const overlay = document.getElementById(`selection${fileNumber}`);
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    const zoomRange = fileNumber === 1 ? zoom1 : zoom2;
    const duration = zoomRange.end - zoomRange.start;
    
    // 計算相對於當前縮放的百分比
    const startPercent = (range.start - zoomRange.start) / duration * 100;
    const endPercent = (range.end - zoomRange.start) / duration * 100;
    
    // 更新覆蓋層位置和寬度
    overlay.style.left = `${startPercent}%`;
    overlay.style.width = `${endPercent - startPercent}%`;
}

// 縮放到選擇範圍
function zoomToSelection(fileNumber) {
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    
    if (fileNumber === 1) {
        zoom1 = { start: range.start, end: range.end };
        drawPreviewWaveform(audioBuffer1, 1);
        
        // 更新範圍滑桿
        const slider1 = document.getElementById('slider1');
        if (slider1.noUiSlider) {
            slider1.noUiSlider.updateOptions({
                range: {
                    'min': range.start,
                    'max': range.end
                }
            });
            slider1.noUiSlider.set([range.start, range.end]);
        }
    } else {
        zoom2 = { start: range.start, end: range.end };
        drawPreviewWaveform(audioBuffer2, 2);
        
        // 更新範圍滑桿
        const slider2 = document.getElementById('slider2');
        if (slider2.noUiSlider) {
            slider2.noUiSlider.updateOptions({
                range: {
                    'min': range.start,
                    'max': range.end
                }
            });
            slider2.noUiSlider.set([range.start, range.end]);
        }
    }
}

// 重設縮放
function resetZoom(fileNumber) {
    const buffer = fileNumber === 1 ? audioBuffer1 : audioBuffer2;
    if (!buffer) return;
    
    if (fileNumber === 1) {
        zoom1 = { start: 0, end: buffer.duration };
        drawPreviewWaveform(buffer, 1);
        
        // 更新範圍滑桿
        const slider1 = document.getElementById('slider1');
        if (slider1.noUiSlider) {
            slider1.noUiSlider.updateOptions({
                range: {
                    'min': 0,
                    'max': buffer.duration
                }
            });
            slider1.noUiSlider.set([0, buffer.duration]);
        }
    } else {
        zoom2 = { start: 0, end: buffer.duration };
        drawPreviewWaveform(buffer, 2);
        
        // 更新範圍滑桿
        const slider2 = document.getElementById('slider2');
        if (slider2.noUiSlider) {
            slider2.noUiSlider.updateOptions({
                range: {
                    'min': 0,
                    'max': buffer.duration
                }
            });
            slider2.noUiSlider.set([0, buffer.duration]);
        }
    }
}

// 播放選擇的音頻
function playSelectedAudio(fileNumber) {
    // 停止當前正在播放的音頻
    if (fileNumber === 1 && audioSource1) {
        audioSource1.stop();
        audioSource1 = null;
    } else if (fileNumber === 2 && audioSource2) {
        audioSource2.stop();
        audioSource2 = null;
    }
    
    const buffer = fileNumber === 1 ? audioBuffer1 : audioBuffer2;
    const range = fileNumber === 1 ? selectedRange1 : selectedRange2;
    
    if (!buffer) return;
    
    try {
        // 確保AudioContext處於運行狀態
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // 創建音頻源
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        
        // 存儲音頻源以便之後停止
        if (fileNumber === 1) {
            audioSource1 = source;
        } else {
            audioSource2 = source;
        }
        
        // 播放選擇的部分
        source.start(0, range.start, range.end - range.start);
        
        // 播放完成後清理
        source.onended = function() {
            if (fileNumber === 1) {
                audioSource1 = null;
            } else {
                audioSource2 = null;
            }
        };
    } catch (error) {
        console.error('播放音頻時發生錯誤:', error);
        updateStatusMessage(`播放音頻時發生錯誤: ${error.message}`);
    }
}

// 檢查檔案是否已就緒
function checkFilesReady() {
    const analyzeBtn = document.getElementById('analyzeBtn');
    
    if (audioBuffer2) {
        console.log("至少有第二個音檔已上傳並解碼完成，啟用分析按鈕");
        analyzeBtn.disabled = false;
        
        if (!audioBuffer1) {
            updateStatusMessage("僅上傳第二個音檔，將直接分析物體的自然頻率");
        } else {
            updateStatusMessage("兩個音檔已上傳，可以進行比較分析");
        }
    } else {
        console.log("尚未上傳第二個音檔，分析按鈕保持禁用");
        analyzeBtn.disabled = true;
        if (audioBuffer1) {
            updateStatusMessage("已上傳第一個音檔，請上傳第二個音檔");
        } else {
            updateStatusMessage("請至少上傳第二個音檔後再進行分析");
        }
    }
}

// 繪製預覽波形
function drawPreviewWaveform(audioBuffer, fileNumber) {
    const canvas = document.getElementById(`preview${fileNumber}`);
    if (!canvas) {
        console.error(`Canvas element preview${fileNumber} not found`);
        return;
    }
    
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error(`Could not get 2D context for canvas preview${fileNumber}`);
        return;
    }
    
    // 獲取音頻數據
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600; // 預設寬度以防父元素寬度未設置
    canvas.width = parentWidth;
    canvas.height = 150;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 獲取當前縮放範圍
    const zoomRange = fileNumber === 1 ? zoom1 : zoom2;
    const startSample = Math.floor(zoomRange.start * sampleRate);
    const endSample = Math.min(Math.floor(zoomRange.end * sampleRate), channelData.length);
    
    // 計算每個像素對應的樣本數
    const samplesPerPixel = Math.max(1, Math.ceil((endSample - startSample) / canvas.width));
    
    // 繪製波形
    ctx.strokeStyle = '#3498db';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    for (let i = 0; i < canvas.width; i++) {
        // 計算當前像素對應的樣本範圍
        const sampleStart = startSample + i * samplesPerPixel;
        const sampleEnd = Math.min(sampleStart + samplesPerPixel, endSample);
        
        // 在樣本範圍內尋找最大和最小值
        let min = Infinity;
        let max = -Infinity;
        
        for (let j = sampleStart; j < sampleEnd; j++) {
            if (j < channelData.length) {
                const value = channelData[j];
                if (value < min) min = value;
                if (value > max) max = value;
            }
        }
        
        // 如果沒有找到有效值，設置為0
        if (min === Infinity) min = 0;
        if (max === -Infinity) max = 0;
        
        // 將值映射到畫布高度
        const y1 = (1 + min) * canvas.height / 2;
        const y2 = (1 + max) * canvas.height / 2;
        
        // 繪製垂直線段
        ctx.moveTo(i, y1);
        ctx.lineTo(i, y2);
    }
    
    ctx.stroke();
}

// 使用AI分析音頻
async function analyzeAudioWithAI() {
    console.log("執行音頻分析並用AI解讀");
    
    // 確保有第二個音檔的數據
    if (!audioBuffer2) {
        console.error("缺少第二個音檔數據，無法分析");
        alert('請至少上傳第二個音頻文件（物體+桌面）。');
        return;
    }
    
    // 顯示載入指示器
    document.getElementById('loadingIndicator').style.display = 'block';
    document.getElementById('analyzeBtn').disabled = true;
    updateStatusMessage("正在分析音頻數據...");
    
    // 清除先前的圖表
    Object.values(charts).forEach(chart => {
        if (chart) chart.destroy();
    });
    
    try {
        console.log("提取選定範圍的數據");
        
        // 如果有第一個音檔，則提取其數據
        let selectedData1 = null;
        if (audioBuffer1) {
            selectedData1 = extractSelectedData(audioBuffer1, selectedRange1);
            console.log("繪製第一個音檔波形圖");
            drawWaveform(selectedData1, 'waveform1', '純桌面波形');
        }
        
        // 提取第二個音檔數據
        const selectedData2 = extractSelectedData(audioBuffer2, selectedRange2);
        console.log("繪製第二個音檔波形圖");
        drawWaveform(selectedData2, 'waveform2', '物體+桌面波形');
        
        console.log("計算FFT");
        // 如果有第一個音檔，計算其FFT
        if (selectedData1) {
            fftData1 = calculateFFT(selectedData1);
            console.log("繪製第一個音檔FFT圖");
            drawFFT(fftData1, 'fft1', '純桌面頻譜');
        } else {
            fftData1 = null;
        }
        
        // 計算第二個音檔的FFT
        fftData2 = calculateFFT(selectedData2);
        console.log("繪製第二個音檔FFT圖");
        drawFFT(fftData2, 'fft2', '物體+桌面頻譜');
        
        console.log("計算PSD");
        // 如果有第一個音檔，計算其PSD
        if (selectedData1) {
            psdData1 = calculatePSD(selectedData1);
            console.log("繪製第一個音檔PSD圖");
            drawPSD(psdData1, 'psd1', '純桌面功率譜密度');
        } else {
            psdData1 = null;
        }
        
        // 計算第二個音檔的PSD
        psdData2 = calculatePSD(selectedData2);
        console.log("繪製第二個音檔PSD圖");
        drawPSD(psdData2, 'psd2', '物體+桌面功率譜密度');
        
        console.log("顯示結果容器");
        // 顯示結果容器
        document.getElementById('resultsContainer').style.display = 'block';
        
        // 滾動到結果區域
        document.getElementById('resultsContainer').scrollIntoView({ behavior: 'smooth' });
        
        // 使用AI分析數據
        await performAIAnalysis();
        
        updateStatusMessage("分析完成");
        
    } catch (error) {
        console.error('分析過程中發生錯誤:', error);
        alert('分析過程中發生錯誤: ' + error.message);
        updateStatusMessage(`分析過程中發生錯誤: ${error.message}`);
    } finally {
        // 隱藏載入指示器
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('analyzeBtn').disabled = false;
    }
}

// 從AudioBuffer中提取選定範圍的數據
function extractSelectedData(audioBuffer, range) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 計算選擇的樣本範圍
    const startSample = Math.floor(range.start * sampleRate);
    const endSample = Math.min(Math.floor(range.end * sampleRate), channelData.length);
    const sampleCount = endSample - startSample;
    
    if (sampleCount <= 0) {
        throw new Error("選擇的範圍無效或太小");
    }
    
    // 創建新的AudioBuffer
    const newBuffer = audioContext.createBuffer(
        audioBuffer.numberOfChannels,
        sampleCount,
        sampleRate
    );
    
    // 複製選擇範圍的數據
    const newChannelData = newBuffer.getChannelData(0);
    for (let i = 0; i < sampleCount; i++) {
        newChannelData[i] = channelData[startSample + i];
    }
    
    return newBuffer;
}

// 解碼音頻
async function decodeAudio(audioData) {
    return new Promise((resolve, reject) => {
        try {
            // 確保有有效的音頻數據
            if (!audioData || audioData.byteLength === 0) {
                reject(new Error("無效的音頻數據"));
                return;
            }
            
            // 嘗試解碼
            audioContext.decodeAudioData(
                audioData.slice(0), 
                (buffer) => {
                    if (buffer) {
                        resolve(buffer);
                    } else {
                        reject(new Error("解碼音頻失敗"));
                    }
                },
                (error) => {
                    reject(error || new Error("解碼音頻時發生未知錯誤"));
                }
            );
        } catch (error) {
            reject(error);
        }
    });
}

function drawWaveform(audioBuffer, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 獲取音頻數據
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 設置畫布大小 - 與FFT圖保持一致
    const parentWidth = canvas.parentNode.clientWidth || 600;
    const targetHeight = 200; // 基礎高度
    canvas.width = parentWidth;
    canvas.height = targetHeight;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 繪製波形
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    // 對數據進行下採樣以適應畫布寬度
    const downsampleFactor = Math.max(1, Math.ceil(channelData.length / canvas.width));
    const maxData = [];  // 用於存儲最大值
    const minData = [];  // 用於存儲最小值
    
    for (let i = 0; i < canvas.width; i++) {
        const startIndex = i * downsampleFactor;
        const endIndex = Math.min((i + 1) * downsampleFactor, channelData.length);
        
        // 在每個區間內尋找最大和最小值
        let min = Infinity;
        let max = -Infinity;
        
        for (let j = startIndex; j < endIndex; j++) {
            if (j < channelData.length) {
                const value = channelData[j];
                if (value < min) min = value;
                if (value > max) max = value;
            }
        }
        
        // 如果沒有找到有效值，設置為0
        if (min === Infinity) min = 0;
        if (max === -Infinity) max = 0;
        
        const x = i / canvas.width * audioBuffer.duration;
        
        // 分別存儲最大值和最小值
        maxData.push({ x: x, y: max });
        minData.push({ x: x, y: min });
    }
    
    // 使用Chart.js創建波形圖，同時繪製最大值和最小值
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    label: label,
                    data: maxData,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: false
                },
                {
                    label: '_hidden', // 使用下劃線前綴的標籤會被圖例忽略
                    data: minData,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: '+1',  // 填充到前一個數據集
                    backgroundColor: 'rgba(75, 192, 192, 0.2)'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // 不維持寬高比，允許完全自定義高度
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '時間 (秒)'
                    },
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: '振幅'
                    },
                    min: -1.1,
                    max: 1.1,
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        filter: function(item) {
                            // 不顯示以下劃線開頭的標籤
                            return !item.text.startsWith('_');
                        },
                        boxWidth: 15,
                        padding: 5
                    }
                },
                tooltip: {
                    enabled: false // 禁用工具提示以提高性能
                }
            },
            layout: {
                padding: {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }
            },
            animation: false,
            elements: {
                line: {
                    tension: 0 // 禁用曲線平滑
                }
            }
        }
    });
    
    // 設置容器樣式以確保高度匹配
    const container = canvas.parentNode;
    if (container) {
        container.style.height = targetHeight + 'px';
    }
}

// FFT 類實現
class FFT {
    constructor(size) {
        this.size = size;
        this.csize = size * 2;
        
        // 預計算反轉位元表
        this.reverseBits = new Array(size);
        for (let i = 0; i < size; i++) {
            this.reverseBits[i] = this.calculateReverseBits(i, Math.log2(size));
        }
        
        // 預計算旋轉因子
        this.cosTable = new Array(size / 2);
        this.sinTable = new Array(size / 2);
        for (let i = 0; i < size / 2; i++) {
            this.cosTable[i] = Math.cos(2 * Math.PI * i / size);
            this.sinTable[i] = Math.sin(2 * Math.PI * i / size);
        }
    }
    
    // 計算反轉位元
    calculateReverseBits(x, bits) {
        let res = 0;
        for (let i = 0; i < bits; i++) {
            res = (res << 1) | (x & 1);
            x >>= 1;
        }
        return res;
    }
    
    // 執行FFT
    forward(input) {
        // 創建複數數組 (實部+虛部)
        const complex = new Float32Array(this.csize);
        
        // 填充實部，虛部為零
        for (let i = 0; i < this.size; i++) {
            complex[2 * this.reverseBits[i]] = input[i];
        }
        
        // 蝴蝶運算
        for (let len = 2; len <= this.size; len *= 2) {
            const halfLen = len / 2;
            const tablestep = this.size / len;
            
            for (let i = 0; i < this.size; i += len) {
                for (let j = 0; j < halfLen; j++) {
                    const idx1 = 2 * (i + j);
                    const idx2 = 2 * (i + j + halfLen);
                    
                    const k = j * tablestep;
                    const cosVal = this.cosTable[k];
                    const sinVal = this.sinTable[k];
                    
                    const re = complex[idx2] * cosVal + complex[idx2 + 1] * sinVal;
                    const im = complex[idx2 + 1] * cosVal - complex[idx2] * sinVal;
                    
                    complex[idx2] = complex[idx1] - re;
                    complex[idx2 + 1] = complex[idx1 + 1] - im;
                    complex[idx1] += re;
                    complex[idx1 + 1] += im;
                }
            }
        }
        
        // 計算幅度
        const magnitudes = new Float32Array(this.size);
        for (let i = 0; i < this.size; i++) {
            const re = complex[2 * i];
            const im = complex[2 * i + 1];
            magnitudes[i] = Math.sqrt(re * re + im * im) / this.size;
        }
        
        return magnitudes;
    }
}

// 計算FFT
function calculateFFT(audioBuffer) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 確定FFT大小（2的冪次方）
    const fftSize = Math.pow(2, Math.ceil(Math.log2(channelData.length)));
    
    // 創建FFT對象
    const fft = new FFT(fftSize);
    
    // 準備輸入數據（用零填充）
    const fftInput = new Float32Array(fftSize);
    fftInput.set(channelData.slice(0, fftSize));
    
    // 在執行FFT前應用窗口函數（漢寧窗）
    applyHannWindow(fftInput);
    
    // 執行FFT
    const fftOutput = fft.forward(fftInput);
    
    // 計算頻率分辨率
    const freqStep = sampleRate / fftSize;
    
    // 準備結果數據（只取前半部分，因為FFT結果是對稱的）
    const result = {
        frequencies: [],
        magnitudes: [],
        sampleRate: sampleRate
    };
    
    for (let i = 0; i < fftSize / 2; i++) {
        result.frequencies.push(i * freqStep);
        result.magnitudes.push(fftOutput[i]);
    }
    
    return result;
}

// 應用漢寧窗
function applyHannWindow(buffer) {
    for (let i = 0; i < buffer.length; i++) {
        const multiplier = 0.5 * (1 - Math.cos(2 * Math.PI * i / (buffer.length - 1)));
        buffer[i] *= multiplier;
    }
}

// 計算功率譜密度 (PSD)
function calculatePSD(audioBuffer) {
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    
    // 確定FFT大小（2的冪次方）
    const fftSize = Math.pow(2, Math.ceil(Math.log2(channelData.length)));
    
    // 創建FFT對象
    const fft = new FFT(fftSize);
    
    // 準備輸入數據（用零填充）
    const fftInput = new Float32Array(fftSize);
    fftInput.set(channelData.slice(0, fftSize));
    
    // 在執行FFT前應用窗口函數（漢寧窗）
    applyHannWindow(fftInput);
    
    // 執行FFT
    const fftOutput = fft.forward(fftInput);
    
    // 計算頻率分辨率
    const freqStep = sampleRate / fftSize;
    
    // 準備結果數據（只取前半部分，因為FFT結果是對稱的）
    const result = {
        frequencies: [],
        psd: [],
        sampleRate: sampleRate
    };
    
    for (let i = 0; i < fftSize / 2; i++) {
        result.frequencies.push(i * freqStep);
        // 計算功率譜密度（幅度的平方除以頻率分辨率）
        result.psd.push((fftOutput[i] * fftOutput[i]) / freqStep);
    }
    
    return result;
}

// 修改 drawFFT 函數，增加頻率範圍過濾
function drawFFT(fftData, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600;
    const targetHeight = 200; // 與波形圖一致的高度
    canvas.width = parentWidth;
    canvas.height = targetHeight;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 創建數據點，只包含選定頻率範圍內的數據
    const dataPoints = [];
    
    // 使用用戶設定的頻率範圍，確保有默認值
    const minFreq = typeof freqRangeMin !== 'undefined' ? freqRangeMin : 0;
    const maxFreq = typeof freqRangeMax !== 'undefined' ? freqRangeMax : 5000;
    
    // 過濾數據點到指定的頻率範圍
    for (let i = 0; i < fftData.frequencies.length; i++) {
        if (fftData.frequencies[i] >= minFreq && fftData.frequencies[i] <= maxFreq) {
            dataPoints.push({
                x: fftData.frequencies[i],
                y: fftData.magnitudes[i]
            });
        }
    }
    
    // 使用Chart.js創建FFT圖
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: label,
                data: dataPoints,
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                pointRadius: 0,
                fill: false
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '頻率 (Hz)'
                    },
                    min: minFreq,      // 設置X軸最小值為當前選擇的最小頻率
                    max: maxFreq,      // 設置X軸最大值為當前選擇的最大頻率
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                },
                y: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '振幅'
                    },
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        boxWidth: 15,
                        padding: 5
                    }
                },
                tooltip: {
                    enabled: true // 啟用工具提示以便查看具體頻率值
                }
            },
            animation: false
        }
    });
    
    // 設置容器樣式以確保高度匹配
    const container = canvas.parentNode;
    if (container) {
        container.style.height = targetHeight + 'px';
    }
}

// 相應地修改PSD圖的繪製函數
function drawPSD(psdData, canvasId, label) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');
    
    // 設置畫布大小
    const parentWidth = canvas.parentNode.clientWidth || 600;
    const targetHeight = 200; // 與其他圖一致的高度
    canvas.width = parentWidth;
    canvas.height = targetHeight;
    
    // 清除畫布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 創建數據點，只包含選定頻率範圍內的數據
    const dataPoints = [];
    
    // 使用用戶設定的頻率範圍，確保有默認值
    const minFreq = typeof freqRangeMin !== 'undefined' ? freqRangeMin : 0;
    const maxFreq = typeof freqRangeMax !== 'undefined' ? freqRangeMax : 5000;
    
    // 過濾數據點到指定的頻率範圍
    for (let i = 0; i < psdData.frequencies.length; i++) {
        if (psdData.frequencies[i] >= minFreq && psdData.frequencies[i] <= maxFreq) {
            dataPoints.push({
                x: psdData.frequencies[i],
                y: 10 * Math.log10(psdData.psd[i] + 1e-10) // 轉換為dB，避免log(0)
            });
        }
    }
    
    // 使用Chart.js創建PSD圖
    if (charts[canvasId]) {
        charts[canvasId].destroy();
    }
    
    charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: label,
                data: dataPoints,
                borderColor: 'rgba(153, 102, 255, 1)',
                borderWidth: 1,
                pointRadius: 0,
                fill: false
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: '頻率 (Hz)'
                    },
                    min: minFreq,      // 設置X軸最小值為當前選擇的最小頻率
                    max: maxFreq,      // 設置X軸最大值為當前選擇的最大頻率
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                },
                y: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: 'PSD (dB/Hz)'
                    },
                    grid: {
                        display: true,
                        color: 'rgba(200, 200, 200, 0.3)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        boxWidth: 15,
                        padding: 5
                    }
                },
                tooltip: {
                    enabled: true // 啟用工具提示以便查看具體頻率值
                }
            },
            animation: false
        }
    });
    
    // 設置容器樣式以確保高度匹配
    const container = canvas.parentNode;
    if (container) {
        container.style.height = targetHeight + 'px';
    }
}

// 改進峰值檢測算法，使其更能識別實際的自然頻率
function findSignificantPeaksInRange(fftData, maxPeaks, minFreq, maxFreq) {
    const peaks = [];
    const minPeakDistance = 5; // 峰值最小間距(Hz)
    
    // 計算背景噪聲水平（使用中位數而非平均值，更能抵抗離群值影響）
    const magnitudesInRange = [];
    for (let i = 0; i < fftData.frequencies.length; i++) {
        const freq = fftData.frequencies[i];
        if (freq >= minFreq && freq <= maxFreq) {
            magnitudesInRange.push(fftData.magnitudes[i]);
        }
    }
    
    // 排序並取中位數
    magnitudesInRange.sort((a, b) => a - b);
    const medianMagnitude = magnitudesInRange[Math.floor(magnitudesInRange.length / 2)];
    
    // 計算噪聲閾值 (中位數的幾倍)
    const noiseThreshold = medianMagnitude * 3;
    
    console.log(`頻率範圍 ${minFreq}-${maxFreq}Hz 的噪聲閾值: ${noiseThreshold} (中位數: ${medianMagnitude})`);
    
    // 尋找局部峰值，使用更先進的峰值檢測
    for (let i = 2; i < fftData.frequencies.length - 2; i++) {
        const freq = fftData.frequencies[i];
        const mag = fftData.magnitudes[i];
        
        // 跳過不在選定頻率範圍內的頻率
        if (freq < minFreq || freq > maxFreq) continue;
        
        // 跳過低於噪聲閾值的值
        if (mag < noiseThreshold) continue;
        
        // 計算局部峰值品質 (和周圍點的差異)
        const peakQuality = calculatePeakQuality(fftData.magnitudes, i, 2);
        
        // 檢查是否是局部峰值 (比左右兩側高)
        // 加入更嚴格的峰值條件：必須同時高於相鄰的多個點
        if (mag > fftData.magnitudes[i-2] && 
            mag > fftData.magnitudes[i-1] && 
            mag > fftData.magnitudes[i+1] && 
            mag > fftData.magnitudes[i+2]) {
            
            // 檢查是否與已有峰值太接近
            let tooClose = false;
            for (const peak of peaks) {
                if (Math.abs(peak.frequency - freq) < minPeakDistance) {
                    tooClose = true;
                    // 如果新峰值更強或品質更好，替換舊峰值
                    if (mag > peak.magnitude || peakQuality > peak.quality) {
                        peak.frequency = freq;
                        peak.magnitude = mag;
                        peak.index = i;
                        peak.quality = peakQuality;
                    }
                    break;
                }
            }
            
            // 如果不太接近現有峰值，添加新峰值
            if (!tooClose) {
                peaks.push({
                    frequency: freq,
                    magnitude: mag,
                    index: i,
                    quality: peakQuality,
                    noiseRatio: mag / medianMagnitude // 信噪比
                });
            }
        }
    }
    
    // 定義一個加權排序函數，考慮振幅和峰值品質
    const weightedSort = (a, b) => {
        // 結合振幅和峰值品質的加權分數
        const scoreA = a.magnitude * 0.7 + a.quality * 0.3;
        const scoreB = b.magnitude * 0.7 + b.quality * 0.3;
        return scoreB - scoreA;
    };
    
    // 按加權分數排序
    peaks.sort(weightedSort);
    
    // 返回前N個峰值
    return peaks.slice(0, maxPeaks);
}

// 計算峰值品質 (峰值與周圍點的差異程度)
function calculatePeakQuality(magnitudes, peakIndex, range) {
    const peakMag = magnitudes[peakIndex];
    let qualitySum = 0;
    
    // 計算與左側點的差異
    for (let i = Math.max(0, peakIndex - range); i < peakIndex; i++) {
        qualitySum += (peakMag - magnitudes[i]) / range;
    }
    
    // 計算與右側點的差異
    for (let i = peakIndex + 1; i <= Math.min(magnitudes.length - 1, peakIndex + range); i++) {
        qualitySum += (peakMag - magnitudes[i]) / range;
    }
    
    return qualitySum;
}

// 改進分析函數，使其更有效地識別自然頻率
function analyzeFFTAndPSD(fftData1, fftData2, psdData1, psdData2) {
    // 結果數組
    const results = [];
    
    // 獲取當前選定的頻率範圍
    const minFreq = typeof freqRangeMin !== 'undefined' ? freqRangeMin : 0;
    const maxFreq = typeof freqRangeMax !== 'undefined' ? freqRangeMax : 5000;
    
    // 1. 先從FFT中找出主要峰值（僅考慮選定頻率範圍內的）
    const fftPeaks = findSignificantPeaksInRange(fftData2, 20, minFreq, maxFreq);
    
    console.log("找到的峰值:", fftPeaks);
    
    // 2. 使用PSD來驗證這些峰值是否真實
    for (const peak of fftPeaks) {
        // 在PSD數據中尋找對應頻率
        const psdValue = findPSDValueAtFrequency(psdData2, peak.frequency);
        const normalizedPSDValue = normalizePSDValue(psdData2, psdValue);
        
        // 計算FFT峰值的顯著性
        const fftSignificance = peak.noiseRatio || calculatePeakSignificance(fftData2, peak.index);
        
        // 如果PSD在此頻率點也顯示能量集中，則認為此峰值可信
        const psdConfirmed = isPSDConfirmed(psdData2, peak.frequency);
        
        // 如果有第一個音頻數據，計算頻率增強率
        let enhancementRatio = 1;
        let isEnhanced = false;
        
        if (fftData1) {
            const result = compareWithFirstFile(fftData1, peak.frequency, peak.magnitude);
            enhancementRatio = result.ratio;
            isEnhanced = result.isEnhanced;
        }
        
        // 改進的可信度計算方法
        const credibility = calculateImprovedCredibility(
            fftSignificance,
            normalizedPSDValue,
            psdConfirmed,
            enhancementRatio,
            isEnhanced,
            peak.quality || 0
        );
        
        // 降低可信度閾值，使更多潛在的自然頻率能被納入分析
        if (credibility > 20) { // 將閾值從30降低至20
            results.push({
                frequency: peak.frequency,
                credibility: credibility,
                fftMagnitude: peak.magnitude,
                psdValue: psdValue,
                psdConfirmed: psdConfirmed,
                enhancementRatio: fftData1 ? enhancementRatio : null,
                isNew: fftData1 ? (enhancementRatio > 10) : null,
                peakQuality: peak.quality || 0
            });
        }
    }
    
    // 合併接近的頻率（相差5%內）
    const mergedResults = mergeCloseFrequencies(results);
    
    // 按可信度排序（從高到低）
    mergedResults.sort((a, b) => b.credibility - a.credibility);
    
    console.log("最終結果:", mergedResults);
    
    // 返回前8個結果，增加返回的結果數量
    return mergedResults.slice(0, 8);
}

// 在PSD數據中尋找特定頻率的值
function findPSDValueAtFrequency(psdData, targetFreq) {
    let closestIndex = 0;
    let minDiff = Infinity;
    
    // 尋找最接近的頻率點
    for (let i = 0; i < psdData.frequencies.length; i++) {
        const diff = Math.abs(psdData.frequencies[i] - targetFreq);
        if (diff < minDiff) {
            minDiff = diff;
            closestIndex = i;
        }
    }
    
    return psdData.psd[closestIndex];
}

// 歸一化PSD值
function normalizePSDValue(psdData, value) {
    // 找出最大PSD值
    const maxPSD = Math.max(...psdData.psd);
    
    // 返回歸一化值（0-100）
    return value / maxPSD * 100;
}

// 計算峰值顯著性（相對於周圍的高度）
function calculatePeakSignificance(fftData, peakIndex) {
    const peakMag = fftData.magnitudes[peakIndex];
    const searchRange = 10; // 搜索範圍
    
    // 計算周圍區域平均振幅
    let sum = 0;
    let count = 0;
    
    for (let i = Math.max(0, peakIndex - searchRange); i <= Math.min(fftData.magnitudes.length - 1, peakIndex + searchRange); i++) {
        if (Math.abs(i - peakIndex) > 2) { // 排除峰值點及其緊鄰點
            sum += fftData.magnitudes[i];
            count++;
        }
    }
    
    const avgMag = count > 0 ? sum / count : 0;
    
    // 峰值與周圍區域平均振幅的比率
    return avgMag > 0 ? peakMag / avgMag : 1;
}

// 改進的 isPSDConfirmed 函數，使其更敏感地確認頻率峰值
function isPSDConfirmed(psdData, targetFreq) {
    // 找出最接近的頻率點
    let closestIndex = 0;
    let minDiff = Infinity;
    
    for (let i = 0; i < psdData.frequencies.length; i++) {
        const diff = Math.abs(psdData.frequencies[i] - targetFreq);
        if (diff < minDiff) {
            minDiff = diff;
            closestIndex = i;
        }
    }
    
    // 計算搜索範圍（更小的範圍，更精確的峰值檢測）
    const searchRange = Math.min(2, Math.floor(psdData.frequencies.length / 1000) + 1);
    
    // 檢查是否是PSD局部峰值
    if (closestIndex > searchRange && closestIndex < psdData.psd.length - searchRange) {
        let isPeak = true;
        
        // 檢查左側點
        for (let i = 1; i <= searchRange; i++) {
            if (psdData.psd[closestIndex] <= psdData.psd[closestIndex - i]) {
                isPeak = false;
                break;
            }
        }
        
        // 如果左側確認是峰值，再檢查右側點
        if (isPeak) {
            for (let i = 1; i <= searchRange; i++) {
                if (psdData.psd[closestIndex] <= psdData.psd[closestIndex + i]) {
                    isPeak = false;
                    break;
                }
            }
        }
        
        return isPeak;
    }
    
    return false;
}

// 改進的 compareWithFirstFile 函數，使其更敏感地檢測增強的頻率
function compareWithFirstFile(fftData1, targetFreq, magnitude2) {
    const freqTolerance = targetFreq * 0.03; // 頻率匹配容許3%誤差
    
    // 在第一個音頻中尋找對應頻率
    let magnitude1 = 0;
    let bestMatchIndex = -1;
    let found = false;
    
    for (let i = 0; i < fftData1.frequencies.length; i++) {
        if (Math.abs(fftData1.frequencies[i] - targetFreq) <= freqTolerance) {
            if (bestMatchIndex === -1 || Math.abs(fftData1.frequencies[i] - targetFreq) < Math.abs(fftData1.frequencies[bestMatchIndex] - targetFreq)) {
                bestMatchIndex = i;
                magnitude1 = fftData1.magnitudes[i];
                found = true;
            }
        }
    }
    
    // 計算振幅比例，增強對小振幅變化的靈敏度
    let ratio = 1;
    if (found && magnitude1 > 0.000001) {
        ratio = magnitude2 / magnitude1;
    } else {
        // 如果在第一個音頻中未找到此頻率，可能是全新的頻率
        ratio = 10; // 給予較高的比率，表示這可能是物體的自然頻率
    }
    
    // 判斷是否顯著增強（降低閾值，使其更容易被識別為增強）
    const isEnhanced = ratio > 1.2; // 從1.5降低到1.2
    
    return { ratio, isEnhanced, magnitude1 };
}

// 改進的可信度計算方法
function calculateImprovedCredibility(fftSignificance, normalizedPSD, psdConfirmed, enhancementRatio, isEnhanced, peakQuality) {
    // 初始化各個分量的分數
    let fftScore = 0;           // FFT峰值評分
    let psdScore = 0;           // PSD確認評分
    let enhancementScore = 0;   // 頻率增強評分
    let qualityScore = 0;       // 峰值品質評分
    
    // 1. FFT峰值顯著性評分 (最高5分) - 使用更敏感的閾值
    if (fftSignificance < 1.5) {
        fftScore = 1; // 微弱峰值
    } else if (fftSignificance < 2.5) {
        fftScore = 2; // 弱峰值
    } else if (fftSignificance < 3.5) {
        fftScore = 3; // 中等峰值
    } else if (fftSignificance < 5) {
        fftScore = 4; // 強峰值
    } else {
        fftScore = 5; // 非常顯著的峰值
    }
    
    // 2. PSD確認評分 (最高3分)
    if (psdConfirmed) {
        psdScore = 3; // PSD完全確認
    } else if (normalizedPSD > 40) { // 降低閾值，使其更容易獲得較高評分
        psdScore = 2; // PSD有較強能量
    } else if (normalizedPSD > 15) { // 降低閾值
        psdScore = 1; // PSD有部分能量
    }
    
    // 3. 頻率增強評分 (最高5分，僅在有兩個音檔時適用)
    if (enhancementRatio !== null) {
        if (!isEnhanced) {
            enhancementScore = 0; // 未增強
        } else if (enhancementRatio < 1.3) { // 降低閾值，使其更敏感
            enhancementScore = 1; // 輕微增強
        } else if (enhancementRatio < 1.7) {
            enhancementScore = 2; // 明顯增強
        } else if (enhancementRatio < 2.5) {
            enhancementScore = 3; // 顯著增強
        } else if (enhancementRatio < 4) {
            enhancementScore = 4; // 強烈增強
        } else {
            enhancementScore = 5; // 極度增強或新頻率
        }
    } else {
        // 如果沒有比較數據，則對PSD和FFT評分給予更高權重
        fftScore = Math.min(5, Math.ceil(fftScore * 1.3));
        psdScore = Math.min(3, Math.ceil(psdScore * 1.3));
    }
    
    // 4. 峰值品質評分 (最高3分)
    if (peakQuality > 0.5) {
        qualityScore = 3; // 非常清晰的峰值
    } else if (peakQuality > 0.2) {
        qualityScore = 2; // 清晰的峰值
    } else if (peakQuality > 0.1) {
        qualityScore = 1; // 可辨識的峰值
    }
    
    // 計算總分
    const totalScore = fftScore + psdScore + enhancementScore + qualityScore;
    const maxScore = enhancementRatio !== null ? 16 : 11; // 加入峰值品質後的最高分
    
    // 計算可信度百分比
    const credibility = Math.min(100, Math.round(totalScore / maxScore * 100));
    
    return credibility;
}

// 合併接近的頻率
function mergeCloseFrequencies(results) {
    const merged = [];
    const threshold = 0.05; // 5%閾值
    
    for (const result of results) {
        let foundGroup = false;
        
        for (const group of merged) {
            // 檢查是否在閾值範圍內
            if (Math.abs(group.frequency - result.frequency) / group.frequency < threshold) {
                // 如果新結果可信度更高，更新組信息
                if (result.credibility > group.credibility) {
                    group.frequency = result.frequency;
                    group.fftMagnitude = result.fftMagnitude;
                    group.psdValue = result.psdValue;
                    group.psdConfirmed = result.psdConfirmed;
                    group.enhancementRatio = result.enhancementRatio;
                    group.isNew = result.isNew;
                }
                
                // 取平均可信度，略微提高
                group.credibility = Math.min(100, Math.round((group.credibility + result.credibility) / 2 * 1.05));
                group.count = (group.count || 1) + 1;
                foundGroup = true;
                break;
            }
        }
        
        // 如果不能合併到現有組，創建新組
        if (!foundGroup) {
            merged.push({...result, count: 1});
        }
    }
    
    return merged;
}

// 找出可視的峰值函數，用於提供給AI
function findVisiblePeaks(fftData, maxPeaks, minFreq, maxFreq) {
    // 保存峰值的數組
    const peaks = [];
    
    // 找出在選定頻率範圍內的數據
    const dataInRange = {
        frequencies: [],
        magnitudes: [],
        indices: []
    };
    
    for (let i = 0; i < fftData.frequencies.length; i++) {
        if (fftData.frequencies[i] >= minFreq && fftData.frequencies[i] <= maxFreq) {
            dataInRange.frequencies.push(fftData.frequencies[i]);
            dataInRange.magnitudes.push(fftData.magnitudes[i]);
            dataInRange.indices.push(i);
        }
    }
    
    // 如果範圍內沒有數據，返回空數組
    if (dataInRange.frequencies.length === 0) {
        return [];
    }
    
    // 計算振幅的平均值和標準差，用於識別明顯的峰值
    const sum = dataInRange.magnitudes.reduce((a, b) => a + b, 0);
    const mean = sum / dataInRange.magnitudes.length;
    
    const variance = dataInRange.magnitudes.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / dataInRange.magnitudes.length;
    const stdDev = Math.sqrt(variance);
    
    // 設置閾值，高於平均值+1.5倍標準差的可能是明顯峰值
    const threshold = mean + 1.5 * stdDev;
    
    // 在範圍內尋找局部峰值
    for (let i = 2; i < dataInRange.frequencies.length - 2; i++) {
        const mag = dataInRange.magnitudes[i];
        const freq = dataInRange.frequencies[i];
        const originalIndex = dataInRange.indices[i];
        
        // 只考慮高於閾值的點
        if (mag < threshold) continue;
        
        // 檢查是否為局部峰值
        if (mag > dataInRange.magnitudes[i-2] && 
            mag > dataInRange.magnitudes[i-1] && 
            mag > dataInRange.magnitudes[i+1] && 
            mag > dataInRange.magnitudes[i+2]) {
            
            // 計算峰值品質（與周圍點的差異）
            const quality = calculatePeakQuality(dataInRange.magnitudes, i, 2);
            
            // 添加到峰值列表
            peaks.push({
                frequency: freq,
                magnitude: mag,
                index: originalIndex,
                quality: quality,
                significance: (mag - mean) / stdDev // Z分數，表示峰值顯著性
            });
        }
    }
    
    // 按顯著性排序
    peaks.sort((a, b) => b.significance - a.significance);
    
    // 返回前N個峰值
    return peaks.slice(0, maxPeaks);
}

// 改進的AI提示詞，使其產生更精確的自然頻率分析結果
function prepareAIPrompt(resultFrequencies, fftData1, fftData2, psdData1, psdData2) {
    try {
        // 準備頻率數據JSON
        let freqDataJson = "[]";
        try {
            freqDataJson = JSON.stringify(resultFrequencies || [], null, 2);
        } catch (e) {
            console.error("序列化頻率數據時出錯:", e);
        }
        
        // 提取明顯的FFT峰值信息，不僅僅依賴算法分析
        let peakDescriptions = "";
        try {
            const fftPeaks = findVisiblePeaks(fftData2, 10, freqRangeMin, freqRangeMax);
            peakDescriptions = fftPeaks.map(peak => 
                `- 頻率 ${peak.frequency.toFixed(2)}Hz: 振幅 ${peak.magnitude.toFixed(4)}，峰值品質 ${peak.quality.toFixed(2)}`
            ).join("\n");
        } catch (e) {
            console.error("提取峰值信息時出錯:", e);
        }
        
// 改進的提示詞
        let prompt = `你是一位物理學和振動分析專家，特別擅長物體自然頻率的分析。以下是我對物體振動特性的聲學分析數據，請幫我解讀分析結果，找出物體最可能的自然頻率。請用繁體中文回應。

【重要】我需要你使用表格格式呈現結果，表格必須包含以下欄位：頻率(Hz)、可信度(%)、說明。表格內容請依照可信度由高至低排序。

分析方法說明：
我使用了音頻頻譜分析技術，通過比較敲擊桌面（對照組）與敲擊桌面上物體的聲音差異（實驗組），識別物體的自然頻率。具體流程：
1. 錄製兩個音頻：「純桌面敲擊聲音」和「物體放在桌面上敲擊的聲音」
2. 使用快速傅立葉變換(FFT)找出頻譜中的峰值頻率
3. 用功率譜密度(PSD)分析來確認這些頻率是否確實能量集中
4. 比較兩個音頻中同一頻率的強度，若某頻率在實驗組中明顯增強，則很可能是物體的自然頻率

分析頻率範圍：${freqRangeMin} - ${freqRangeMax} Hz
（只關注此頻率範圍內的結果）

從FFT圖中直接觀察到的顯著峰值：
${peakDescriptions}

經算法分析的潛在自然頻率（含可信度計算）：
${freqDataJson}

【自然頻率的物理解釋】
物體自然頻率是物體在受到沖擊後容易振動的特定頻率。當物體放在桌面上被敲擊時，如果聲音頻譜在特定頻率處出現明顯的增強，且這些頻率在純桌面敲擊時不顯著，則這些頻率很可能是物體的自然頻率。

請從兩種視角分析：
1. 直接觀察到的FFT峰值
2. 算法計算的可信度結果

重點關注：
- 在FFT圖中有明顯峰值且在PSD中得到確認的頻率
- 相比純桌面敲擊聲音，在物體+桌面敲擊聲音中顯著增強的頻率
- 峰值形狀清晰、與周圍頻率對比明顯的頻率點

請生成一個簡潔的表格，包含頻率值(Hz)、可信度百分比、以及為何該頻率可能是物體自然頻率的具體解釋。請確保表格依照可信度由高至低排序，且只包含確實可能是物體自然頻率的結果。

表格格式示例：
| 頻率(Hz) | 可信度(%) | 說明 |
|---------|----------|------|
| 1234.56 | 95% | 此頻率在FFT中表現為顯著峰值，通過PSD確認為能量集中點，且在放置物體後強度增強了X倍。峰值形狀清晰，很可能是物體的主要自然頻率。 |`;

        return prompt;
    } catch (error) {
        console.error("準備AI提示詞時發生錯誤:", error);
        return `請分析這些頻率數據並創建一個包含頻率、可信度百分比和說明的表格。分析範圍: ${freqRangeMin}-${freqRangeMax}Hz`;
    }
}

// 修改 performAIAnalysis 函數，確保添加導出按鈕
async function performAIAnalysis() {
    const aiContentContainer = document.getElementById('aiAnalysisContent');
    
    // 檢查是否有頻率數據可以分析
    if (!fftData2 || !psdData2) {
        aiContentContainer.innerHTML = '<p>沒有足夠的數據可分析。</p>';
        return;
    }
    
    // 顯示載入狀態
    aiContentContainer.innerHTML = `
        <div class="ai-loading">
            <div class="spinner"></div>
            <p>AI正在分析數據，請稍候...</p>
        </div>
    `;
    
    try {
        // 設置請求超時
        const timeout = 30000; // 30秒
        
        // 整合FFT和PSD進行分析，確保只分析指定頻率範圍內的數據
        console.log(`使用頻率範圍 ${freqRangeMin}-${freqRangeMax}Hz 進行分析`);
        const resultFrequencies = analyzeFFTAndPSD(fftData1, fftData2, psdData1, psdData2);
        
        // 驗證所有結果頻率是否在設定的範圍內
        const validResults = resultFrequencies.filter(result => 
            result.frequency >= freqRangeMin && result.frequency <= freqRangeMax
        );
        
        console.log(`過濾後的結果數: ${validResults.length}/${resultFrequencies.length}`);
        
        // 準備AI分析所需的提示文本，確保只傳遞有效的頻率結果
        const promptText = prepareAIPrompt(validResults, fftData1, fftData2, psdData1, psdData2);
        
        // 構建請求數據
        const requestData = {
            contents: [{
                parts: [{
                    text: promptText
                }]
            }]
        };
        
        // 創建AbortController用於超時處理
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        // 發送請求到Gemini API
        console.log("發送請求到Gemini API");
        const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDov2Ya3CxuExXJ1sQHnJjgZ0cvxCvIKTI", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(requestData),
            signal: controller.signal
        });
        
        // 清除超時
        clearTimeout(timeoutId);
        
        const data = await response.json();
        
        // 處理響應
        if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0].text) {
            const analysisText = data.candidates[0].content.parts[0].text;
            
            // 格式化AI回復
            const formattedAnalysis = formatTableResponse(analysisText);
            
            // 顯示結果
            aiContentContainer.innerHTML = formattedAnalysis;
            
            // 添加頻率範圍提示
            aiContentContainer.insertAdjacentHTML('afterbegin', `
                <div style="margin-bottom: 15px; font-style: italic; color: #666;">
                    分析範圍: ${freqRangeMin} - ${freqRangeMax} Hz
                </div>
            `);
            
            console.log("AI分析完成，確保導出按鈕存在");
            // 確保導出按鈕存在，無論HTML中是否已有預定義的按鈕
            setTimeout(() => {
                // 延遲添加導出區塊，確保DOM已完全更新
                setupExportButtons();
            }, 500);
            
        } else {
            throw new Error("無法獲取AI結果");
        }
    } catch (error) {
        console.error("AI分析過程中發生錯誤:", error);
        
        // 更友好的錯誤消息
        let errorMsg = "分析過程中發生錯誤";
        if (error.name === "AbortError") {
            errorMsg = "請求超時，請稍後再試";
        } else if (error.name === "RangeError" && error.message.includes("Maximum call stack size exceeded")) {
            errorMsg = "數據處理複雜度過高，請嘗試選擇較短的音頻片段";
        } else {
            errorMsg = `${error.message}`;
        }
        
        aiContentContainer.innerHTML = `
            <div style="padding: 20px; border-left: 4px solid #e74c3c; background-color: #fef5f5;">
                <p style="margin: 0; color: #e74c3c; font-weight: bold;">分析錯誤</p>
                <p style="margin-top: 10px;">${errorMsg}</p>
                <p style="margin-top: 10px;">請稍後再試或選擇不同的音頻範圍。</p>
            </div>
        `;
    }
}

// 格式化表格響應
function formatTableResponse(text) {
    try {
        // 提取表格部分，使用更簡單的方法
        let tableContent = '';
        const lines = text.split('\n');
        let tableStarted = false;
        let tableEnded = false;
        
        // 安全地提取表格行
        for (const line of lines) {
            if (line.trim().startsWith('|') && line.includes('頻率')) {
                tableStarted = true;
                tableContent += line + '\n';
            } else if (tableStarted && line.trim().startsWith('|')) {
                tableContent += line + '\n';
            } else if (tableStarted && !line.trim().startsWith('|') && line.trim().length > 0) {
                tableEnded = true;
                break;
            }
        }
        
        // 如果沒有找到表格，返回簡單的消息
        if (!tableStarted || tableContent.trim() === '') {
            return `<div class="ai-analysis-title">物體自然頻率分析結果</div>
                    <p>在頻率範圍 ${freqRangeMin}-${freqRangeMax}Hz 內未發現明確的自然頻率。請嘗試調整頻率範圍或使用不同的音頻片段。</p>`;
        }
        
        let htmlContent = `<div class="ai-analysis-title">物體自然頻率分析結果</div>`;
        
        // 解析表格
        const rows = tableContent.split('\n').filter(row => row.trim().length > 0);
        
        // 確保有足夠的行來處理
        if (rows.length < 2) {
            return htmlContent + `<p>在頻率範圍 ${freqRangeMin}-${freqRangeMax}Hz 內未找到足夠的自然頻率數據。</p>`;
        }
        
        let htmlTable = `
            <table class="natural-freq-table" style="width:100%; border-collapse:collapse; margin:20px 0;">
                <thead style="background-color:#f2f2f2;">
        `;
        
        // 處理表頭
        const headerCells = rows[0].split('|').filter(cell => cell.trim().length > 0);
        htmlTable += '<tr>';
        for (const cell of headerCells) {
            htmlTable += `<th style="padding:8px; border:1px solid #ddd; text-align:center;">${cell.trim()}</th>`;
        }
        htmlTable += '</tr></thead><tbody>';
        
        // 跳過分隔符行和表頭，處理數據行
        const dataRowsStart = rows[1].includes('-|-') ? 2 : 1;
        for (let i = dataRowsStart; i < rows.length; i++) {
            const cells = rows[i].split('|').filter(cell => cell.trim().length > 0);
            if (cells.length < 2) continue; // 跳過不完整的行
            
            // 檢查頻率是否在範圍內
            let freqValue = 0;
            try {
                // 提取第一列中的數字(頻率)
                freqValue = parseFloat(cells[0].trim().replace(/[^\d.]/g, ''));
                
                // 如果頻率超出範圍，則跳過此行
                if (freqValue < freqRangeMin || freqValue > freqRangeMax) {
                    console.warn(`跳過範圍外的頻率: ${freqValue}Hz (範圍: ${freqRangeMin}-${freqRangeMax}Hz)`);
                    continue;
                }
            } catch (e) {
                console.error("解析頻率值時出錯:", e);
            }
            
            htmlTable += '<tr>';
            
            for (let j = 0; j < cells.length; j++) {
                const cell = cells[j];
                // 對頻率列應用特殊樣式
                if (j === 0) {
                    htmlTable += `<td style="padding:8px; border:1px solid #ddd; font-weight:bold; color:#9b59b6; text-align:center;">${cell.trim()}</td>`;
                } 
                // 對可信度列應用特殊樣式（百分比）
                else if (j === 1) {
                    // 安全地解析百分比值
                    let percentValue = 0;
                    try {
                        percentValue = parseInt(cell.trim().replace(/%/g, '')) || 0;
                        percentValue = Math.max(0, Math.min(100, percentValue)); // 限制在0-100範圍內
                    } catch (e) {
                        console.error("解析百分比時出錯:", e);
                    }
                    
                    htmlTable += `
                        <td style="padding:8px; border:1px solid #ddd; text-align:center;">
                            <div style="display:flex; align-items:center; width:100%;">
                                <span style="flex:0 0 auto; margin-right:8px; font-weight:bold; white-space:nowrap;">${cell.trim()}</span>
                                <div style="flex:1; height:16px; background-color:#f0f0f0; border-radius:8px; overflow:hidden;">
                                    <div style="width:${percentValue}%; height:100%; background-color:#9b59b6; border-radius:8px;"></div>
                                </div>
                            </div>
                        </td>`;
                }
                // 對說明列應用普通樣式
                else {
                    htmlTable += `<td style="padding:8px; border:1px solid #ddd;">${cell.trim()}</td>`;
                }
            }
            
            htmlTable += '</tr>';
        }
        
        htmlTable += '</tbody></table>';
        
        // 檢查是否有任何行被添加
        if (htmlTable.indexOf('<tr>') === htmlTable.lastIndexOf('<tr>')) {
            // 只有表頭行，沒有數據行
            htmlTable += `<tr><td colspan="${headerCells.length}" style="padding:20px; text-align:center;">
                在頻率範圍 ${freqRangeMin}-${freqRangeMax}Hz 內未找到顯著的自然頻率。
            </td></tr>`;
        }
        
        htmlTable += '</tbody></table>';
        htmlContent += htmlTable;
        
        return htmlContent;
        
    } catch (error) {
        console.error("格式化表格時發生錯誤:", error);
        return `<div class="ai-analysis-title">物體自然頻率分析結果</div>
                <p>格式化結果時發生錯誤: ${error.message}</p>
                <p>分析範圍: ${freqRangeMin}-${freqRangeMax}Hz</p>`;
    }
}

// 添加 CSV 導出功能
function setupExportButtons() {
    console.log("設置導出按鈕事件");
    
    // 獲取按鈕元素
    const exportFFTBtn = document.getElementById('exportFFTBtn');
    const exportPSDBtn = document.getElementById('exportPSDBtn');
    const exportAllBtn = document.getElementById('exportAllBtn');
    
    // 添加導出 FFT 數據的事件處理
    if (exportFFTBtn) {
        console.log("找到 FFT 按鈕，添加事件處理");
        exportFFTBtn.addEventListener('click', function() {
            console.log("FFT 按鈕被點擊");
            exportFFTData();
        });
    } else {
        console.warn("未找到 FFT 導出按鈕");
    }
    
    // 添加導出 PSD 數據的事件處理
    if (exportPSDBtn) {
        console.log("找到 PSD 按鈕，添加事件處理");
        exportPSDBtn.addEventListener('click', function() {
            console.log("PSD 按鈕被點擊");
            exportPSDData();
        });
    } else {
        console.warn("未找到 PSD 導出按鈕");
    }
    
    // 添加導出所有數據的事件處理
    if (exportAllBtn) {
        console.log("找到全部數據按鈕，添加事件處理");
        exportAllBtn.addEventListener('click', function() {
            console.log("全部數據按鈕被點擊");
            exportAllData();
        });
    } else {
        console.warn("未找到全部數據導出按鈕");
    }
}

// 導出 FFT 數據為 CSV
function exportFFTData() {
    try {
        console.log("開始導出 FFT 數據");
        if (!fftData2) {
            alert('沒有可用的 FFT 數據。請先進行分析。');
            return;
        }
        
        // 創建 CSV 內容
        let csvContent = "頻率(Hz),純桌面振幅,物體+桌面振幅\n";
        
        // 獲取當前選定的頻率範圍
        const minFreq = typeof freqRangeMin !== 'undefined' ? freqRangeMin : 0;
        const maxFreq = typeof freqRangeMax !== 'undefined' ? freqRangeMax : 5000;
        
        // 遍歷頻率數據
        for (let i = 0; i < fftData2.frequencies.length; i++) {
            const freq = fftData2.frequencies[i];
            
            // 只包含選定範圍內的頻率
            if (freq >= minFreq && freq <= maxFreq) {
                // 第一個音頻的振幅（如果有）
                const mag1 = fftData1 && i < fftData1.magnitudes.length ? fftData1.magnitudes[i] : '';
                
                // 第二個音頻的振幅
                const mag2 = fftData2.magnitudes[i];
                
                // 添加到 CSV
                csvContent += `${freq.toFixed(2)},${mag1},${mag2}\n`;
            }
        }
        
        // 導出為文件
        downloadCSV(csvContent, `fft_data_${getCurrentTimeString()}.csv`);
        
    } catch (error) {
        console.error('導出 FFT 數據時發生錯誤:', error);
        alert('導出 FFT 數據時發生錯誤: ' + error.message);
    }
}

// 導出 PSD 數據為 CSV
function exportPSDData() {
    try {
        console.log("開始導出 PSD 數據");
        if (!psdData2) {
            alert('沒有可用的 PSD 數據。請先進行分析。');
            return;
        }
        
        // 創建 CSV 內容
        let csvContent = "頻率(Hz),純桌面PSD(dB/Hz),物體+桌面PSD(dB/Hz)\n";
        
        // 獲取當前選定的頻率範圍
        const minFreq = typeof freqRangeMin !== 'undefined' ? freqRangeMin : 0;
        const maxFreq = typeof freqRangeMax !== 'undefined' ? freqRangeMax : 5000;
        
        // 遍歷頻率數據
        for (let i = 0; i < psdData2.frequencies.length; i++) {
            const freq = psdData2.frequencies[i];
            
            // 只包含選定範圍內的頻率
            if (freq >= minFreq && freq <= maxFreq) {
                // 第一個音頻的 PSD（如果有）
                const psd1 = psdData1 && i < psdData1.psd.length ? 
                    (10 * Math.log10(psdData1.psd[i] + 1e-10)).toFixed(2) : '';
                
                // 第二個音頻的 PSD
                const psd2 = (10 * Math.log10(psdData2.psd[i] + 1e-10)).toFixed(2);
                
                // 添加到 CSV
                csvContent += `${freq.toFixed(2)},${psd1},${psd2}\n`;
            }
        }
        
        // 導出為文件
        downloadCSV(csvContent, `psd_data_${getCurrentTimeString()}.csv`);
        
    } catch (error) {
        console.error('導出 PSD 數據時發生錯誤:', error);
        alert('導出 PSD 數據時發生錯誤: ' + error.message);
    }
}

// 導出所有數據
function exportAllData() {
    try {
        console.log("開始導出所有數據");
        if (!fftData2 || !psdData2) {
            alert('沒有可用的數據。請先進行分析。');
            return;
        }
        
        // 創建波形數據 CSV
        let waveformCSV = "時間(秒),純桌面波形,物體+桌面波形\n";
        
        // 獲取波形數據
        const waveform1 = audioBuffer1 ? audioBuffer1.getChannelData(0) : null;
        const waveform2 = audioBuffer2.getChannelData(0);
        const sampleRate = audioBuffer2.sampleRate;
        
        // 選取適當的採樣點數量（不超過10000點以保持文件大小合理）
        const maxPoints = 10000;
        const skipInterval = Math.max(1, Math.ceil(waveform2.length / maxPoints));
        
        // 遍歷波形數據
        for (let i = 0; i < waveform2.length; i += skipInterval) {
            const time = i / sampleRate;
            const value1 = waveform1 && i < waveform1.length ? waveform1[i] : '';
            const value2 = waveform2[i];
            
            waveformCSV += `${time.toFixed(4)},${value1},${value2}\n`;
        }
        
        // 創建 FFT 數據 CSV
        let fftCSV = "頻率(Hz),純桌面振幅,物體+桌面振幅\n";
        
        // 獲取當前選定的頻率範圍
        const minFreq = typeof freqRangeMin !== 'undefined' ? freqRangeMin : 0;
        const maxFreq = typeof freqRangeMax !== 'undefined' ? freqRangeMax : 5000;
        
        // 遍歷 FFT 數據
        for (let i = 0; i < fftData2.frequencies.length; i++) {
            const freq = fftData2.frequencies[i];
            
            // 只包含選定範圍內的頻率
            if (freq >= minFreq && freq <= maxFreq) {
                const mag1 = fftData1 && i < fftData1.magnitudes.length ? fftData1.magnitudes[i] : '';
                const mag2 = fftData2.magnitudes[i];
                
                fftCSV += `${freq.toFixed(2)},${mag1},${mag2}\n`;
            }
        }
        
        // 創建 PSD 數據 CSV
        let psdCSV = "頻率(Hz),純桌面PSD(dB/Hz),物體+桌面PSD(dB/Hz)\n";
        
        // 遍歷 PSD 數據
        for (let i = 0; i < psdData2.frequencies.length; i++) {
            const freq = psdData2.frequencies[i];
            
            // 只包含選定範圍內的頻率
            if (freq >= minFreq && freq <= maxFreq) {
                const psd1 = psdData1 && i < psdData1.psd.length ? 
                    (10 * Math.log10(psdData1.psd[i] + 1e-10)).toFixed(2) : '';
                const psd2 = (10 * Math.log10(psdData2.psd[i] + 1e-10)).toFixed(2);
                
                psdCSV += `${freq.toFixed(2)},${psd1},${psd2}\n`;
            }
        }
        
        // 創建自然頻率分析結果 CSV
        let resultsCSV = "頻率(Hz),可信度(%),振幅,PSD值,PSD確認,增強比率\n";
        
        // 獲取分析結果
        const analysisResults = analyzeFFTAndPSD(fftData1, fftData2, psdData1, psdData2);
        
        // 遍歷分析結果
        for (const result of analysisResults) {
            if (result.frequency >= minFreq && result.frequency <= maxFreq) {
                resultsCSV += `${result.frequency.toFixed(2)},` +
                    `${result.credibility},` +
                    `${result.fftMagnitude.toFixed(4)},` +
                    `${result.psdValue.toFixed(4)},` +
                    `${result.psdConfirmed ? 'Y' : 'N'},` +
                    `${result.enhancementRatio ? result.enhancementRatio.toFixed(2) : 'N/A'}\n`;
            }
        }
        
        // 下載所有CSV文件
        console.log("下載所有CSV文件");
        downloadCSV(waveformCSV, `waveform_data_${getCurrentTimeString()}.csv`);
        downloadCSV(fftCSV, `fft_data_${getCurrentTimeString()}.csv`);
        downloadCSV(psdCSV, `psd_data_${getCurrentTimeString()}.csv`);
        downloadCSV(resultsCSV, `natural_frequency_results_${getCurrentTimeString()}.csv`);
        
    } catch (error) {
        console.error('導出所有數據時發生錯誤:', error);
        alert('導出所有數據時發生錯誤: ' + error.message);
    }
}

// 改進的CSV下載函數
function downloadCSV(csvContent, filename) {
    try {
        console.log(`開始下載 ${filename}`);
        
        // 使用 UTF-8 BOM 確保 Excel 能正確處理中文
        const BOM = new Uint8Array([0xEF, 0xBB, 0xBF]);
        const blob = new Blob([BOM, csvContent], { type: 'text/csv;charset=utf-8;' });
        
        // 檢查 blob 是否創建成功
        if (!(blob instanceof Blob)) {
            throw new Error("創建 Blob 失敗");
        }
        console.log(`創建了 ${blob.size} 字節的 Blob`);
        
        // 創建臨時 URL
        const url = URL.createObjectURL(blob);
        
        // 創建下載鏈接
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.style.display = 'none';
        
        // 添加到文檔並觸發點擊
        document.body.appendChild(link);
        console.log(`觸發下載...`);
        link.click();
        
        // 使用更長的超時時間
        setTimeout(function() {
            // 清理
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            console.log(`${filename} 下載處理完成`);
        }, 1000);
        
        return true;
    } catch (error) {
        console.error(`下載 ${filename} 時發生錯誤:`, error);
        alert(`下載文件時發生錯誤: ${error.message}`);
        return false;
    }
}

// 獲取當前時間字符串，用於文件名
function getCurrentTimeString() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hour = String(now.getHours()).padStart(2, '0');
    const minute = String(now.getMinutes()).padStart(2, '0');
    
    return `${year}${month}${day}_${hour}${minute}`;
}

// 添加導出樣式
function addExportStyles() {
    console.log("添加導出樣式");
    // 檢查是否已添加樣式
    if (document.getElementById('export-styles')) {
        console.log("導出樣式已存在，跳過");
        return;
    }
    
    const styleElement = document.createElement('style');
    styleElement.id = 'export-styles';
    styleElement.textContent = `
        .export-data-container {
            margin-top: 30px;
            padding: 15px;
            background-color: #f8f9fc;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .export-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .export-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .export-btn:hover {
            background-color: #2980b9;
        }

        .export-btn.primary-button {
            background-color: #9b59b6;
        }

        .export-btn.primary-button:hover {
            background-color: #8e44ad;
        }
    `;
    
    document.head.appendChild(styleElement);
    console.log("導出樣式已添加");
}

// 在分析完成後添加導出按鈕
function addExportSection() {
    console.log("嘗試添加導出區塊");
    const resultsContainer = document.getElementById('resultsContainer');
    if (!resultsContainer) {
        console.warn("未找到結果容器，無法添加導出區塊");
        return;
    }
    
    // 檢查是否已經存在導出部分
    if (document.querySelector('.export-data-container')) {
        console.log("導出區塊已存在，重新綁定事件");
        setupExportButtons();
        return;
    }
    
    console.log("創建新的導出區塊");
    // 創建導出數據部分
    const exportSection = document.createElement('div');
    exportSection.className = 'export-data-container';
    exportSection.innerHTML = `
        <h3>實驗數據導出</h3>
        <div class="export-buttons">
            <button id="exportFFTBtn" class="export-btn">導出FFT數據</button>
            <button id="exportPSDBtn" class="export-btn">導出PSD數據</button>
            <button id="exportAllBtn" class="export-btn primary-button">取得所有數據</button>
        </div>
    `;
    
    // 添加到結果容器
    resultsContainer.appendChild(exportSection);
    
    // 設置導出按鈕事件
    setupExportButtons();
    console.log("導出區塊已添加並設置事件");
}

</script>

</body>