<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>精確頻率分析工具</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            text-align: center; 
            margin: 0 auto;
            max-width: 1200px;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .chart-container { 
            width: 100%; 
            margin: 20px auto;
            height: 400px;
        }
        .chart-wrapper {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h2, h3 {
            color: #333;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        .file-upload {
            display: inline-block;
        }
        .file-upload label {
            display: inline-block;
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .file-upload label:hover {
            background: #45a049;
        }
        .file-upload input[type="file"] {
            display: none;
        }
        #fileStatus {
            margin-left: 10px;
            font-style: italic;
        }
        input[type="number"], input[type="text"] {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #0b7dda;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .frequency-ranges {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            gap: 10px;
            flex-wrap: wrap;
        }
        .frequency-range {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .frequency-range.active {
            background: #e3f2fd;
            border-color: #2196F3;
            font-weight: bold;
        }
        .custom-range {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 0 10px;
        }
        #frequencyInfo {
            margin: 20px 0;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 8px;
            line-height: 1.6;
        }
        .peak-table {
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            border-collapse: collapse;
        }
        .peak-table th, .peak-table td {
            padding: 8px 12px;
            border: 1px solid #ddd;
            text-align: center;
        }
        .peak-table th {
            background: #f5f5f5;
        }
        .peak-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .peak-highlight {
            background-color: #ffefd5 !important;
            font-weight: bold;
        }
        .loading {
            display: none;
            margin: 0 10px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .tabs {
            display: flex;
            margin: 20px 0 0 0;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
            background: #f5f5f5;
        }
        .tab.active {
            background: white;
            border-color: #ddd;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: bold;
        }
        .tab-content {
            display: none;
            padding: 20px;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
        }
        .tab-content.active {
            display: block;
        }
        .top-peaks {
            margin: 20px auto;
            padding: 15px;
            background: #fff8e1;
            border-radius: 8px;
            line-height: 1.6;
            max-width: 800px;
            border-left: 4px solid #ffc107;
        }
        .top-peak-item {
            display: inline-block;
            margin: 5px 10px;
            padding: 8px 12px;
            background: #ffecb3;
            border-radius: 4px;
            font-weight: bold;
        }
        .sampling-info {
            margin-top: 10px;
            padding: 5px 10px;
            background: #e8eaf6;
            border-radius: 4px;
            font-style: italic;
            display: none;
        }
        .axis-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
        }
        .axis-btn {
            padding: 5px 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            background: #f5f5f5;
            transition: all 0.3s;
        }
        .axis-btn.active {
            background: #e3f2fd;
            border-color: #2196F3;
            font-weight: bold;
        }
        .panel {
            margin: 15px 0;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            border-left: 4px solid #2196F3;
        }
        .data-preview {
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            text-align: left;
            font-family: monospace;
            font-size: 12px;
            background: #f5f5f5;
        }
        .column-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }
        .column-item {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
            background: white;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            text-align: left;
        }
        .advanced-settings {
            margin: 15px 0;
            padding: 15px;
            background: #f1f8e9;
            border-radius: 8px;
            border-left: 4px solid #8bc34a;
        }
        .advanced-settings-toggle {
            color: #2196F3;
            cursor: pointer;
            text-decoration: underline;
            margin-bottom: 10px;
            display: inline-block;
        }
        .advanced-settings-content {
            display: none;
        }
        .real-time-chart {
            position: relative;
            height: 150px;
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        /* 響應式設計優化 */
        @media (max-width: 768px) {
            .controls, .frequency-ranges {
                flex-direction: column;
                align-items: stretch;
            }
            .custom-range {
                flex-wrap: wrap;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>精確頻率分析工具</h2>
        
        <div class="controls">
            <div class="file-upload">
                <label for="fileInput">選擇數據檔案</label>
                <input type="file" id="fileInput" accept=".txt,.csv">
            </div>
            <span id="fileStatus">尚未選擇檔案</span>
            <div id="loading" class="loading"></div>
            
            <div class="control-group">
                <label for="samplingRate">採樣率 (Hz):</label>
                <input type="number" id="samplingRate" value="200" min="1" step="1">
                <div id="samplingInfo" class="sampling-info"></div>
                
                <button id="analyzeBtn">分析數據</button>
            </div>
        </div>
        
        <div class="warning">
            <strong>重要提示:</strong> 您的裝置採樣率為200Hz，這意味著：
            <ul>
                <li>您能夠可靠檢測的最高頻率是100Hz（即採樣率的一半）</li>
                <li>為了正確識別頻率，請確保您有足夠的數據點</li>
                <li>當測量接近100Hz的頻率時，可能需要更長的數據樣本以獲得準確結果</li>
            </ul>
        </div>
        
        <div class="advanced-settings">
            <span class="advanced-settings-toggle" id="advancedSettingsToggle">顯示高級設置</span>
            <div class="advanced-settings-content" id="advancedSettingsContent">
                <div class="control-group" style="justify-content: center; margin-bottom: 10px;">
                    <label for="windowSize">FFT視窗大小:</label>
                    <select id="windowSize">
                        <option value="auto">自動（自適應）</option>
                        <option value="128">128點</option>
                        <option value="256">256點</option>
                        <option value="512">512點</option>
                        <option value="1024">1024點</option>
                        <option value="2048">2048點</option>
                        <option value="4096">4096點</option>
                    </select>
                    
                    <label for="windowFunction">視窗函數:</label>
                    <select id="windowFunction">
                        <option value="hann">漢寧窗（Hanning）</option>
                        <option value="hamming">漢明窗（Hamming）</option>
                        <option value="blackman">布萊克曼窗（Blackman）</option>
                        <option value="rectangular">矩形窗（無窗函數）</option>
                    </select>
                    
                    <label for="zeroPadding">零填充:</label>
                    <select id="zeroPadding">
                        <option value="1">不填充</option>
                        <option value="2" selected>2倍</option>
                        <option value="4">4倍</option>
                        <option value="8">8倍</option>
                    </select>
                </div>
                
                <div class="control-group" style="justify-content: center;">
                    <label for="interpolation">頻率插值:</label>
                    <select id="interpolation">
                        <option value="none">無</option>
                        <option value="quadratic" selected>二次（改善精度）</option>
                        <option value="gaussian">高斯（最高精度）</option>
                    </select>
                    
                    <label for="peakDetection">峰值檢測敏感度:</label>
                    <select id="peakDetection">
                        <option value="low">低（只檢測主要峰值）</option>
                        <option value="medium" selected>中等</option>
                        <option value="high">高（檢測更多峰值）</option>
                    </select>
                </div>
                
                <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                    <strong>提示:</strong> 增加FFT窗口大小和零填充可提高頻率分辨率。使用插值可獲得更精確的頻率估計。
                </div>
            </div>
        </div>
        
        <div id="filePreviewPanel" style="display: none;" class="panel">
            <h3>數據預覽</h3>
            <div id="dataPreview" class="data-preview"></div>
            
            <div id="columnSelector" class="column-selector">
                <!-- 欄位選擇器將在這裡動態生成 -->
            </div>
            
            <div class="control-group" style="justify-content: center; margin-top: 10px;">
                <button id="confirmColumnsBtn">確認欄位並分析</button>
            </div>
        </div>
        
        <div id="analysisPanel" style="display: none;">
            <div class="axis-selector">
                <div class="axis-btn active" data-axis="z">Z軸數據</div>
                <div class="axis-btn" data-axis="x">X軸數據</div>
                <div class="axis-btn" data-axis="y">Y軸數據</div>
            </div>
            
            <div class="panel">
                <div id="dataInfo"></div>
            </div>
            
            <div class="chart-wrapper chart-container">
                <h3>時域圖</h3>
                <canvas id="accelerationChart"></canvas>
            </div>
            
            <div class="real-time-chart">
                <canvas id="realTimeChart"></canvas>
            </div>
            
            <div id="topPeaksContainer" class="top-peaks" style="display: none;">
                <h3>前5個最強頻率</h3>
                <div id="topPeaks"></div>
            </div>
            
            <div class="tabs">
                <div class="tab active" data-tab="frequency">頻率分析</div>
                <div class="tab" data-tab="details">詳細結果</div>
                <div class="tab" data-tab="debug">診斷信息</div>
            </div>
            
            <div id="frequencyTab" class="tab-content active">
                <div class="frequency-ranges">
                    <div class="frequency-range active" data-max="all">全頻率範圍</div>
                    <div class="frequency-range" data-max="25">0-25 Hz</div>
                    <div class="frequency-range" data-max="50">0-50 Hz</div>
                    <div class="frequency-range" data-max="75">0-75 Hz</div>
                    <div class="frequency-range" data-max="100">0-100 Hz</div>
                    
                    <div class="custom-range">
                        <label for="minFreq">自定義:</label>
                        <input type="number" id="minFreq" placeholder="最小" min="0" step="0.1" value="0">
                        <span>至</span>
                        <input type="number" id="maxFreq" placeholder="最大" min="0.1" step="0.1">
                        <button id="applyRangeBtn">應用</button>
                    </div>
                </div>
                
                <div class="chart-wrapper chart-container">
                    <canvas id="frequencyChart"></canvas>
                </div>
            </div>
            
            <div id="detailsTab" class="tab-content">
                <div id="frequencyInfo"></div>
                
                <table class="peak-table">
                    <thead>
                        <tr>
                            <th>排名</th>
                            <th>頻率 (Hz)</th>
                            <th>精確頻率 (Hz)</th>
                            <th>幅度</th>
                            <th>相對強度 (%)</th>
                        </tr>
                    </thead>
                    <tbody id="peakTableBody">
                    </tbody>
                </table>
            </div>
            
            <div id="debugTab" class="tab-content">
                <h3>診斷信息</h3>
                <div id="fftDiagnostics" class="data-preview"></div>
                
                <div class="chart-wrapper" style="height: 250px;">
                    <h4>原始波形和采样点</h4>
                    <canvas id="waveformChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 獲取DOM元素
            const fileInput = document.getElementById('fileInput');
            const fileStatus = document.getElementById('fileStatus');
            const loading = document.getElementById('loading');
            const samplingRateInput = document.getElementById('samplingRate');
            const samplingInfo = document.getElementById('samplingInfo');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const frequencyInfoElement = document.getElementById('frequencyInfo');
            const peakTableBody = document.getElementById('peakTableBody');
            const dataInfoElement = document.getElementById('dataInfo');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const frequencyRanges = document.querySelectorAll('.frequency-range');
            const minFreqInput = document.getElementById('minFreq');
            const maxFreqInput = document.getElementById('maxFreq');
            const applyRangeBtn = document.getElementById('applyRangeBtn');
            const topPeaksContainer = document.getElementById('topPeaksContainer');
            const topPeaksElement = document.getElementById('topPeaks');
            const axisBtns = document.querySelectorAll('.axis-btn');
            const filePreviewPanel = document.getElementById('filePreviewPanel');
            const dataPreview = document.getElementById('dataPreview');
            const columnSelector = document.getElementById('columnSelector');
            const confirmColumnsBtn = document.getElementById('confirmColumnsBtn');
            const analysisPanel = document.getElementById('analysisPanel');
            const advancedSettingsToggle = document.getElementById('advancedSettingsToggle');
            const advancedSettingsContent = document.getElementById('advancedSettingsContent');
            const windowSizeSelect = document.getElementById('windowSize');
            const windowFunctionSelect = document.getElementById('windowFunction');
            const zeroPaddingSelect = document.getElementById('zeroPadding');
            const interpolationSelect = document.getElementById('interpolation');
            const peakDetectionSelect = document.getElementById('peakDetection');
            const fftDiagnostics = document.getElementById('fftDiagnostics');
            
            // 高級設置切換
            advancedSettingsToggle.addEventListener('click', function() {
                if (advancedSettingsContent.style.display === 'block') {
                    advancedSettingsContent.style.display = 'none';
                    advancedSettingsToggle.textContent = '顯示高級設置';
                } else {
                    advancedSettingsContent.style.display = 'block';
                    advancedSettingsToggle.textContent = '隱藏高級設置';
                }
            });
            
            // 存儲圖表實例和數據
            let accelerationChartInstance = null;
            let frequencyChartInstance = null;
            let realTimeChartInstance = null;
            let waveformChartInstance = null;
            let allFrequencies = [];
            let currentMinFreq = 0;
            let currentMaxFreq = 'all';
            let fullDataSet = { x: [], y: [], z: [] };
            let timestamps = [];
            let samplingRate = 200;
            let detectedSamplingRate = null;
            let currentAxis = 'z';
            let fileContent = null;
            let columnData = {
                xIndex: -1,
                yIndex: -1,
                zIndex: -1,
                timeIndex: -1
            };
            let parsedData = null;
            let fftWindowSize = 'auto';
            let fftResults = {
                rawSpectrum: [],
                frequencies: [],
                spectrum: [],
                peaks: [],
                fftSize: 0,
                zeroPadded: false,
                windowFunction: 'hann',
                frequencyResolution: 0,
                effectiveResolution: 0,
                diagnostics: ''
            };
            
            // 軸選擇功能
            axisBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    axisBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    currentAxis = btn.getAttribute('data-axis');
                    
                    if (fullDataSet[currentAxis].length > 0) {
                        // 更新時域圖
                        drawAccelerationChart(fullDataSet[currentAxis], samplingRate);
                        
                        // 分析頻率
                        analyzeFrequency(fullDataSet[currentAxis], samplingRate);
                        
                        // 更新波形圖
                        drawWaveformChart(fullDataSet[currentAxis], samplingRate);
                    }
                });
            });
            
            // 標籤切換功能
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    
                    // 更新標籤狀態
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // 更新內容狀態
                    tabContents.forEach(content => content.classList.remove('active'));
                    document.getElementById(tabId + 'Tab').classList.add('active');
                });
            });
            
            // 頻率範圍切換功能
            frequencyRanges.forEach(range => {
                range.addEventListener('click', () => {
                    frequencyRanges.forEach(r => r.classList.remove('active'));
                    range.classList.add('active');
                    
                    currentMaxFreq = range.getAttribute('data-max');
                    currentMinFreq = 0;
                    
                    if (allFrequencies.length > 0) {
                        updateFrequencyChart();
                    }
                });
            });
            
            // 自定義範圍功能
            applyRangeBtn.addEventListener('click', () => {
                const minFreq = parseFloat(minFreqInput.value) || 0;
                const maxFreq = parseFloat(maxFreqInput.value);
                
                if (!isNaN(maxFreq) && maxFreq > minFreq) {
                    frequencyRanges.forEach(r => r.classList.remove('active'));
                    
                    currentMinFreq = minFreq;
                    currentMaxFreq = maxFreq;
                    
                    // 檢查最高頻率是否超過奈奎斯特頻率
                    const nyquistFreq = samplingRate / 2;
                    if (maxFreq > nyquistFreq) {
                        alert(`警告：您指定的最高頻率 ${maxFreq} Hz 超過了奈奎斯特頻率 ${nyquistFreq} Hz。\n根據採樣定理，只能可靠檢測到不超過採樣率一半的頻率。`);
                    }
                    
                    if (allFrequencies.length > 0) {
                        updateFrequencyChart();
                    }
                } else {
                    alert('請輸入有效的頻率範圍（最大值需大於最小值）');
                }
            });
            
            // 綁定文件選擇事件
            fileInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file) {
                    fileStatus.textContent = `已選擇檔案: ${file.name}`;
                    
                    // 讀取檔案預覽
                    loading.style.display = 'inline-block';
                    setTimeout(() => {
                        readFilePreview(file);
                    }, 50);
                }
            });
            
            // 綁定分析按鈕事件
            analyzeBtn.addEventListener('click', function() {
                const file = fileInput.files[0];
                if (!file) {
                    alert('請先選擇數據檔案');
                    return;
                }
                
                samplingRate = parseFloat(samplingRateInput.value) || 200;
                if (samplingRate <= 0) {
                    alert('請輸入有效的採樣率');
                    return;
                }
                
                loading.style.display = 'inline-block';
                fileStatus.textContent = '分析中...';
                
                // 讀取檔案預覽
                setTimeout(() => {
                    readFilePreview(file);
                }, 50);
            });
            
            // 綁定確認欄位按鈕事件
            confirmColumnsBtn.addEventListener('click', function() {
                // 獲取選擇的列索引
                const xSelect = document.getElementById('xColumnSelect');
                const ySelect = document.getElementById('yColumnSelect');
                const zSelect = document.getElementById('zColumnSelect');
                
                columnData.xIndex = parseInt(xSelect.value);
                columnData.yIndex = parseInt(ySelect.value);
                columnData.zIndex = parseInt(zSelect.value);
                
                // 更新採樣率
                samplingRate = parseFloat(samplingRateInput.value) || 200;
                
                // 獲取FFT參數
                fftWindowSize = windowSizeSelect.value;
                const windowFunction = windowFunctionSelect.value;
                const zeroPadding = parseInt(zeroPaddingSelect.value) || 1;
                const interpolation = interpolationSelect.value;
                const peakDetection = peakDetectionSelect.value;
                
                // 處理數據
                processParsedData(windowFunction, zeroPadding, interpolation, peakDetection);
            });
            
            // 讀取檔案預覽
            function readFilePreview(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    fileContent = e.target.result;
                    
                    // 解析數據
                    parseFileData(fileContent);
                    
                    // 顯示預覽並讓用戶選擇欄位
                    showDataPreview();
                    
                    loading.style.display = 'none';
                };
                reader.onerror = function() {
                    loading.style.display = 'none';
                    fileStatus.textContent = '讀取檔案時發生錯誤';
                };
                reader.readAsText(file);
            }
            
            // 解析檔案數據
            function parseFileData(content) {
                // 獲取前幾行來檢測格式
                const lines = content.split('\n').filter(line => line.trim().length > 0);
                
                // 檢測最可能的分隔符
                const delimiters = ['\t', ',', ' ', ';'];
                let bestDelimiter = '\t';
                let mostConsistentColumns = 0;
                
                for (const delimiter of delimiters) {
                    // 檢查前10行的列數是否一致
                    const columnsCount = lines.slice(0, Math.min(10, lines.length))
                        .map(line => line.split(delimiter).length);
                    
                    // 計算最常見的列數
                    const counts = {};
                    columnsCount.forEach(count => {
                        counts[count] = (counts[count] || 0) + 1;
                    });
                    
                    let maxCount = 0;
                    let mostCommonColumns = 0;
                    for (const count in counts) {
                        if (counts[count] > maxCount) {
                            maxCount = counts[count];
                            mostCommonColumns = parseInt(count);
                        }
                    }
                    
                    // 如果這個分隔符產生的列數更一致，則選擇它
                    if (maxCount > mostConsistentColumns && mostCommonColumns > 1) {
                        mostConsistentColumns = maxCount;
                        bestDelimiter = delimiter;
                    }
                }
                
                // 解析數據行
                const headerLine = lines[0];
                const headers = headerLine.split(bestDelimiter).map(h => h.trim());
                
                // 解析所有數據行
                const dataRows = [];
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const values = line.split(bestDelimiter).map(v => v.trim());
                    
                    // 檢查是否有足夠的列
                    if (values.length > 1) {
                        dataRows.push(values);
                    }
                }
                
                // 嘗試識別加速度數據列
                let timeIndex = -1;
                let xIndex = -1;
                let yIndex = -1;
                let zIndex = -1;
                
                // 檢查標題行是否包含關鍵詞
                for (let i = 0; i < headers.length; i++) {
                    const header = headers[i].toLowerCase();
                    if (header.includes('time') || header.includes('時間')) {
                        timeIndex = i;
                    } else if (header.includes('x') && (header.includes('acc') || header.includes('加速'))) {
                        xIndex = i;
                    } else if (header.includes('y') && (header.includes('acc') || header.includes('加速'))) {
                        yIndex = i;
                    } else if (header.includes('z') && (header.includes('acc') || header.includes('加速'))) {
                        zIndex = i;
                    }
                }
                
                // 如果標題識別失敗，則嘗試基於數據特性識別可能的列
                if (xIndex === -1 && yIndex === -1 && zIndex === -1) {
                    // 找出數值列
                    const numericColumns = [];
                    for (let i = 0; i < headers.length; i++) {
                        let numericCount = 0;
                        for (let j = 0; j < Math.min(dataRows.length, 10); j++) {
                            if (dataRows[j].length > i && !isNaN(parseFloat(dataRows[j][i]))) {
                                numericCount++;
                            }
                        }
                        if (numericCount > dataRows.length * 0.8) {
                            numericColumns.push(i);
                        }
                    }
                    
                    // 假設前三個數值列是X, Y, Z（如果有的話）
                    if (numericColumns.length >= 3) {
                        xIndex = numericColumns[0];
                        yIndex = numericColumns[1];
                        zIndex = numericColumns[2];
                    } else if (numericColumns.length > 0) {
                        // 至少選擇一個作為Z軸
                        zIndex = numericColumns[0];
                    }
                }
                
                // 存儲解析結果
                parsedData = {
                    headers,
                    dataRows,
                    delimiter: bestDelimiter,
                    timeIndex,
                    xIndex,
                    yIndex,
                    zIndex
                };
                
                // 更新欄位數據
                columnData.timeIndex = timeIndex;
                columnData.xIndex = xIndex;
                columnData.yIndex = yIndex;
                columnData.zIndex = zIndex;
                
                // 嘗試從時間戳估計採樣率
                if (timeIndex !== -1) {
                    estimateSamplingRateFromTimestamps();
                }
            }
            
            // 顯示數據預覽
            function showDataPreview() {
                if (!parsedData) return;
                
                // 顯示前10行的數據預覽
                let previewHtml = '';
                for (let i = 0; i < Math.min(10, parsedData.dataRows.length); i++) {
                    previewHtml += parsedData.dataRows[i].join(' | ') + '<br>';
                }
                dataPreview.innerHTML = previewHtml;
                
                // 創建欄位選擇器
                createColumnSelectors();
                
                // 顯示預覽面板
                filePreviewPanel.style.display = 'block';
                analysisPanel.style.display = 'none';
            }
            
            // 創建欄位選擇器
            function createColumnSelectors() {
                const headers = parsedData.headers;
                let html = '';
                
                // X軸選擇器
                html += '<div class="column-item">';
                html += '<label for="xColumnSelect">X軸數據:</label>';
                html += '<select id="xColumnSelect">';
                html += '<option value="-1">無</option>';
                for (let i = 0; i < headers.length; i++) {
                    html += `<option value="${i}" ${i === columnData.xIndex ? 'selected' : ''}>${i + 1}: ${headers[i]}</option>`;
                }
                html += '</select></div>';
                
                // Y軸選擇器
                html += '<div class="column-item">';
                html += '<label for="yColumnSelect">Y軸數據:</label>';
                html += '<select id="yColumnSelect">';
                html += '<option value="-1">無</option>';
                for (let i = 0; i < headers.length; i++) {
                    html += `<option value="${i}" ${i === columnData.yIndex ? 'selected' : ''}>${i + 1}: ${headers[i]}</option>`;
                }
                html += '</select></div>';
                
                // Z軸選擇器
                html += '<div class="column-item">';
                html += '<label for="zColumnSelect">Z軸數據:</label>';
                html += '<select id="zColumnSelect">';
                html += '<option value="-1">無</option>';
                for (let i = 0; i < headers.length; i++) {
                    html += `<option value="${i}" ${i === columnData.zIndex ? 'selected' : ''}>${i + 1}: ${headers[i]}</option>`;
                }
                html += '</select></div>';
                
                columnSelector.innerHTML = html;
            }
            
            // 從時間戳估計採樣率
            function estimateSamplingRateFromTimestamps() {
                if (!parsedData || parsedData.timeIndex === -1) return;
                
                const timestamps = [];
                const timeIntervals = [];
                
                // 嘗試解析不同格式的時間戳
                for (let i = 0; i < Math.min(parsedData.dataRows.length, 100); i++) {
                    const row = parsedData.dataRows[i];
                    if (row.length <= parsedData.timeIndex) continue;
                    
                    const timeValue = row[parsedData.timeIndex];
                    
                    // 嘗試直接解析為數字（可能是秒數或毫秒數）
                    let timestamp = parseFloat(timeValue);
                    if (!isNaN(timestamp)) {
                        timestamps.push(timestamp);
                    } else {
                        // 嘗試解析為日期時間格式
                        try {
                            const dateObj = new Date(timeValue);
                            if (!isNaN(dateObj.getTime())) {
                                timestamps.push(dateObj.getTime());
                            }
                        } catch (e) {
                            // 無法解析此時間戳
                        }
                    }
                }
                
                // 計算時間間隔
                if (timestamps.length >= 2) {
                    for (let i = 1; i < timestamps.length; i++) {
                        const interval = timestamps[i] - timestamps[i - 1];
                        if (interval > 0) {
                            timeIntervals.push(interval);
                        }
                    }
                }
                
                // 計算平均間隔和採樣率
                if (timeIntervals.length > 0) {
                    // 過濾極端值
                    const sortedIntervals = [...timeIntervals].sort((a, b) => a - b);
                    const filteredIntervals = sortedIntervals.slice(
                        Math.floor(sortedIntervals.length * 0.1),
                        Math.ceil(sortedIntervals.length * 0.9)
                    );
                    
                    // 計算平均間隔
                    const avgInterval = filteredIntervals.reduce((a, b) => a + b, 0) / filteredIntervals.length;
                    
                    // 判斷是毫秒還是秒
                    let calculatedRate;
                    if (avgInterval > 0.001 && avgInterval < 1) {
                        // 假設間隔是秒
                        calculatedRate = Math.round(1 / avgInterval);
                    } else if (avgInterval >= 1 && avgInterval < 1000) {
                        // 假設間隔是毫秒
                        calculatedRate = Math.round(1000 / avgInterval);
                    } else {
                        return; // 無法確定間隔單位
                    }
                    
                    if (calculatedRate > 0 && calculatedRate <= 10000) {
                        detectedSamplingRate = calculatedRate;
                        samplingRateInput.value = detectedSamplingRate;
                        samplingInfo.textContent = `從數據中檢測到採樣率: ${detectedSamplingRate} Hz`;
                        samplingInfo.style.display = 'block';
                    }
                }
            }
            
            // 處理解析後的數據
            function processParsedData(windowFunction = 'hann', zeroPadding = 2, interpolation = 'quadratic', peakDetection = 'medium') {
                if (!parsedData) return;
                
                // 提取每個軸的數據
                fullDataSet = { x: [], y: [], z: [] };
                timestamps = [];
                
                for (let i = 0; i < parsedData.dataRows.length; i++) {
                    const row = parsedData.dataRows[i];
                    
                    // 提取時間戳（如果有）
                    if (columnData.timeIndex !== -1 && row.length > columnData.timeIndex) {
                        timestamps.push(row[columnData.timeIndex]);
                    } else {
                        timestamps.push(i);
                    }
                    
                    // 提取X軸數據
                    if (columnData.xIndex !== -1 && row.length > columnData.xIndex) {
                        const xValue = parseFloat(row[columnData.xIndex]);
                        if (!isNaN(xValue)) {
                            fullDataSet.x.push(xValue);
                        }
                    }
                    
                    // 提取Y軸數據
                    if (columnData.yIndex !== -1 && row.length > columnData.yIndex) {
                        const yValue = parseFloat(row[columnData.yIndex]);
                        if (!isNaN(yValue)) {
                            fullDataSet.y.push(yValue);
                        }
                    }
                    
                    // 提取Z軸數據
                    if (columnData.zIndex !== -1 && row.length > columnData.zIndex) {
                        const zValue = parseFloat(row[columnData.zIndex]);
                        if (!isNaN(zValue)) {
                            fullDataSet.z.push(zValue);
                        }
                    }
                }
                
                // 獲取當前選擇的軸
                const axisData = fullDataSet[currentAxis];
                
                // 檢查是否有足夠的數據
                if (axisData.length === 0) {
                    // 嘗試使用任何有數據的軸
                    if (fullDataSet.x.length > 0) {
                        currentAxis = 'x';
                    } else if (fullDataSet.y.length > 0) {
                        currentAxis = 'y';
                    } else if (fullDataSet.z.length > 0) {
                        currentAxis = 'z';
                    } else {
                        alert('未能從檔案中提取有效數據，請檢查欄位選擇');
                        return;
                    }
                    
                    // 更新按鈕狀態
                    axisBtns.forEach(btn => {
                        if (btn.getAttribute('data-axis') === currentAxis) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                }
                
                // 使用選定的軸數據
                const currentData = fullDataSet[currentAxis];
                
                // 更新數據信息
                updateDataInfo();
                
                // 繪製時域圖
                drawAccelerationChart(currentData, samplingRate);
                
                // 繪製波形圖
                drawWaveformChart(currentData, samplingRate);
                
                // 分析頻率
                analyzeFrequency(currentData, samplingRate, fftWindowSize, windowFunction, zeroPadding, interpolation, peakDetection);
                
                // 顯示完成信息
                fileStatus.textContent = `分析完成: ${currentData.length} 個數據點`;
                
                // 顯示分析面板
                filePreviewPanel.style.display = 'none';
                analysisPanel.style.display = 'block';
                
                // 滾動到分析結果
                analysisPanel.scrollIntoView({ behavior: 'smooth' });
            }
            
            // 更新數據信息
            function updateDataInfo() {
                // 計算每個軸的統計信息
                let xStats = { min: 0, max: 0, mean: 0, stdDev: 0 };
                let yStats = { min: 0, max: 0, mean: 0, stdDev: 0 };
                let zStats = { min: 0, max: 0, mean: 0, stdDev: 0 };
                
                if (fullDataSet.x.length > 0) xStats = calculateStats(fullDataSet.x);
                if (fullDataSet.y.length > 0) yStats = calculateStats(fullDataSet.y);
                if (fullDataSet.z.length > 0) zStats = calculateStats(fullDataSet.z);
                
                // 準備顯示內容
                let html = '<h3>數據統計信息</h3>';
                
                // 添加數據長度和樣本時間
                const sampleDuration = fullDataSet[currentAxis].length / samplingRate;
                html += `<p><strong>總數據點數:</strong> ${fullDataSet[currentAxis].length} 點`;
                html += ` (樣本時間: ${sampleDuration.toFixed(2)} 秒)</p>`;
                
                // 添加採樣率和可檢測頻率
                const nyquistFreq = samplingRate / 2;
                html += `<p><strong>採樣率:</strong> ${samplingRate} Hz`;
                html += ` (可檢測頻率上限: ${nyquistFreq} Hz)</p>`;
                
                // 添加頻率分辨率信息
                const baseResolution = samplingRate / fullDataSet[currentAxis].length;
                html += `<p><strong>基本頻率分辨率:</strong> ${baseResolution.toFixed(3)} Hz`;
                
                // 如果有FFT結果，添加精確分辨率
                if (fftResults.effectiveResolution) {
                    html += ` (優化後: ${fftResults.effectiveResolution.toFixed(4)} Hz)</p>`;
                } else {
                    html += `</p>`;
                }
                
                // 建立表格顯示統計信息
                html += '<table style="width:100%; border-collapse:collapse; margin:10px 0;">';
                html += '<tr style="background:#f5f5f5">';
                html += '<th style="padding:8px; border:1px solid #ddd;">軸</th>';
                html += '<th style="padding:8px; border:1px solid #ddd;">數據點</th>';
                html += '<th style="padding:8px; border:1px solid #ddd;">最小值</th>';
                html += '<th style="padding:8px; border:1px solid #ddd;">最大值</th>';
                html += '<th style="padding:8px; border:1px solid #ddd;">平均值</th>';
                html += '<th style="padding:8px; border:1px solid #ddd;">標準差</th>';
                html += '</tr>';
                
                // X軸
                if (fullDataSet.x.length > 0) {
                    html += '<tr>';
                    html += '<td style="padding:8px; border:1px solid #ddd;">X軸</td>';
                    html += `<td style="padding:8px; border:1px solid #ddd;">${fullDataSet.x.length}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${xStats.min.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${xStats.max.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${xStats.mean.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${xStats.stdDev.toFixed(4)}</td>`;
                    html += '</tr>';
                }
                
                // Y軸
                if (fullDataSet.y.length > 0) {
                    html += '<tr>';
                    html += '<td style="padding:8px; border:1px solid #ddd;">Y軸</td>';
                    html += `<td style="padding:8px; border:1px solid #ddd;">${fullDataSet.y.length}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${yStats.min.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${yStats.max.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${yStats.mean.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${yStats.stdDev.toFixed(4)}</td>`;
                    html += '</tr>';
                }
                
                // Z軸
                if (fullDataSet.z.length > 0) {
                    html += '<tr>';
                    html += '<td style="padding:8px; border:1px solid #ddd;">Z軸</td>';
                    html += `<td style="padding:8px; border:1px solid #ddd;">${fullDataSet.z.length}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${zStats.min.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${zStats.max.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${zStats.mean.toFixed(4)}</td>`;
                    html += `<td style="padding:8px; border:1px solid #ddd;">${zStats.stdDev.toFixed(4)}</td>`;
                    html += '</tr>';
                }
                
                html += '</table>';
                html += `<p><small>點擊上方按鈕切換分析軸向 (當前: ${currentAxis.toUpperCase()}軸)</small></p>`;
                
                dataInfoElement.innerHTML = html;
            }
            
            // 計算統計數據
            function calculateStats(data) {
                if (data.length === 0) {
                    return { min: 0, max: 0, mean: 0, stdDev: 0 };
                }
                
                const min = Math.min(...data);
                const max = Math.max(...data);
                const sum = data.reduce((a, b) => a + b, 0);
                const mean = sum / data.length;
                
                // 計算標準差
                const squaredDiffs = data.map(value => Math.pow(value - mean, 2));
                const variance = squaredDiffs.reduce((a, b) => a + b, 0) / data.length;
                const stdDev = Math.sqrt(variance);
                
                return { min, max, mean, stdDev };
            }
            
            // 繪製加速度時域圖
            function drawAccelerationChart(data, samplingRate) {
                const ctx = document.getElementById('accelerationChart').getContext('2d');
                
                // 如果圖表已存在，則銷毀它
                if (accelerationChartInstance) {
                    accelerationChartInstance.destroy();
                }
                
                // 限制數據點數，避免瀏覽器崩潰
                const maxPoints = 10000;
                let displayData, timeLabels;
                
                if (data.length > maxPoints) {
                    const skipFactor = Math.ceil(data.length / maxPoints);
                    displayData = data.filter((_, i) => i % skipFactor === 0);
                    timeLabels = displayData.map((_, i) => ((i * skipFactor) / samplingRate).toFixed(3));
                } else {
                    displayData = data;
                    timeLabels = data.map((_, i) => (i / samplingRate).toFixed(3));
                }
                
                // 創建新圖表
                accelerationChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: timeLabels,
                        datasets: [{
                            label: `${currentAxis.toUpperCase()} 軸數據`,
                            data: displayData,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderWidth: 1,
                            fill: false,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${currentAxis.toUpperCase()} 軸數據隨時間變化`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '時間 (秒)'
                                },
                                ticks: {
                                    maxTicksLimit: 10
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '數值'
                                }
                            }
                        }
                    }
                });
            }
            
            // 繪製波形圖（用於診斷）
            function drawWaveformChart(data, samplingRate) {
                const ctx = document.getElementById('waveformChart').getContext('2d');
                
                // 如果圖表已存在，則銷毀它
                if (waveformChartInstance) {
                    waveformChartInstance.destroy();
                }
                
                // 只取一小段數據進行繪製，確保可以看到波形
                const maxSamplesToDraw = 200; 
                let sampleData;
                
                if (data.length > maxSamplesToDraw) {
                    // 找到信號波動最大的一段數據
                    let maxVariation = 0;
                    let bestStartIndex = 0;
                    
                    for (let i = 0; i < data.length - maxSamplesToDraw; i += maxSamplesToDraw / 4) {
                        const segment = data.slice(i, i + maxSamplesToDraw);
                        const segmentMax = Math.max(...segment);
                        const segmentMin = Math.min(...segment);
                        const variation = segmentMax - segmentMin;
                        
                        if (variation > maxVariation) {
                            maxVariation = variation;
                            bestStartIndex = i;
                        }
                    }
                    
                    sampleData = data.slice(bestStartIndex, bestStartIndex + maxSamplesToDraw);
                } else {
                    sampleData = [...data];
                }
                
                // 生成時間標籤
                const timeLabels = sampleData.map((_, i) => (i / samplingRate).toFixed(4));
                
                // 生成波形插值點 - 100倍密度
                const interpolationFactor = 100;
                const interpolatedTimePoints = [];
                const continuousWaveform = [];
                
                for (let i = 0; i < sampleData.length - 1; i++) {
                    for (let j = 0; j < interpolationFactor; j++) {
                        const t = i + j / interpolationFactor;
                        interpolatedTimePoints.push(t / samplingRate);
                        
                        // 使用線性插值
                        const alpha = j / interpolationFactor;
                        const value = sampleData[i] * (1 - alpha) + sampleData[i + 1] * alpha;
                        continuousWaveform.push(value);
                    }
                }
                
                // 創建新圖表
                waveformChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: '連續波形（估計）',
                                data: interpolatedTimePoints.map((x, i) => ({ x, y: continuousWaveform[i] })),
                                borderColor: 'rgba(54, 162, 235, 0.5)',
                                borderWidth: 1,
                                pointRadius: 0,
                                fill: false
                            },
                            {
                                label: '採樣點',
                                data: timeLabels.map((x, i) => ({ x: parseFloat(x), y: sampleData[i] })),
                                borderColor: 'rgba(255, 99, 132, 1)',
                                backgroundColor: 'rgba(255, 99, 132, 0.7)',
                                pointRadius: 4,
                                pointHoverRadius: 6,
                                showLine: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: '波形採樣示意圖'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const datasetLabel = context.dataset.label || '';
                                        const value = context.parsed.y;
                                        const time = context.parsed.x;
                                        return `${datasetLabel}: ${value.toFixed(4)} @ ${time.toFixed(4)}秒`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: '時間 (秒)'
                                },
                                ticks: {
                                    maxTicksLimit: 10
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '數值'
                                }
                            }
                        }
                    }
                });
            }
            
            // 應用窗函數
            function applyWindowFunction(data, windowType) {
                const N = data.length;
                const windowed = new Array(N);
                
                switch (windowType) {
                    case 'hamming':
                        // 漢明窗 w(n) = 0.54 - 0.46 * cos(2πn/(N-1))
                        for (let i = 0; i < N; i++) {
                            windowed[i] = data[i] * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / (N - 1)));
                        }
                        break;
                    case 'blackman':
                        // 布萊克曼窗 w(n) = 0.42 - 0.5 * cos(2πn/(N-1)) + 0.08 * cos(4πn/(N-1))
                        for (let i = 0; i < N; i++) {
                            windowed[i] = data[i] * (0.42 - 0.5 * Math.cos(2 * Math.PI * i / (N - 1)) + 0.08 * Math.cos(4 * Math.PI * i / (N - 1)));
                        }
                        break;
                    case 'rectangular':
                        // 矩形窗（不應用窗函數）
                        windowed = [...data];
                        break;
                    case 'hann':
                    default:
                        // 漢寧窗 w(n) = 0.5 * (1 - cos(2πn/(N-1)))
                        for (let i = 0; i < N; i++) {
                            windowed[i] = data[i] * (0.5 - 0.5 * Math.cos(2 * Math.PI * i / (N - 1)));
                        }
                        break;
                }
                
                return windowed;
            }
            
            // 決定最佳FFT窗口大小
            function determineBestWindowSize(dataLength, userSpecified) {
                if (userSpecified !== 'auto') {
                    return parseInt(userSpecified);
                }
                
                // 尋找最佳的窗口大小
                // 盡量使用接近數據長度的2的冪次
                const powerOfTwo = Math.floor(Math.log2(dataLength));
                let bestSize = Math.pow(2, powerOfTwo);
                
                // 如果數據長度超過了2的冪次的1.5倍，則使用更大的窗口
                if (dataLength > bestSize * 1.5 && powerOfTwo < 20) {
                    bestSize = Math.pow(2, powerOfTwo + 1);
                }
                
                return bestSize;
            }
            
            // 分析頻率 - 優化FFT實現
            function analyzeFrequency(data, samplingRate, windowSize, windowFunction, zeroPadding, interpolation, peakDetection) {
                // 清除之前的診斷信息
                let diagnostics = '';
                
                // 驗證數據
                if (data.length < 8) {
                    diagnostics += `警告: 數據點數過少 (${data.length}), 無法進行可靠的頻率分析\n`;
                    fftDiagnostics.textContent = diagnostics;
                    return;
                }
                
                // 確定窗口大小
                const actualWindowSize = determineBestWindowSize(data.length, windowSize);
                diagnostics += `FFT窗口大小: ${actualWindowSize} 點`;
                
                // 如果需要截取數據
                let processedData;
                if (data.length > actualWindowSize) {
                    // 使用中間部分的數據以避免開頭和結尾的數據質量問題
                    const startIdx = Math.floor((data.length - actualWindowSize) / 2);
                    processedData = data.slice(startIdx, startIdx + actualWindowSize);
                    diagnostics += ` (使用了數據的中間 ${actualWindowSize}/${data.length} 點)\n`;
                } else {
                    processedData = [...data];
                    if (data.length < actualWindowSize) {
                        // 如果數據點不夠，填充0至窗口大小
                        processedData = [...data, ...new Array(actualWindowSize - data.length).fill(0)];
                        diagnostics += ` (數據不足, 已填充0至 ${actualWindowSize} 點)\n`;
                    } else {
                        diagnostics += ` (使用全部 ${data.length} 個數據點)\n`;
                    }
                }
                
                // 移除直流分量（平均值）
                const mean = processedData.reduce((sum, val) => sum + val, 0) / processedData.length;
                processedData = processedData.map(val => val - mean);
                diagnostics += `移除平均值: ${mean.toFixed(6)}\n`;
                
                // 應用窗函數
                processedData = applyWindowFunction(processedData, windowFunction);
                diagnostics += `應用窗函數: ${windowFunction}\n`;
                
                // 如果開啟零填充
                let paddedData = [...processedData];
                let isPadded = false;
                if (zeroPadding > 1) {
                    const paddingLength = (processedData.length * zeroPadding) - processedData.length;
                    paddedData = [...processedData, ...new Array(paddingLength).fill(0)];
                    isPadded = true;
                    diagnostics += `應用零填充: ${zeroPadding}倍 (${processedData.length} → ${paddedData.length} 點)\n`;
                } else {
                    diagnostics += `未應用零填充\n`;
                }
                
                // 計算FFT
                const fftResult = computeFFT(paddedData);
                
                // 計算頻率分辨率
                const baseResolution = samplingRate / processedData.length;
                const effectiveResolution = isPadded ? samplingRate / paddedData.length : baseResolution;
                
                diagnostics += `基本頻率分辨率: ${baseResolution.toFixed(4)} Hz\n`;
                diagnostics += `有效頻率分辨率: ${effectiveResolution.toFixed(4)} Hz\n`;
                
                // 創建頻率數組
                const frequencies = fftResult.map((amp, index) => ({
                    freq: index * effectiveResolution,
                    amp: amp,
                    index: index
                }));
                
                // 去除0頻率(DC分量)，保留到奈奎斯特頻率
                const nyquistFreq = samplingRate / 2;
                let filteredFrequencies = frequencies.filter(f => f.freq > 0 && f.freq <= nyquistFreq);
                
                // 檢測峰值
                const peakThresholds = {
                    'low': 0.3,    // 只檢測主要峰值
                    'medium': 0.1, // 中等靈敏度
                    'high': 0.05   // 高靈敏度
                };
                
                const threshold = peakThresholds[peakDetection] || 0.1;
                const peaks = detectPeaks(filteredFrequencies, threshold);
                
                // 應用頻率插值以提高精度
                if (interpolation !== 'none') {
                    diagnostics += `應用頻率插值: ${interpolation}\n`;
                    peaks.forEach(peak => {
                        // 使用二次或高斯插值提高頻率估計精度
                        const interpolatedFreq = interpolatePeakFrequency(
                            filteredFrequencies,
                            peak.index,
                            effectiveResolution,
                            interpolation
                        );
                        peak.exactFreq = interpolatedFreq;
                    });
                }
                
                // 按幅度排序
                peaks.sort((a, b) => b.amp - a.amp);
                
                // 計算相對強度
                if (peaks.length > 0) {
                    const maxAmp = peaks[0].amp;
                    peaks.forEach(peak => {
                        peak.relativeStrength = (peak.amp / maxAmp) * 100;
                    });
                }
                
                // 保存FFT結果用於其他地方引用
                fftResults = {
                    rawSpectrum: fftResult,
                    frequencies: filteredFrequencies,
                    peaks,
                    fftSize: paddedData.length,
                    zeroPadded: isPadded,
                    windowFunction,
                    frequencyResolution: baseResolution,
                    effectiveResolution: effectiveResolution,
                    diagnostics
                };
                
                // 更新診斷信息
                if (peaks.length > 0) {
                    diagnostics += `檢測到的峰值數量: ${peaks.length}\n`;
                    diagnostics += `最強峰值頻率: ${peaks[0].exactFreq ? peaks[0].exactFreq.toFixed(4) : peaks[0].freq.toFixed(4)} Hz (幅度: ${peaks[0].amp.toFixed(6)})\n`;
                    
                    // 添加子諧波和諧波分析
                    const fundamentalFreq = peaks[0].exactFreq || peaks[0].freq;
                    diagnostics += `\n可能的諧波關係:\n`;
                    
                    // 檢查前5個峰值是否有諧波關係
                    for (let i = 0; i < Math.min(5, peaks.length); i++) {
                        const peakFreq = peaks[i].exactFreq || peaks[i].freq;
                        
                        // 檢查是否為基頻的倍數或分數
                        for (let n = 1; n <= 5; n++) {
                            const harmonicFreq = fundamentalFreq * n;
                            const subharmonicFreq = fundamentalFreq / n;
                            
                            // 計算與諧波的誤差百分比
                            const harmonicError = Math.abs((peakFreq - harmonicFreq) / harmonicFreq) * 100;
                            const subharmonicError = Math.abs((peakFreq - subharmonicFreq) / subharmonicFreq) * 100;
                            
                            // 如果誤差小於5%，則認為是諧波關係
                            if (harmonicError < 5 && n > 1) {
                                diagnostics += `- ${peakFreq.toFixed(2)} Hz 可能是 ${fundamentalFreq.toFixed(2)} Hz 的 ${n} 次諧波 (誤差: ${harmonicError.toFixed(2)}%)\n`;
                            }
                            if (subharmonicError < 5 && n > 1) {
                                diagnostics += `- ${peakFreq.toFixed(2)} Hz 可能是 ${fundamentalFreq.toFixed(2)} Hz 的 1/${n} 子諧波 (誤差: ${subharmonicError.toFixed(2)}%)\n`;
                            }
                        }
                    }
                    
                    // 如果最強峰值接近25Hz，而100Hz比較弱，可能是採樣問題
                    const freq25Peak = peaks.find(p => Math.abs((p.exactFreq || p.freq) - 25) < 2);
                    const freq100Peak = peaks.find(p => Math.abs((p.exactFreq || p.freq) - 100) < 2);
                    
                    if (freq25Peak && (!freq100Peak || freq25Peak.amp > freq100Peak.amp * 2)) {
                        diagnostics += `\n注意: 檢測到強烈的25Hz信號，而100Hz信號較弱或不存在。\n`;
                        diagnostics += `這可能是由於採樣率（${samplingRate}Hz）接近信號頻率的兩倍所導致的混疊或相位問題。\n`;
                        diagnostics += `建議: 嘗試增加採樣率或收集更長時間的數據以提高頻率估計的準確性。\n`;
                    }
                    
                    // 數據長度警告
                    const minSamplesNeeded = samplingRate / 10; // 至少需要0.1秒的數據才能可靠檢測10Hz以上的頻率
                    if (data.length < minSamplesNeeded) {
                        diagnostics += `\n警告: 數據長度過短 (${data.length} 點)，可能不足以可靠檢測低於 ${(10).toFixed(1)} Hz 的頻率。\n`;
                        diagnostics += `建議: 收集至少 ${Math.ceil(minSamplesNeeded)} 個數據點以獲得更可靠的結果。\n`;
                    }
                } else {
                    diagnostics += `未檢測到顯著峰值，可能需要調整峰值檢測敏感度或增加數據長度。\n`;
                }
                
                fftDiagnostics.textContent = diagnostics;
                
                // 顯示頻率信息
                displayFrequencyInfo(peaks, effectiveResolution, samplingRate, nyquistFreq);
                
                // 顯示前5個最強頻率
                showTopPeaks(peaks.slice(0, 5));
                
                // 更新頻率圖表
                updateFrequencyChart(filteredFrequencies, peaks);
            }
            
            // 峰值檢測函數
            function detectPeaks(frequencies, threshold) {
                const peaks = [];
                const minPeakSpacing = 2; // 最小峰值間隔為2個bin
                
                // 計算最大幅度以確定閾值
                const maxAmp = Math.max(...frequencies.map(f => f.amp));
                const minAmp = maxAmp * threshold;
                
                for (let i = 1; i < frequencies.length - 1; i++) {
                    const prev = frequencies[i - 1].amp;
                    const curr = frequencies[i].amp;
                    const next = frequencies[i + 1].amp;
                    
                    // 檢查是否為局部最大值且高於閾值
                    if (curr > prev && curr > next && curr > minAmp) {
                        // 檢查是否與已有峰值太近
                        const tooClose = peaks.some(peak => Math.abs(peak.index - frequencies[i].index) < minPeakSpacing);
                        
                        if (!tooClose) {
                            peaks.push({
                                freq: frequencies[i].freq,
                                amp: frequencies[i].amp,
                                index: frequencies[i].index
                            });
                        }
                    }
                }
                
                return peaks;
            }
            
            // 頻率插值函數（提高峰值頻率估計的精度）
            function interpolatePeakFrequency(frequencies, peakIndex, resolution, method) {
                // 確保我們有前後的點用於插值
                if (peakIndex <= 0 || peakIndex >= frequencies.length - 1) {
                    return frequencies[peakIndex].freq;
                }
                
                const prevBin = frequencies[peakIndex - 1];
                const peakBin = frequencies[peakIndex];
                const nextBin = frequencies[peakIndex + 1];
                
                if (method === 'quadratic') {
                    // 二次插值 (抛物線擬合)
                    const alpha = prevBin.amp;
                    const beta = peakBin.amp;
                    const gamma = nextBin.amp;
                    
                    // 計算峰值位置的偏移量
                    const p = 0.5 * (alpha - gamma) / (alpha - 2 * beta + gamma);
                    
                    // 加上偏移量到原始頻率
                    return peakBin.freq + p * resolution;
                } else if (method === 'gaussian') {
                    // 對數高斯插值 (更高精度，適用於窗函數處理過的數據)
                    const prevAmp = Math.log(Math.max(prevBin.amp, 1e-10));
                    const peakAmp = Math.log(Math.max(peakBin.amp, 1e-10));
                    const nextAmp = Math.log(Math.max(nextBin.amp, 1e-10));
                    
                    // 高斯擬合的峰值位置偏移量
                    const p = 0.5 * (prevAmp - nextAmp) / (prevAmp - 2 * peakAmp + nextAmp);
                    
                    return peakBin.freq + p * resolution;
                } else {
                    // 不插值
                    return peakBin.freq;
                }
            }
            
            // 計算FFT（離散傅立葉變換）- 更高精度的實現
            function computeFFT(data) {
                const n = data.length;
                const spectrum = new Array(Math.floor(n / 2) + 1).fill(0);
                
                // 直接計算DFT
                for (let f = 0; f <= Math.floor(n / 2); f++) {
                    let real = 0, imag = 0;
                    
                    for (let t = 0; t < n; t++) {
                        const angle = (2 * Math.PI * f * t) / n;
                        real += data[t] * Math.cos(angle);
                        imag -= data[t] * Math.sin(angle);
                    }
                    
                    // 計算幅度並歸一化 - 保持高頻分量的相對強度
                    spectrum[f] = 2 * Math.sqrt(real * real + imag * imag) / n;
                }
                
                // DC分量（f=0）不需要乘以2
                if (spectrum.length > 0) {
                    spectrum[0] /= 2;
                }
                
                return spectrum;
            }
            
            // 顯示前5個最強頻率
            function showTopPeaks(top5Peaks) {
                let html = '';
                
                if (top5Peaks.length === 0) {
                    html = '<div class="top-peak-item">未檢測到顯著的頻率峰值</div>';
                } else {
                    top5Peaks.forEach((peak, index) => {
                        const exactFreq = peak.exactFreq || peak.freq;
                        html += `<div class="top-peak-item">
                            ${index + 1}. ${exactFreq.toFixed(3)} Hz (強度: ${peak.amp.toFixed(6)})
                        </div>`;
                    });
                }
                
                topPeaksElement.innerHTML = html;
                topPeaksContainer.style.display = 'block';
            }
            
            // 顯示頻率信息
            function displayFrequencyInfo(peaks, resolution, samplingRate, nyquistFreq) {
                // 更新頻率信息區域
                let infoHtml = `
                    <h3>頻譜分析結果 (${currentAxis.toUpperCase()}軸)</h3>
                    <p><strong>數據信息：</strong> 採樣率 ${samplingRate} Hz, 頻率分辨率 ${resolution.toFixed(4)} Hz, 奈奎斯特頻率 ${nyquistFreq.toFixed(1)} Hz</p>
                `;
                
                if (peaks.length > 0) {
                    infoHtml += `<p><strong>最強頻率：</strong> ${(peaks[0].exactFreq || peaks[0].freq).toFixed(3)} Hz (幅度: ${peaks[0].amp.toFixed(6)})</p>`;
                    
                    // 檢查是否有100Hz附近的峰值（考慮頻率分辨率）
                    const freq100 = peaks.find(p => Math.abs((p.exactFreq || p.freq) - 100) < resolution * 2);
                    if (freq100) {
                        const freq100Index = peaks.indexOf(freq100);
                        infoHtml += `<p><strong>100Hz附近的頻率：</strong> ${(freq100.exactFreq || freq100.freq).toFixed(3)} Hz (幅度: ${freq100.amp.toFixed(6)}, 排名: ${freq100Index + 1})</p>`;
                    } else {
                        infoHtml += `<p><strong>100Hz附近未檢測到顯著頻率</strong></p>`;
                    }
                    
                    // 檢查是否有25Hz附近的峰值
                    const freq25 = peaks.find(p => Math.abs((p.exactFreq || p.freq) - 25) < resolution * 2);
                    if (freq25) {
                        const freq25Index = peaks.indexOf(freq25);
                        infoHtml += `<p><strong>25Hz附近的頻率：</strong> ${(freq25.exactFreq || freq25.freq).toFixed(3)} Hz (幅度: ${freq25.amp.toFixed(6)}, 排名: ${freq25Index + 1})</p>`;
                    }
                } else {
                    infoHtml += `<p><strong>未檢測到顯著的頻率峰值</strong> - 嘗試調整峰值檢測敏感度或增加數據長度</p>`;
                }
                
                infoHtml += `<p><strong>注意：</strong> 表格顯示按幅度排序的頻率峰值，前5個用黃色標出。</p>`;
                
                frequencyInfoElement.innerHTML = infoHtml;
                
                // 更新峰值表格
                peakTableBody.innerHTML = '';
                peaks.forEach((peak, index) => {
                    const row = document.createElement('tr');
                    if (index < 5) {
                        row.className = 'peak-highlight';
                    }
                    const exactFreq = peak.exactFreq || peak.freq;
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${peak.freq.toFixed(3)}</td>
                        <td>${exactFreq.toFixed(3)}</td>
                        <td>${peak.amp.toFixed(6)}</td>
                        <td>${peak.relativeStrength.toFixed(1)}%</td>
                    `;
                    peakTableBody.appendChild(row);
                });
            }
            
            // 更新頻率圖表
            function updateFrequencyChart(frequencies, peaks) {
                const ctx = document.getElementById('frequencyChart').getContext('2d');
                
                // 如果圖表已存在，則銷毀它
                if (frequencyChartInstance) {
                    frequencyChartInstance.destroy();
                }
                
                // 根據選擇的範圍篩選頻率
                let displayFrequencies = [...frequencies];
                let maxFreq = Infinity;
                let minFreq = currentMinFreq;
                
                if (currentMaxFreq !== 'all') {
                    maxFreq = parseFloat(currentMaxFreq);
                }
                
                displayFrequencies = frequencies.filter(f => f.freq >= minFreq && f.freq <= maxFreq);
                
                // 如果數據點過多，進行抽樣
                let sampledFrequencies = [...displayFrequencies];
                const maxDataPoints = 2000;
                
                if (displayFrequencies.length > maxDataPoints) {
                    // 創建重要頻率點集合
                    const importantFreqIndices = new Set();
                    
                    // 添加峰值索引到重要點
                    peaks.forEach(peak => {
                        for (let i = 0; i < displayFrequencies.length; i++) {
                            if (Math.abs(displayFrequencies[i].freq - peak.freq) < 0.001) {
                                importantFreqIndices.add(i);
                                // 添加峰值附近的點也作為重要點
                                for (let j = 1; j <= 2; j++) {
                                    if (i - j >= 0) importantFreqIndices.add(i - j);
                                    if (i + j < displayFrequencies.length) importantFreqIndices.add(i + j);
                                }
                                break;
                            }
                        }
                    });
                    
                    // 計算抽樣間隔
                    const skipFactor = Math.ceil(displayFrequencies.length / maxDataPoints);
                    
                    // 抽樣點 + 重要點
                    sampledFrequencies = displayFrequencies.filter((f, i) => {
                        return importantFreqIndices.has(i) || i % skipFactor === 0;
                    });
                    
                    // 確保點按頻率排序
                    sampledFrequencies.sort((a, b) => a.freq - b.freq);
                }
                
                // 獲取峰值頻率用於標記
                const peakFreqs = peaks.map(p => p.freq);
                
                // 準備顏色數組 - 標記峰值
                const backgroundColor = sampledFrequencies.map(f => {
                    const isPeak = peakFreqs.some(peakFreq => Math.abs(f.freq - peakFreq) < 0.001);
                    
                    // 找到匹配的峰值索引
                    let peakIndex = -1;
                    if (isPeak) {
                        peakIndex = peaks.findIndex(p => Math.abs(p.freq - f.freq) < 0.001);
                    }
                    
                    if (peakIndex >= 0 && peakIndex < 5) {
                        // 前5個峰值用紅色
                        return 'rgba(255, 99, 132, 0.8)';
                    } else if (peakIndex >= 5 && peakIndex < 10) {
                        // 6-10個峰值用橙色
                        return 'rgba(255, 159, 64, 0.8)';
                    } else if (peakIndex >= 0) {
                        // 其他峰值用黃色
                        return 'rgba(255, 205, 86, 0.8)';
                    } else if (Math.abs(f.freq - 100) < 1) {
                        // 標記100Hz附近的頻率為綠色
                        return 'rgba(75, 192, 192, 0.8)';
                    } else if (Math.abs(f.freq - 25) < 1) {
                        // 標記25Hz附近的頻率為紫色
                        return 'rgba(153, 102, 255, 0.8)';
                    } else {
                        // 其他點用藍色
                        return 'rgba(54, 162, 235, 0.5)';
                    }
                });
                
                // 設置頻譜圖標題
                let chartTitle = `${currentAxis.toUpperCase()}軸頻譜分析`;
                if (currentMaxFreq === 'all') {
                    if (minFreq > 0) {
                        chartTitle = `${currentAxis.toUpperCase()}軸頻譜分析 (${minFreq} Hz 以上)`;
                    } else {
                        chartTitle = `${currentAxis.toUpperCase()}軸完整頻譜分析`;
                    }
                } else {
                    chartTitle = `${currentAxis.toUpperCase()}軸頻譜分析 (${minFreq}-${maxFreq} Hz)`;
                }
                
                // 創建新圖表
                frequencyChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sampledFrequencies.map(f => f.freq.toFixed(2)),
                        datasets: [{
                            label: '頻譜幅度',
                            data: sampledFrequencies.map(f => f.amp),
                            backgroundColor: backgroundColor,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: chartTitle
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        return `頻率: ${tooltipItems[0].label} Hz`;
                                    },
                                    label: function(context) {
                                        // 檢查是否為峰值
                                        const isPeak = peakFreqs.some(peakFreq => 
                                            Math.abs(parseFloat(context.label) - peakFreq) < 0.001);
                                        
                                        let peakIndex = -1;
                                        if (isPeak) {
                                            peakIndex = peaks.findIndex(p => 
                                                Math.abs(p.freq - parseFloat(context.label)) < 0.001);
                                        }
                                        
                                        let labelText = `幅度: ${context.raw.toFixed(6)}`;
                                        
                                        if (peakIndex >= 0 && peakIndex < 5) {
                                            const peak = peaks[peakIndex];
                                            const exactFreq = peak.exactFreq || peak.freq;
                                            labelText += ` (排名 ${peakIndex + 1}, 精確頻率: ${exactFreq.toFixed(3)} Hz)`;
                                        } else if (peakIndex >= 0) {
                                            labelText += ` (排名 ${peakIndex + 1})`;
                                        }
                                        
                                        return labelText;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '頻率 (Hz)'
                                },
                                ticks: {
                                    maxTicksLimit: 20
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '幅度'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
        });
    </script>
</body>
</html>
